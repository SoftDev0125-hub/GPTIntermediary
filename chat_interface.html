<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChatGPT Assistant - AI-Powered Automation</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <script>
        for(let i = 0; i < 30; i++) {
            let particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.left = Math.random() * 100 + '%';
            particle.style.animationDelay = Math.random() * 15 + 's';
            particle.style.animationDuration = (Math.random() * 10 + 10) + 's';
            document.body.appendChild(particle);
        }
    </script>

    <div class="container">
        <div class="tab-bar">
            <button class="tab-button active" data-tab="chat">Chat</button>
            <button class="tab-button" data-tab="email">Email</button>
            <button class="tab-button" data-tab="word">Word</button>
            <button class="tab-button" data-tab="telegram">Telegram</button>
            <button class="tab-button" data-tab="slack">Slack</button>
        </div>

        <div id="chat" class="tab-content active">
            <div class="header">
                <div class="header-content">
                    <h1>ChatGPT Assistant</h1>
                    <div class="status-badge">Online</div>
                </div>
            </div>

            <div class="chat-container" id="chatContainer">
                <div class="message system">
                    <div class="message-content">
                        <strong>Welcome to ChatGPT Assistant!</strong><br>
                        Your AI-powered automation system is ready. Try:<br>
                        &bull; "Launch calculator" or "Open notepad"<br>
                        &bull; "Send email to user@example.com"<br>
                        &bull; Or ask any question!
                    </div>
                </div>
            </div>

            <div class="typing-indicator" id="typingIndicator">
                <span></span>
                <span></span>
                <span></span>
            </div>

            <div class="input-container">
                <div class="input-wrapper">
                    <input 
                        type="text" 
                        id="messageInput" 
                        placeholder="Type your message or command..."
                        autocomplete="off"
                    />
                    <button id="sendButton" class="btn">Send</button>
                </div>
            </div>
        </div>

        <div id="email" class="tab-content">
            <div class="header">
                <div class="header-content">
                    <h1>Email Management</h1>
                    <div class="status-badge">Ready</div>
                </div>
            </div>

            <div class="email-container">
                <div class="email-header">
                    <h2>Inbox</h2>
                    <div class="email-count" id="emailCount">Unread: --</div>
                    <div class="button-group">
                        <button id="unreadButton" class="btn">Unread Mail</button>
                        <button id="refreshButton" class="btn btn-secondary">Refresh</button>
                    </div>
                </div>


                <div class="email-scroll-area">
                    <div class="pagination-controls pagination-top" id="paginationControlsTop" style="display: none;">
                        <button id="prevButtonTop" class="btn btn-pagination">‚Üê Previous</button>
                        <div class="page-numbers" id="pageNumbers"></div>
                        <button id="nextButtonTop" class="btn btn-pagination">Next ‚Üí</button>
                    </div>
                    <div id="emailList" class="email-list">
                        <div class="empty-state">
                            <div class="empty-state-text">Mail</div>
                            <p>Click "Unread Mail" to load your emails</p>
                        </div>
                    </div>
                    <div class="pagination-controls" id="paginationControls" style="display: none;">
                        <button id="prevButton" class="btn btn-pagination">‚Üê Previous</button>
                        <div class="page-numbers" id="pageNumbersBottom"></div>
                        <button id="nextButton" class="btn btn-pagination">Next ‚Üí</button>
                    </div>
                </div>

                <!-- Email Detail Modal - Beautiful Dialog -->
                <div class="email-detail-modal" id="emailDetailModal" style="display: none;">
                    <div class="email-detail-overlay"></div>
                    <div class="email-detail-container">
                        <div class="email-detail-header">
                            <div class="email-detail-header-content">
                                <h2 id="detailSubject" class="email-detail-subject">Subject</h2>
                                <button class="email-close-btn" id="closeEmailBtn" aria-label="Close">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <line x1="18" y1="6" x2="6" y2="18"></line>
                                        <line x1="6" y1="6" x2="18" y2="18"></line>
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <div class="email-detail-info">
                            <div class="email-detail-info-row">
                                <div class="email-detail-info-item">
                                    <span class="email-detail-label">From:</span>
                                    <span id="detailFrom" class="email-detail-value">sender@example.com</span>
                                </div>
                                <div class="email-detail-info-item">
                                    <span class="email-detail-label">Date:</span>
                                    <span id="detailDate" class="email-detail-value">Date</span>
                                </div>
                            </div>
                        </div>
                        <div class="email-detail-body-container">
                            <div class="email-detail-body" id="detailBody">
                                <!-- Email body content here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>


        <div id="telegram" class="tab-content">
            <div class="telegram-container">
                <!-- Telegram Sidebar -->
                <div class="telegram-sidebar">
                    <div class="telegram-sidebar-header">
                        <h2>Chats</h2>
                        <button id="telegramShowButton" class="telegram-refresh-btn">Refresh</button>
                </div>
                    <div class="telegram-sidebar-content" id="telegramChatsList">
                        <div class="telegram-sidebar-empty">Click "Refresh" to load chats</div>
                    </div>
                </div>

                <!-- Telegram Main Area -->
                <div class="telegram-main">
                    <div class="telegram-header">
                        <div class="telegram-header-content">
                            <h2 id="telegramCurrentChat">Select a chat</h2>
                            <div class="telegram-header-info" id="telegramCount">-- messages</div>
                        </div>
                    </div>
                    <div class="telegram-messages-container" id="telegramMessagesContainer">
                        <div class="telegram-empty-state">
                            <div class="telegram-empty-icon">‚úàÔ∏è</div>
                            <h3>Welcome to Telegram</h3>
                            <p>Select a chat from the sidebar or click "Refresh" to load your messages</p>
                </div>
                        </div>
                    <div class="telegram-input-container" id="telegramInputContainer" style="display: none;">
                        <div class="telegram-input-wrapper">
                            <textarea 
                                id="telegramMessageInput" 
                                class="telegram-message-input" 
                                placeholder="Type a message..."
                                rows="1"
                            ></textarea>
                            <button id="telegramSendButton" class="telegram-send-button" disabled>
                                <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                                    <path d="M18 2L9 11M18 2L12 18L9 11M18 2L2 8L9 11" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </button>
                            </div>
                            </div>
                </div>
            </div>
        </div>

        <div id="word" class="tab-content">
            <div class="header">
                <div class="header-content">
                    <h1>Microsoft Word</h1>
                    <div class="status-badge">Ready</div>
                </div>
            </div>

            <div class="word-container">
                <div class="word-header">
                    <h2>Word Documents</h2>
                    <div class="button-group">
                        <button id="createWordDocButton" class="btn">Create Document</button>
                        <button id="openWordDocButton" class="btn btn-secondary">Open Document</button>
                    </div>
                </div>

                <div class="word-scroll-area">
                    <div id="wordDocumentArea" class="word-document-area">
                        <div class="empty-state">
                            <div class="empty-state-text">üìÑ</div>
                            <h3>Word Document Manager</h3>
                            <p>Create a new document or open an existing one to get started</p>
                            <div style="margin-top: 20px; text-align: left; max-width: 600px; background: rgba(0,0,0,0.05); padding: 16px; border-radius: 8px;">
                                <p style="font-weight: 600; margin-bottom: 12px;">Available Features:</p>
                                <ul style="margin: 8px 0; padding-left: 20px; line-height: 1.8;">
                                    <li>Create and open Word documents</li>
                                    <li>Add formatted text (bold, italic, underline, fonts, colors)</li>
                                    <li>Format paragraphs (alignment, spacing, indentation)</li>
                                    <li>Add headings, lists, and tables</li>
                                    <li>Find and replace text</li>
                                    <li>Configure page setup (margins, orientation, page size)</li>
                                    <li>Save documents</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Word Document Creation Modal -->
                <div class="word-modal" id="wordCreateModal" style="display: none;">
                    <div class="word-modal-content">
                        <div class="word-modal-header">
                            <h3>Create New Document</h3>
                            <button class="word-modal-close" id="wordCreateModalClose">&times;</button>
                        </div>
                        <div class="word-modal-body">
                            <div class="form-group">
                                <label for="wordFilePath">File Path:</label>
                                <div style="display: flex; gap: 8px; align-items: center;">
                                    <input type="text" id="wordFilePath" placeholder="C:\Users\Username\Documents\document.docx" style="flex: 1;" />
                                    <button type="button" id="wordFilePathBrowse" class="btn btn-secondary" style="white-space: nowrap; padding: 8px 16px;">Browse</button>
                                </div>
                                <input type="file" id="wordFilePathInput" accept=".docx" style="display: none;" />
                                <small>Enter the full path where you want to save the document, or click Browse to select a location</small>
                            </div>
                            <div class="form-group">
                                <label for="wordDocTitle">Document Title (optional):</label>
                                <input type="text" id="wordDocTitle" placeholder="My Document" />
                            </div>
                            <div class="form-group">
                                <label for="wordDocContent">Initial Content (optional):</label>
                                <textarea id="wordDocContent" rows="5" placeholder="Enter initial content for your document..."></textarea>
                            </div>
                        </div>
                        <div class="word-modal-footer">
                            <button class="btn btn-secondary" id="wordCreateCancel">Cancel</button>
                            <button class="btn" id="wordCreateSubmit">Create Document</button>
                        </div>
                    </div>
                </div>

                <!-- Word Document Open Modal -->
                <div class="word-modal" id="wordOpenModal" style="display: none;">
                    <div class="word-modal-content">
                        <div class="word-modal-header">
                            <h3>Open Document</h3>
                            <button class="word-modal-close" id="wordOpenModalClose">&times;</button>
                        </div>
                        <div class="word-modal-body">
                            <div class="form-group">
                                <label for="wordOpenFilePath">File Path:</label>
                                <div style="display: flex; gap: 8px; align-items: center;">
                                    <input type="text" id="wordOpenFilePath" placeholder="C:\Users\Username\Documents\document.docx" style="flex: 1;" />
                                    <button type="button" id="wordOpenFilePathBrowse" class="btn btn-secondary" style="white-space: nowrap; padding: 8px 16px;">Browse</button>
                                </div>
                                <input type="file" id="wordOpenFilePathInput" accept=".docx" style="display: none;" />
                                <small>Enter the full path to the Word document you want to open, or click Browse to select a file</small>
                            </div>
                        </div>
                        <div class="word-modal-footer">
                            <button class="btn btn-secondary" id="wordOpenCancel">Cancel</button>
                            <button class="btn" id="wordOpenSubmit">Open Document</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Word Document Save As Modal -->
        <div class="word-modal" id="wordSaveAsModal" style="display: none;">
            <div class="word-modal-content">
                <div class="word-modal-header">
                    <h3>Save As</h3>
                    <button class="word-modal-close" id="wordSaveAsModalClose">&times;</button>
                </div>
                <div class="word-modal-body">
                    <div class="form-group">
                        <label for="wordSaveAsFolderPath">Folder Path:</label>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <input type="text" id="wordSaveAsFolderPath" placeholder="C:\Users\Username\Documents" style="flex: 1;" />
                            <button type="button" id="wordSaveAsFolderPathBrowse" class="btn btn-secondary" style="white-space: nowrap; padding: 8px 16px;">Browse Folder</button>
                        </div>
                        <small>Select the folder where you want to save the document</small>
                    </div>
                    <div class="form-group" style="margin-top: 16px;">
                        <label for="wordSaveAsFileName">File Name:</label>
                        <input type="text" id="wordSaveAsFileName" placeholder="document.docx" style="width: 100%;" />
                        <small>Enter the file name (include .docx extension or it will be added automatically)</small>
                    </div>
                </div>
                <div class="word-modal-footer">
                    <button class="btn btn-secondary" id="wordSaveAsCancel">Cancel</button>
                    <button class="btn" id="wordSaveAsSubmit">Save</button>
                </div>
            </div>
        </div>

        <!-- Folder Browser Dialog for Save As -->
        <div class="word-modal" id="wordFolderBrowserDialog" style="display: none; z-index: 2001;">
            <div class="word-modal-content" style="max-width: 800px; width: 90%; max-height: 85vh; display: flex; flex-direction: column;">
                <div class="word-modal-header" style="flex-shrink: 0;">
                    <h3>Select Folder</h3>
                    <button class="word-modal-close" id="wordFolderBrowserDialogClose">&times;</button>
                </div>
                
                <!-- Navigation Bar -->
                <div style="padding: 8px 16px; background: #f5f5f5; border-bottom: 1px solid #ddd; display: flex; align-items: center; gap: 8px; flex-shrink: 0;">
                    <button type="button" id="wordFolderBrowserNavUp" class="word-nav-btn" title="Up" style="width: 32px; height: 32px; padding: 0; border: 1px solid #ccc; background: white; border-radius: 2px; cursor: pointer;">‚Üë</button>
                    <div id="wordFolderBrowserPathBreadcrumb" style="flex: 1; padding: 4px 8px; background: white; border: 1px solid #ccc; border-radius: 2px; font-size: 12px; color: #333; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                        <!-- Path breadcrumb will be shown here -->
                    </div>
                    <button type="button" id="wordFolderBrowserRefresh" class="word-nav-btn" title="Refresh" style="width: 32px; height: 32px; padding: 0; border: 1px solid #ccc; background: white; border-radius: 2px; cursor: pointer;">‚Üª</button>
                </div>

                <!-- Folder List -->
                <div style="flex: 1; overflow-y: auto; background: white; padding: 4px 0; min-height: 300px;">
                    <div id="wordFolderBrowserContent" style="padding: 8px;">
                        <!-- Folders will be listed here -->
                    </div>
                </div>

                <!-- Bottom Section -->
                <div style="padding: 12px 16px; background: #f5f5f5; border-top: 1px solid #ddd; flex-shrink: 0; display: flex; justify-content: flex-end; gap: 8px;">
                    <button class="btn btn-secondary" id="wordFolderBrowserCancel">Cancel</button>
                    <button class="btn" id="wordFolderBrowserSelect">Select Folder</button>
                </div>
            </div>
        </div>

        <!-- File Browser Dialog (Windows-style) -->
        <div class="word-modal" id="wordFileBrowserDialog" style="display: none; z-index: 2000;">
            <div class="word-modal-content" style="max-width: 900px; width: 90%; max-height: 85vh; display: flex; flex-direction: column;">
                <div class="word-modal-header" style="flex-shrink: 0;">
                    <h3 id="wordBrowserDialogTitle">Open</h3>
                    <button class="word-modal-close" id="wordFileBrowserDialogClose">&times;</button>
                </div>
                
                <!-- Navigation Bar -->
                <div style="padding: 8px 16px; background: #f5f5f5; border-bottom: 1px solid #ddd; display: flex; align-items: center; gap: 8px; flex-shrink: 0;">
                    <button type="button" id="wordBrowserNavBack" class="word-nav-btn" title="Back" style="width: 32px; height: 32px; padding: 0; border: 1px solid #ccc; background: white; border-radius: 2px; cursor: pointer;">‚Üê</button>
                    <button type="button" id="wordBrowserNavForward" class="word-nav-btn" title="Forward" style="width: 32px; height: 32px; padding: 0; border: 1px solid #ccc; background: white; border-radius: 2px; cursor: pointer;">‚Üí</button>
                    <button type="button" id="wordBrowserNavUp" class="word-nav-btn" title="Up" style="width: 32px; height: 32px; padding: 0; border: 1px solid #ccc; background: white; border-radius: 2px; cursor: pointer;">‚Üë</button>
                    <div id="wordBrowserPathBreadcrumb" style="flex: 1; padding: 4px 8px; background: white; border: 1px solid #ccc; border-radius: 2px; font-size: 12px; color: #333; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                        <!-- Path breadcrumb will be shown here -->
                    </div>
                    <button type="button" id="wordBrowserRefresh" class="word-nav-btn" title="Refresh" style="width: 32px; height: 32px; padding: 0; border: 1px solid #ccc; background: white; border-radius: 2px; cursor: pointer;">‚Üª</button>
                </div>

                <!-- Main Content Area -->
                <div style="display: flex; flex: 1; min-height: 0; overflow: hidden;">
                    <!-- Left Sidebar -->
                    <div style="width: 220px; background: #f9f9f9; border-right: 1px solid #ddd; padding: 12px; overflow-y: auto; flex-shrink: 0;">
                        <div style="margin-bottom: 16px;">
                            <div style="font-size: 11px; font-weight: 600; color: #666; margin-bottom: 8px; text-transform: uppercase;">Quick Access</div>
                            <div id="wordBrowserQuickAccess" style="display: flex; flex-direction: column; gap: 2px;">
                                <!-- Quick access items will be added here -->
                            </div>
                        </div>
                        <div>
                            <div style="font-size: 11px; font-weight: 600; color: #666; margin-bottom: 8px; text-transform: uppercase;">Folders</div>
                            <div id="wordBrowserFolderTree" style="display: flex; flex-direction: column; gap: 2px;">
                                <!-- Folder tree will be added here -->
                            </div>
                        </div>
                    </div>

                    <!-- Main File List -->
                    <div style="flex: 1; display: flex; flex-direction: column; overflow: hidden;">
                        <!-- File List Header -->
                        <div style="padding: 8px 16px; background: #f5f5f5; border-bottom: 1px solid #ddd; display: grid; grid-template-columns: 2fr 1.5fr 1fr; gap: 16px; font-size: 12px; font-weight: 600; color: #666; flex-shrink: 0;">
                            <div>Name</div>
                            <div>Date modified</div>
                            <div>Type</div>
                        </div>
                        <!-- File List Content -->
                        <div id="wordBrowserDialogContent" style="flex: 1; overflow-y: auto; background: white; padding: 4px 0;">
                            <!-- Files and folders will be listed here -->
                        </div>
                    </div>
                </div>

                <!-- Bottom Section -->
                <div style="padding: 12px 16px; background: #f5f5f5; border-top: 1px solid #ddd; flex-shrink: 0;">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
                        <label style="font-size: 12px; color: #333; white-space: nowrap;">File name:</label>
                        <input type="text" id="wordBrowserFileName" style="flex: 1; padding: 4px 8px; border: 1px solid #ccc; border-radius: 2px; font-size: 12px;" placeholder="Enter file name or select from list" />
                    </div>
                    <div style="display: flex; align-items: center; gap: 12px; justify-content: flex-end;">
                        <label style="font-size: 12px; color: #333; white-space: nowrap;">Files of type:</label>
                        <select id="wordBrowserFileType" style="padding: 4px 8px; border: 1px solid #ccc; border-radius: 2px; font-size: 12px; background: white;">
                            <option value=".docx">Word Documents (*.docx)</option>
                            <option value="*">All Files (*.*)</option>
                        </select>
                    </div>
                </div>

                <!-- Footer Buttons -->
                <div class="word-modal-footer" style="flex-shrink: 0;">
                    <button class="btn" id="wordFileBrowserDialogOpen" style="min-width: 80px;">Open</button>
                    <button class="btn btn-secondary" id="wordFileBrowserDialogCancel" style="min-width: 80px;">Cancel</button>
                </div>
            </div>
        </div>

        <div id="slack" class="tab-content">
            <div class="slack-container">
                <!-- Slack Sidebar -->
                <div class="slack-sidebar">
                    <div class="slack-sidebar-header">
                        <h2>Channels & Conversations</h2>
                        <button id="slackViewButton" class="slack-refresh-btn">Refresh</button>
                </div>
                    <div class="slack-sidebar-content" id="slackChannelsList">
                        <div class="slack-sidebar-empty">Click "Refresh" to load channels</div>
                    </div>
                </div>

                <!-- Slack Main Area -->
                <div class="slack-main">
                    <div class="slack-header">
                        <div class="slack-header-content">
                            <h2 id="slackCurrentChannel">Select a channel</h2>
                            <div class="slack-header-info" id="slackCount">-- messages</div>
                        </div>
                    </div>
                    <div class="slack-messages-container" id="slackMessagesContainer">
                        <div class="slack-empty-state">
                            <div class="slack-empty-icon">üí¨</div>
                            <h3>Welcome to Slack</h3>
                            <p>Select a channel from the sidebar or click "Refresh" to load your messages</p>
                </div>
                        </div>
                    <div class="slack-input-container" id="slackInputContainer" style="display: none;">
                        <div class="slack-input-wrapper">
                            <textarea 
                                id="slackMessageInput" 
                                class="slack-message-input" 
                                placeholder="Message #channel"
                                rows="1"
                            ></textarea>
                            <button id="slackSendButton" class="slack-send-button" disabled>
                                <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                                    <path d="M18 2L9 11M18 2L12 18L9 11M18 2L2 8L9 11" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </button>
                            </div>
                            </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', (e) => {
                // Prevent any keyboard shortcuts from triggering when clicking tabs
                e.preventDefault();
                e.stopPropagation();
                
                const tabName = button.dataset.tab;
                
                document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                button.classList.add('active');
                document.getElementById(tabName).classList.add('active');
                
                if (tabName === 'chat') {
                    document.getElementById('messageInput').focus();
                }
                
                // Explicitly ensure no save is triggered when switching tabs
                // The save function should only be called explicitly via the Save button or Ctrl+S
                return false;
            });
        });

        const chatContainer = document.getElementById('chatContainer');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const typingIndicator = document.getElementById('typingIndicator');

        function addMessage(text, type = 'assistant') {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            // Format the message to preserve line breaks and add proper paragraph spacing
            let formattedText = text
                .replace(/\n\n/g, '</p><p>') // Double newlines become new paragraphs
                .replace(/\n/g, '<br>') // Single newlines become line breaks
                .replace(/^(.+)$/, '<p>$1</p>'); // Wrap in paragraph tags
            
            // Enhance emoji and icon display
            formattedText = enhanceIconsAndEmojis(formattedText);
            
            contentDiv.innerHTML = formattedText;
            
            messageDiv.appendChild(contentDiv);
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        function enhanceIconsAndEmojis(text) {
            // Wrap standalone emojis in a span for better styling
            text = text.replace(/([\u{1F300}-\u{1F9FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}])/gu, '<span class="emoji-icon">$1</span>');
            
            // Convert common text patterns to visual icons
            text = text.replace(/\b(‚úì|‚úîÔ∏è|‚úÖ)/g, '<span class="icon-success">$1</span>');
            text = text.replace(/\b(‚úó|‚ùå|‚õî)/g, '<span class="icon-error">$1</span>');
            text = text.replace(/\b(‚ÑπÔ∏è|‚Ñπ|üí°)/g, '<span class="icon-info">$1</span>');
            text = text.replace(/\b(‚ö†Ô∏è|‚ö†|‚ö°)/g, '<span class="icon-warning">$1</span>');
            
            // Enhance bullet points with icons
            text = text.replace(/‚Ä¢/g, '<span class="bullet-icon">‚Ä¢</span>');
            text = text.replace(/‚Üí/g, '<span class="arrow-icon">‚Üí</span>');
            
            return text;
        }

        async function sendMessage() {
            const message = messageInput.value.trim();
            if (!message) return;

            addMessage(message, 'user');
            messageInput.value = '';
            sendButton.disabled = true;

            typingIndicator.classList.add('active');

            try {
                const response = await fetch('http://localhost:5000/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ message: message })
                });

                const data = await response.json();
                typingIndicator.classList.remove('active');

                if (response.ok) {
                    addMessage(data.response, 'assistant');
                } else {
                    addMessage(`ERROR: ${data.error || 'Unknown error'}`, 'error');
                }
            } catch (error) {
                typingIndicator.classList.remove('active');
                addMessage(`CONNECTION ERROR: ${error.message}`, 'error');
            }

            sendButton.disabled = false;
            messageInput.focus();
        }

        sendButton.addEventListener('click', sendMessage);
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });

        const unreadButton = document.getElementById('unreadButton');
        const refreshButton = document.getElementById('refreshButton');
        const emailList = document.getElementById('emailList');
        const emailCount = document.getElementById('emailCount');

        let allEmails = [];
        let totalUnread = 0;
        let currentPage = 1;
        const emailsPerPage = 10;

        function getTotalPages() {
            return Math.ceil(allEmails.length / emailsPerPage);
        }

        function goToPage(pageNum) {
            const totalPages = getTotalPages();
            if (pageNum < 1 || pageNum > totalPages) return;
            currentPage = pageNum;
            renderEmails();
        }

        function updateEmailCount() {
            if (!emailCount) return;
            const shown = allEmails.length;
            const total = totalUnread || 0;
            emailCount.textContent = `Showing ${shown} / ${total} unread`;
        }

        // Get credentials from environment (exposed by backend)
        async function getUserCredentials() {
            try {
                const response = await fetch('http://localhost:5000/get_user_credentials');
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Error fetching credentials:', error);
                return null;
            }
        }

        function renderEmails() {
            const totalPages = getTotalPages();
            const startIdx = (currentPage - 1) * emailsPerPage;
            const endIdx = startIdx + emailsPerPage;
            const paginatedEmails = allEmails.slice(startIdx, endIdx);

            const emailItems = paginatedEmails.map((email, index) => `
                <div class="email-item" data-email-index="${startIdx + index}">
                    <div class="email-from">From: ${email.from_email || 'Unknown'}</div>
                    <div class="email-subject">${email.subject || '(No Subject)'}</div>
                    <div class="email-date">${email.date || new Date().toLocaleDateString()}</div>
                </div>
            `).join('');

            emailList.innerHTML = emailItems;
            updateEmailCount();

            // Add click handlers to email items
            document.querySelectorAll('.email-item').forEach(item => {
                item.addEventListener('click', () => {
                    const emailIndex = parseInt(item.dataset.emailIndex);
                    showEmailDetail(allEmails[emailIndex]);
                });
            });

            // Update pagination controls (both top and bottom)
            updatePaginationControls(totalPages);
        }

        function showEmailDetail(email) {
            const modal = document.getElementById('emailDetailModal');
            const detailSubject = document.getElementById('detailSubject');
            const detailFrom = document.getElementById('detailFrom');
            const detailDate = document.getElementById('detailDate');
            const detailBody = document.getElementById('detailBody');

            // Populate modal with email data
            detailSubject.textContent = email.subject || '(No Subject)';
            detailFrom.textContent = email.from_email || email.from || 'Unknown';
            detailDate.textContent = email.date || new Date().toLocaleDateString();
            
            // Format body content with better readability
            const bodyContent = email.body || 'No content available';
            
            // Clear previous content
            detailBody.innerHTML = '';
            detailBody.className = 'email-detail-body';
            
            // Check if body contains HTML
            if (bodyContent.includes('<') && bodyContent.includes('>')) {
                // Render as HTML (with sanitization) - like Gmail
                detailBody.innerHTML = sanitizeHtml(bodyContent);
                detailBody.className = 'email-detail-body email-detail-body-html';
            } else {
                // Render as plain text with better formatting
                const formattedText = bodyContent
                    .replace(/\n\n+/g, '\n\n') // Normalize multiple line breaks
                    .replace(/\n/g, '<br>'); // Convert line breaks to HTML
                detailBody.innerHTML = `<div class="email-text-content">${formattedText}</div>`;
                detailBody.className = 'email-detail-body email-detail-body-text';
            }

            // Show modal with animation
            modal.style.display = 'flex';
            setTimeout(() => {
                modal.classList.add('email-modal-visible');
            }, 10);
            
            // Prevent body scroll when modal is open
            document.body.style.overflow = 'hidden';
            
            // Mark email as read in Gmail
            markEmailAsRead(email);
        }

        function closeEmailDetail() {
            const modal = document.getElementById('emailDetailModal');
            modal.classList.remove('email-modal-visible');
            setTimeout(() => {
                modal.style.display = 'none';
                document.body.style.overflow = '';
            }, 300);
        }

        async function markEmailAsRead(email) {
            try {
                // Get credentials
                const creds = await getUserCredentials();
                if (!creds || !creds.access_token) {
                    console.warn('Cannot mark email as read: credentials missing');
                    return;
                }
                
                // Call API to mark email as read
                const response = await fetch('http://localhost:8000/api/email/mark-read', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        user_credentials: creds,
                        message_id: email.message_id
                    })
                });
                
                if (response.ok) {
                    console.log(`[OK] Email marked as read: ${email.message_id}`);
                } else {
                    const error = await response.json();
                    console.error('Error marking email as read:', error.detail);
                }
            } catch (error) {
                console.error('Exception marking email as read:', error);
            }
        }

        function sanitizeHtml(html) {
            // Create a temporary container to parse HTML
            const temp = document.createElement('div');
            temp.innerHTML = html;
            
            // Remove potentially dangerous scripts and style elements
            const scripts = temp.querySelectorAll('script, style');
            scripts.forEach(el => el.remove());
            
            // Remove event handlers from all elements
            const allElements = temp.querySelectorAll('*');
            allElements.forEach(el => {
                // Remove all on* attributes (onclick, onload, etc.)
                Array.from(el.attributes).forEach(attr => {
                    if (attr.name.startsWith('on')) {
                        el.removeAttribute(attr.name);
                    }
                });
                
                // Make links safe to open in browser
                if (el.tagName === 'A') {
                    el.target = '_blank';
                    el.rel = 'noopener noreferrer';
                }
            });
            
            return temp.innerHTML;
        }

        function updatePaginationControls(totalPages) {
            const paginationControlsTop = document.getElementById('paginationControlsTop');
            const paginationControls = document.getElementById('paginationControls');
            const prevButton = document.getElementById('prevButton');
            const nextButton = document.getElementById('nextButton');
            const prevButtonTop = document.getElementById('prevButtonTop');
            const nextButtonTop = document.getElementById('nextButtonTop');

            if (totalPages > 1) {
                // Show both pagination controls
                paginationControlsTop.style.display = 'flex';
                paginationControls.style.display = 'flex';
                
                // Update button states for both top and bottom
                prevButton.disabled = currentPage === 1;
                nextButton.disabled = currentPage === totalPages;
                prevButtonTop.disabled = currentPage === 1;
                nextButtonTop.disabled = currentPage === totalPages;
                
                // Generate page numbers for both top and bottom (same structure)
                generatePageNumbers(totalPages, 'pageNumbers');
                generatePageNumbers(totalPages, 'pageNumbersBottom');
            } else {
                paginationControlsTop.style.display = 'none';
                paginationControls.style.display = 'none';
            }
        }

        function generatePageNumbers(totalPages, containerId = 'pageNumbers') {
            const pageNumbers = document.getElementById(containerId);
            if (!pageNumbers) return;
            
            let numbersHTML = '';
            
            // Show up to 7 page numbers with ellipsis for large page counts
            const maxVisible = 7;
            
            if (totalPages <= maxVisible) {
                // Show all pages
                for (let i = 1; i <= totalPages; i++) {
                    numbersHTML += `<button class="page-number ${i === currentPage ? 'active' : ''}" data-page="${i}">${i}</button>`;
                }
            } else {
                // Show first page
                numbersHTML += `<button class="page-number ${currentPage === 1 ? 'active' : ''}" data-page="1">1</button>`;
                
                if (currentPage > 3) {
                    numbersHTML += `<span class="page-ellipsis">...</span>`;
                }
                
                // Show pages around current page
                const start = Math.max(2, currentPage - 1);
                const end = Math.min(totalPages - 1, currentPage + 1);
                
                for (let i = start; i <= end; i++) {
                    numbersHTML += `<button class="page-number ${i === currentPage ? 'active' : ''}" data-page="${i}">${i}</button>`;
                }
                
                if (currentPage < totalPages - 2) {
                    numbersHTML += `<span class="page-ellipsis">...</span>`;
                }
                
                // Show last page
                numbersHTML += `<button class="page-number ${currentPage === totalPages ? 'active' : ''}" data-page="${totalPages}">${totalPages}</button>`;
            }
            
            pageNumbers.innerHTML = numbersHTML;
            
            // Add click handlers to page number buttons
            pageNumbers.querySelectorAll('.page-number').forEach(btn => {
                btn.addEventListener('click', () => {
                    const page = parseInt(btn.dataset.page);
                    goToPage(page);
                });
            });
        }

        async function loadUnreadEmails() {
            unreadButton.disabled = true;
            unreadButton.textContent = 'Loading...';
            allEmails = [];
            totalUnread = 0;
            currentPage = 1;

            try {
                // Get real credentials
                console.log('[*] Fetching credentials...');
                const creds = await getUserCredentials();
                console.log('[*] Got credentials:', {
                    access_token: creds?.access_token ? creds.access_token.substring(0, 20) + '...' : 'NONE',
                    refresh_token: creds?.refresh_token ? creds.refresh_token.substring(0, 20) + '...' : 'NONE',
                    email: creds?.email
                });
                
                if (!creds || !creds.access_token) {
                    console.error('[!] Credentials missing');
                    emailList.innerHTML = '<div class="empty-state"><div class="empty-state-text">Error</div><p>Gmail credentials not found. Please restart the app.</p></div>';
                    if (emailCount) emailCount.textContent = 'Showing 0 / -- unread';
                    unreadButton.disabled = false;
                    unreadButton.textContent = 'Unread Mail';
                    return;
                }

                console.log('[*] Requesting unread emails from backend...');
                const response = await fetch('http://localhost:8000/api/email/unread', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        user_credentials: creds,
                        max_results: 1000
                    })
                });

                console.log('[*] Response status:', response.status);
                const data = await response.json();
                console.log('[*] Response data:', data);

                if (response.ok && data.success) {
                    allEmails = data.emails || [];
                    totalUnread = typeof data.total_unread === 'number' ? data.total_unread : allEmails.length;
                    updateEmailCount();
                    console.log(`[OK] Got ${allEmails.length} emails`);
                    if (allEmails.length === 0) {
                        emailList.innerHTML = '<div class="empty-state"><div class="empty-state-text">OK</div><p>No unread emails</p></div>';
                    } else {
                        renderEmails();
                    }
                } else {
                    const errorMsg = data.error || data.detail || JSON.stringify(data);
                    console.error('[!] Backend error:', errorMsg);
                    emailList.innerHTML = `<div class="empty-state"><div class="empty-state-text">Error</div><p>${errorMsg}</p></div>`;
                    if (emailCount) emailCount.textContent = 'Showing 0 / -- unread';
                }
            } catch (error) {
                console.error('[!] Exception:', error);
                emailList.innerHTML = `<div class="empty-state"><div class="empty-state-text">Error</div><p>Exception: ${error.message}</p></div>`;
                if (emailCount) emailCount.textContent = 'Showing 0 / -- unread';
            }

            unreadButton.disabled = false;
            unreadButton.textContent = 'Unread Mail';
        }

        unreadButton.addEventListener('click', loadUnreadEmails);
        refreshButton.addEventListener('click', loadUnreadEmails);

        document.getElementById('prevButton').addEventListener('click', () => {
            goToPage(currentPage - 1);
        });

        document.getElementById('nextButton').addEventListener('click', () => {
            goToPage(currentPage + 1);
        });

        document.getElementById('prevButtonTop').addEventListener('click', () => {
            goToPage(currentPage - 1);
        });

        document.getElementById('nextButtonTop').addEventListener('click', () => {
            goToPage(currentPage + 1);
        });

        // Close email detail modal
        document.getElementById('closeEmailBtn').addEventListener('click', closeEmailDetail);
        
        // Close modal when clicking outside of it
        // Close modal when clicking on overlay or outside
        const emailDetailModal = document.getElementById('emailDetailModal');
        if (emailDetailModal) {
            emailDetailModal.addEventListener('click', (e) => {
                // Close if clicking on overlay or modal background (not the container)
                if (e.target.id === 'emailDetailModal' || e.target.classList.contains('email-detail-overlay')) {
                    closeEmailDetail();
                }
            });
            
            // Prevent closing when clicking inside the container
            const emailDetailContainer = emailDetailModal.querySelector('.email-detail-container');
            if (emailDetailContainer) {
                emailDetailContainer.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
            }
            
            // Close on ESC key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && emailDetailModal.style.display === 'flex') {
                    closeEmailDetail();
                }
            });
        }

        messageInput.focus();


        // Telegram functionality
        
        // Telegram message sending
        let currentTelegramChatId = null;
        const telegramMessageInput = document.getElementById('telegramMessageInput');
        const telegramSendButton = document.getElementById('telegramSendButton');

        // Auto-resize textarea
        if (telegramMessageInput) {
            telegramMessageInput.addEventListener('input', function() {
                this.style.height = 'auto';
                this.style.height = Math.min(this.scrollHeight, 150) + 'px';
                if (telegramSendButton) {
                    telegramSendButton.disabled = !this.value.trim() || !currentTelegramChatId;
                }
            });

            telegramMessageInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    if (telegramSendButton && !telegramSendButton.disabled) {
                        sendTelegramMessage();
                    }
                }
            });
        }

        // Send button click handler
        if (telegramSendButton) {
            telegramSendButton.addEventListener('click', sendTelegramMessage);
        }

        async function sendTelegramMessage() {
            console.log(`[DEBUG] sendTelegramMessage called, currentTelegramChatId: ${currentTelegramChatId}`);
            if (!currentTelegramChatId || !telegramMessageInput) {
                console.error('[DEBUG] Cannot send: missing currentTelegramChatId or telegramMessageInput');
                alert('Please select a chat first');
                return;
            }
            
            const text = telegramMessageInput.value.trim();
            if (!text) {
                console.error('[DEBUG] Cannot send: empty message text');
                return;
            }

            // Disable input while sending
            telegramMessageInput.disabled = true;
            if (telegramSendButton) {
                telegramSendButton.disabled = true;
                telegramSendButton.innerHTML = '<div class="telegram-send-spinner"></div>';
            }

            try {
                console.log(`[*] Sending message to Telegram chat ${currentTelegramChatId}...`);
                const response = await fetch('http://localhost:8000/api/telegram/send', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        chat_id: currentTelegramChatId,
                        text: text
                    })
                });

                console.log('[*] Response status:', response.status);
                const data = await response.json();
                console.log('[*] Response data:', data);

                if (response.ok && data.success) {
                    // Clear input
                    telegramMessageInput.value = '';
                    telegramMessageInput.style.height = 'auto';
                    
                    // Reload messages to show the new one
                    await loadTelegramMessages();
                    
                    // Re-select the current chat
                    if (currentTelegramChatId) {
                        selectTelegramChat(currentTelegramChatId);
                    }
                } else {
                    const errorMsg = data.error || data.detail || JSON.stringify(data);
                    console.error('[!] Backend error:', errorMsg);
                    alert(`Failed to send message: ${errorMsg}`);
                }
            } catch (error) {
                console.error('[!] Exception:', error);
                alert(`Failed to send message: ${error.message}`);
            } finally {
                // Re-enable input
                telegramMessageInput.disabled = false;
                if (telegramSendButton) {
                    telegramSendButton.disabled = !telegramMessageInput.value.trim() || !currentTelegramChatId;
                    telegramSendButton.innerHTML = `
                        <svg width="20" height="20" viewBox="0 0 20 20" viewBox="0 0 20 20" fill="none">
                            <path d="M18 2L9 11M18 2L12 18L9 11M18 2L2 8L9 11" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    `;
                }
            }
        }

        // Telegram functionality
        const telegramShowButton = document.getElementById('telegramShowButton');
        const telegramMessagesContainer = document.getElementById('telegramMessagesContainer');
        const telegramChatsList = document.getElementById('telegramChatsList');
        const telegramCurrentChat = document.getElementById('telegramCurrentChat');
        const telegramCount = document.getElementById('telegramCount');
        let allTelegramMessages = [];
        let messagesByChat = {};
        let currentChatId = null;
        let totalTelegramCount = 0;

        function getTelegramInitials(name) {
            if (!name) return '?';
            const parts = name.trim().split(' ');
            if (parts.length >= 2) {
                return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
            }
            return name.substring(0, 2).toUpperCase();
        }

        function getTelegramAvatarColor(name) {
            if (!name) return '#3390ec';
            let hash = 0;
            for (let i = 0; i < name.length; i++) {
                hash = name.charCodeAt(i) + ((hash << 5) - hash);
            }
            const colors = [
                '#3390ec', '#e17076', '#fdcb6e', '#6c5ce7', '#a29bfe',
                '#fd79a8', '#00b894', '#00cec9', '#55efc4', '#74b9ff'
            ];
            return colors[Math.abs(hash) % colors.length];
        }

        function formatTelegramTimestamp(timestamp) {
            if (!timestamp) return '';
            try {
                const date = new Date(timestamp);
                const now = new Date();
                const diffMs = now - date;
                const diffMins = Math.floor(diffMs / 60000);
                const diffHours = Math.floor(diffMs / 3600000);
                const diffDays = Math.floor(diffMs / 86400000);

                if (diffMins < 1) return 'now';
                if (diffMins < 60) return `${diffMins}m`;
                if (diffHours < 24) return `${diffHours}h`;
                if (diffDays < 7) return `${diffDays}d`;
                
                const month = date.toLocaleString('default', { month: 'short' });
                const day = date.getDate();
                return `${month} ${day}`;
            } catch (e) {
                return timestamp;
            }
        }

        function formatTelegramTime(timestamp) {
            if (!timestamp) return '';
            try {
                const date = new Date(timestamp);
                return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: false });
            } catch (e) {
                return timestamp;
            }
        }

        function formatTelegramMessage(text) {
            if (!text) return '';
            let formatted = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\n/g, '<br>')
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.+?)\*/g, '<em>$1</em>')
                .replace(/`(.+?)`/g, '<code>$1</code>');
            return formatted;
        }

        function groupMessagesByChat(messages) {
            const grouped = {};
            messages.forEach(msg => {
                const chatId = msg.chat_id || 'unknown';
                if (!grouped[chatId]) {
                    grouped[chatId] = {
                        chatId: chatId,
                        chatName: msg.chat_name || 'Unknown',
                        messages: []
                    };
                }
                grouped[chatId].messages.push(msg);
            });
            
            // Sort messages within each chat by timestamp
            Object.keys(grouped).forEach(chatId => {
                grouped[chatId].messages.sort((a, b) => {
                    const timeA = new Date(a.timestamp || 0).getTime();
                    const timeB = new Date(b.timestamp || 0).getTime();
                    return timeA - timeB; // Oldest first
                });
            });
            
            return grouped;
        }

        function renderTelegramChats() {
            const chats = Object.values(messagesByChat);
            chats.sort((a, b) => {
                const lastMsgA = a.messages[a.messages.length - 1];
                const lastMsgB = b.messages[b.messages.length - 1];
                const timeA = new Date(lastMsgA?.timestamp || 0).getTime();
                const timeB = new Date(lastMsgB?.timestamp || 0).getTime();
                return timeB - timeA; // Most recent first
            });

            if (chats.length === 0) {
                telegramChatsList.innerHTML = '<div class="telegram-sidebar-empty">No chats found</div>';
                return;
            }

            const chatsHTML = chats.map(chat => {
                const lastMsg = chat.messages[chat.messages.length - 1];
                const preview = lastMsg?.body ? (lastMsg.body.length > 30 ? lastMsg.body.substring(0, 30) + '...' : lastMsg.body) : 'No messages';
                const time = formatTelegramTimestamp(lastMsg?.timestamp);
                const isActive = currentChatId === chat.chatId;
                const initials = getTelegramInitials(chat.chatName);
                const avatarColor = getTelegramAvatarColor(chat.chatName);
                
                return `
                    <div class="telegram-chat-item ${isActive ? 'active' : ''}" data-chat-id="${chat.chatId}">
                        <div class="telegram-chat-avatar" style="background-color: ${avatarColor}">
                            ${initials}
                </div>
                        <div class="telegram-chat-info">
                            <div class="telegram-chat-name">${chat.chatName}</div>
                            <div class="telegram-chat-preview">${preview}</div>
                        </div>
                        <div class="telegram-chat-meta">
                            <span class="telegram-chat-time">${time}</span>
                            ${chat.messages.filter(m => !m.is_read && !m.is_sent).length > 0 ? 
                                `<span class="telegram-chat-unread">${chat.messages.filter(m => !m.is_read && !m.is_sent).length}</span>` : ''}
                        </div>
                    </div>
                `;
            }).join('');

            telegramChatsList.innerHTML = chatsHTML;

            // Add click handlers
            document.querySelectorAll('.telegram-chat-item').forEach(item => {
                item.addEventListener('click', () => {
                    const chatId = item.dataset.chatId;
                    selectTelegramChat(chatId);
                });
            });
        }

        function selectTelegramChat(chatId) {
            currentChatId = chatId;
            currentTelegramChatId = chatId;  // Update for send function
            const chat = messagesByChat[chatId];
            if (!chat) return;

            telegramCurrentChat.textContent = chat.chatName;
            telegramCount.textContent = `${chat.messages.length} messages`;

            // Render messages for this chat
            renderTelegramMessages(chat.messages);

            // Show input area
            const telegramInputContainer = document.getElementById('telegramInputContainer');
            if (telegramInputContainer) {
                telegramInputContainer.style.display = 'block';
            }

            // Update active state
            document.querySelectorAll('.telegram-chat-item').forEach(item => {
                item.classList.toggle('active', item.dataset.chatId === chatId);
            });

            // Focus input and update send button state
            const messageInput = document.getElementById('telegramMessageInput');
            if (messageInput) {
                messageInput.focus();
                // Update send button state
                if (telegramSendButton) {
                    telegramSendButton.disabled = !messageInput.value.trim() || !currentTelegramChatId;
                    console.log(`[DEBUG] Chat selected: ${chatId}, currentTelegramChatId: ${currentTelegramChatId}, send button disabled: ${telegramSendButton.disabled}`);
                }
            }
        }

        function renderTelegramMessages(messages) {
            if (!messages || messages.length === 0) {
                telegramMessagesContainer.innerHTML = '<div class="telegram-empty-state"><p>No messages in this chat</p></div>';
                return;
            }

            let lastDate = null;
            const messagesHTML = messages.map((msg, index) => {
                const msgDate = new Date(msg.timestamp || Date.now());
                const currentDate = msgDate.toDateString();
                const showDateDivider = lastDate !== currentDate;
                lastDate = currentDate;

                const timeStr = formatTelegramTime(msg.timestamp);
                const formattedBody = formatTelegramMessage(msg.body || '');
                const isSent = msg.is_sent || false;

                let html = '';
                
                // Date divider
                if (showDateDivider) {
                    const dateStr = msgDate.toLocaleDateString('en-US', { 
                        weekday: 'long', 
                        year: 'numeric', 
                        month: 'long', 
                        day: 'numeric' 
                    });
                    html += `<div class="telegram-date-divider"><span>${dateStr}</span></div>`;
                }

                // Message bubble
                html += `
                    <div class="telegram-message-wrapper ${isSent ? 'sent' : 'received'}">
                        <div class="telegram-message-bubble">
                            <div class="telegram-message-text">${formattedBody || '<em>No content</em>'}</div>
                            <div class="telegram-message-time">${timeStr}</div>
                        </div>
                    </div>
                `;

                return html;
            }).join('');

            telegramMessagesContainer.innerHTML = messagesHTML;
            telegramMessagesContainer.scrollTop = telegramMessagesContainer.scrollHeight;
        }

        function updateTelegramCount() {
            if (!telegramCount) return;
            const total = Object.values(messagesByChat).reduce((sum, ch) => sum + ch.messages.length, 0);
            telegramCount.textContent = `${total} total messages`;
        }

        async function loadTelegramMessages() {
            telegramShowButton.disabled = true;
            telegramShowButton.textContent = 'Loading...';
            allTelegramMessages = [];
            messagesByChat = {};
            currentChatId = null;
            totalTelegramCount = 0;

            try {
                console.log('[*] Requesting Telegram messages from backend...');
                const response = await fetch('http://localhost:8000/api/telegram/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        limit: 50  // Reduced from 200 to 50 for faster loading
                    })
                });

                console.log('[*] Response status:', response.status);
                
                // Handle non-OK responses (like 500 errors)
                if (!response.ok) {
                    let errorData;
                    try {
                        errorData = await response.json();
                    } catch (e) {
                        // If response is not JSON, create error object
                        const errorText = await response.text();
                        errorData = { detail: errorText || `HTTP ${response.status}: ${response.statusText}` };
                    }
                    const errorMsg = errorData.detail || errorData.error || errorData.message || JSON.stringify(errorData);
                    console.error('[!] Backend error (HTTP ' + response.status + '):', errorMsg);
                    throw new Error(errorMsg);
                }
                
                const data = await response.json();
                console.log('[*] Response data:', data);

                if (data.success) {
                    allTelegramMessages = data.messages || [];
                    totalTelegramCount = typeof data.total_count === 'number' ? data.total_count : allTelegramMessages.length;
                    
                    // Group messages by chat
                    messagesByChat = groupMessagesByChat(allTelegramMessages);
                    
                    // Render chats sidebar
                    renderTelegramChats();
                    
                    // Auto-select first chat if available
                    const chats = Object.keys(messagesByChat);
                    if (chats.length > 0) {
                        selectTelegramChat(chats[0]);
                    } else {
                        telegramMessagesContainer.innerHTML = '<div class="telegram-empty-state"><p>No messages found</p></div>';
                    }
                    
                    updateTelegramCount();
                    console.log(`[OK] Got ${allTelegramMessages.length} Telegram messages in ${chats.length} chats`);
                } else {
                    const errorMsg = data.error || data.detail || JSON.stringify(data);
                    console.error('[!] Backend error:', errorMsg);
                    
                    // Check if it's an authentication error
                    if (errorMsg.includes('not authorized') || errorMsg.includes('authenticate') || errorMsg.includes('AUTH_KEY_UNREGISTERED') || errorMsg.includes('invalid or expired') || errorMsg.includes('too many times') || errorMsg.includes('rate limit')) {
                        const isInvalidSession = errorMsg.includes('AUTH_KEY_UNREGISTERED') || errorMsg.includes('invalid or expired');
                        const needsVerificationCode = errorMsg.includes('Verification code') || errorMsg.includes('verification code required');
                        const isRateLimited = errorMsg.includes('too many times') || errorMsg.includes('rate limit') || errorMsg.includes('tried logging in too many');
                        
                        // Format error message - replace newlines with <br> for HTML display
                        const formattedErrorMsg = errorMsg.replace(/\n/g, '<br>');
                        
                        telegramMessagesContainer.innerHTML = `
                            <div class="telegram-empty-state">
                                <div class="telegram-empty-icon">üîê</div>
                                <h3>${isRateLimited ? 'Rate Limited - Please Wait' : isInvalidSession ? 'Invalid Session File' : needsVerificationCode ? 'Verification Code Required' : 'Authentication Required'}</h3>
                                <div style="margin-top: 12px; padding: 16px; background: rgba(0,0,0,0.05); border-radius: 8px; max-width: 600px; text-align: left; margin-left: auto; margin-right: auto;">
                                    <p style="font-size: 13px; color: #2b2b2b; line-height: 1.8; white-space: pre-line; margin: 0; font-family: 'Segoe UI', sans-serif;">${formattedErrorMsg}</p>
                                </div>
                                <p style="margin-top: 20px; font-size: 13px; color: #707579; max-width: 500px; line-height: 1.6;">
                                    ${needsVerificationCode ? 
                                        'This app doesn\'t have a verification code input. ' : 
                                        isInvalidSession ? 
                                            'Your Telegram session file is invalid or expired. ' : 
                                            'Your Telegram client is not authenticated. '
                                    }
                                    ${needsVerificationCode ? 
                                        'Please run the authentication script in your terminal:' : 
                                        'Please follow these steps:'
                                    }
                                </p>
                                ${isRateLimited ? `
                                    <div style="margin-top: 20px; text-align: left; max-width: 500px; background: rgba(255, 193, 7, 0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #ffc107;">
                                        <div style="color: #707579; font-size: 13px; line-height: 1.8;">
                                            <p style="margin-bottom: 12px; font-weight: 600; color: #856404;">‚ö†Ô∏è Rate Limit Active</p>
                                            <p>Telegram has temporarily blocked authentication attempts. This usually happens when:</p>
                                            <ul style="margin: 8px 0; padding-left: 20px;">
                                                <li>Too many verification code requests were made</li>
                                                <li>Multiple failed authentication attempts occurred</li>
                                            </ul>
                                            <p style="margin-top: 12px; font-weight: 600;">What to do:</p>
                                            <ol style="margin: 8px 0; padding-left: 20px;">
                                                <li><strong>Wait 24 hours</strong> for the rate limit to reset</li>
                                                <li>Then try authenticating again: <code style="background: rgba(0,0,0,0.1); padding: 2px 6px; border-radius: 4px;">python authenticate_telegram.py</code></li>
                                                <li>Make sure to enter the verification code correctly on the first try</li>
                                            </ol>
                                        </div>
                                    </div>
                                ` : needsVerificationCode ? `
                                    <div style="margin-top: 20px; text-align: left; max-width: 500px; background: rgba(0,0,0,0.05); padding: 16px; border-radius: 8px;">
                                        <div style="color: #707579; font-size: 13px; line-height: 1.8;">
                                            <p style="margin-bottom: 12px; font-weight: 600; color: #2b2b2b;">Run this command in your terminal:</p>
                                            <code style="display: block; background: rgba(0,0,0,0.1); padding: 12px; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 13px; color: #2b2b2b; margin-bottom: 12px;">
                                                python authenticate_telegram.py
                                            </code>
                                            <p style="margin-top: 12px;">This will open a window where you can enter your verification code from the Telegram app.</p>
                                        </div>
                                    </div>
                                ` : `
                                    <div style="margin-top: 20px; text-align: left; max-width: 500px; background: rgba(0,0,0,0.05); padding: 16px; border-radius: 8px;">
                                        <ol style="color: #707579; font-size: 13px; line-height: 1.8; margin-left: 20px;">
                                            <li>Stop your backend server (Ctrl+C)</li>
                                            <li>Run: <code style="background: rgba(0,0,0,0.1); padding: 2px 6px; border-radius: 4px;">python authenticate_telegram.py</code></li>
                                            <li>Follow the prompts to enter your phone number and verification code</li>
                                            <li>Restart your backend server</li>
                                            <li>Click "Refresh" again</li>
                                        </ol>
                                    </div>
                                    <button id="deleteTelegramSessionBtn" class="telegram-delete-session-btn" style="margin-top: 20px; padding: 10px 20px; background: #e17076; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
                                        Delete Session File (requires server restart)
                                    </button>
                                `}
                            </div>
                        `;
                        
                        // Add click handler for delete session button
                        const deleteBtn = document.getElementById('deleteTelegramSessionBtn');
                        if (deleteBtn) {
                            deleteBtn.addEventListener('click', async () => {
                                if (confirm('This will delete your Telegram session file. You will need to restart the server and authenticate again. Continue?')) {
                                    try {
                                        const response = await fetch('http://localhost:8000/api/telegram/delete-session', {
                                            method: 'POST'
                                        });
                                        const data = await response.json();
                                        if (response.ok && data.success) {
                                            alert(data.message || 'Session file deleted. Please restart your backend server and click Refresh to authenticate.');
                                        } else {
                                            alert('Failed to delete session file: ' + (data.detail || data.message || 'Unknown error'));
                                        }
                                    } catch (error) {
                                        alert('Error deleting session file: ' + error.message);
                                    }
                                }
                            });
                        }
                    } else {
                        telegramMessagesContainer.innerHTML = `<div class="telegram-empty-state"><div class="telegram-empty-icon">‚ö†Ô∏è</div><h3>Error</h3><p>${errorMsg}</p></div>`;
                    }
                    telegramChatsList.innerHTML = '<div class="telegram-sidebar-empty">Error loading chats</div>';
                    if (telegramCount) telegramCount.textContent = 'Error';
        }
            } catch (error) {
                console.error('[!] Exception:', error);
                const errorMsg = error.message || 'Unknown error';
                
                // Check if it's an authentication error
                if (errorMsg.includes('not authorized') || errorMsg.includes('authenticate') || errorMsg.includes('AUTH_KEY_UNREGISTERED') || errorMsg.includes('invalid or expired')) {
                    const isInvalidSession = errorMsg.includes('AUTH_KEY_UNREGISTERED') || errorMsg.includes('invalid or expired');
                    const needsVerificationCode = errorMsg.includes('Verification code') || errorMsg.includes('verification code required');
                    
                    telegramMessagesContainer.innerHTML = `
                        <div class="telegram-empty-state">
                            <div class="telegram-empty-icon">üîê</div>
                            <h3>${isInvalidSession ? 'Invalid Session File' : needsVerificationCode ? 'Verification Code Required' : 'Authentication Required'}</h3>
                            <p>Exception: ${errorMsg}</p>
                                <p style="margin-top: 16px; font-size: 13px; color: #707579; max-width: 500px; line-height: 1.6;">
                                    ${isRateLimited ? 
                                        'Telegram has temporarily blocked authentication attempts due to too many login attempts. ' : 
                                        needsVerificationCode ? 
                                            'This app doesn\'t have a verification code input. ' : 
                                            isInvalidSession ? 
                                                'Your Telegram session file is invalid or expired. ' : 
                                                'Your Telegram client is not authenticated. '
                                    }
                                    ${isRateLimited ? 
                                        'Please wait 24 hours before trying to authenticate again. ' : 
                                        needsVerificationCode ? 
                                            'Please run the authentication script in your terminal:' : 
                                            'Please follow these steps:'
                                    }
                                </p>
                            ${needsVerificationCode ? `
                                <div style="margin-top: 20px; text-align: left; max-width: 500px; background: rgba(0,0,0,0.05); padding: 16px; border-radius: 8px;">
                                    <div style="color: #707579; font-size: 13px; line-height: 1.8;">
                                        <p style="margin-bottom: 12px; font-weight: 600; color: #2b2b2b;">Run this command in your terminal:</p>
                                        <code style="display: block; background: rgba(0,0,0,0.1); padding: 12px; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 13px; color: #2b2b2b; margin-bottom: 12px;">
                                            python authenticate_telegram.py
                                        </code>
                                        <p style="margin-top: 12px;">This will open a window where you can enter your verification code from the Telegram app.</p>
                                    </div>
                                </div>
                            ` : `
                                <div style="margin-top: 20px; text-align: left; max-width: 500px; background: rgba(0,0,0,0.05); padding: 16px; border-radius: 8px;">
                                    <ol style="color: #707579; font-size: 13px; line-height: 1.8; margin-left: 20px;">
                                        <li>Stop your backend server (Ctrl+C)</li>
                                        <li>Run: <code style="background: rgba(0,0,0,0.1); padding: 2px 6px; border-radius: 4px;">python authenticate_telegram.py</code></li>
                                        <li>Follow the prompts to enter your phone number and verification code</li>
                                        <li>Restart your backend server</li>
                                        <li>Click "Refresh" again</li>
                                    </ol>
                                </div>
                                <button id="deleteTelegramSessionBtn2" class="telegram-delete-session-btn" style="margin-top: 20px; padding: 10px 20px; background: #e17076; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
                                    Delete Session File (requires server restart)
                                </button>
                            `}
                        </div>
                    `;
                    
                    // Add click handler for delete session button
                    const deleteBtn = document.getElementById('deleteTelegramSessionBtn2');
                    if (deleteBtn) {
                        deleteBtn.addEventListener('click', async () => {
                            if (confirm('This will delete your Telegram session file. You will need to restart the server and authenticate again. Continue?')) {
                                try {
                                    const response = await fetch('http://localhost:8000/api/telegram/delete-session', {
                                        method: 'POST'
                                    });
                                    const data = await response.json();
                                    if (response.ok && data.success) {
                                        alert('Session file deleted. Please restart your backend server and click Refresh to authenticate.');
                                    } else {
                                        alert('Failed to delete session file: ' + (data.detail || data.message || 'Unknown error'));
                                    }
                                } catch (error) {
                                    alert('Error deleting session file: ' + error.message);
                                }
                            }
                        });
                    }
                } else {
                    telegramMessagesContainer.innerHTML = `<div class="telegram-empty-state"><div class="telegram-empty-icon">‚ö†Ô∏è</div><h3>Error</h3><p>Exception: ${errorMsg}</p></div>`;
                }
                telegramChatsList.innerHTML = '<div class="telegram-sidebar-empty">Error loading chats</div>';
                if (telegramCount) telegramCount.textContent = 'Error';
            }

            telegramShowButton.disabled = false;
            telegramShowButton.textContent = 'Refresh';
        }

        telegramShowButton.addEventListener('click', loadTelegramMessages);


        // Slack functionality
        const slackViewButton = document.getElementById('slackViewButton');
        const slackMessagesContainer = document.getElementById('slackMessagesContainer');
        const slackChannelsList = document.getElementById('slackChannelsList');
        const slackCurrentChannel = document.getElementById('slackCurrentChannel');
        const slackCount = document.getElementById('slackCount');
        let allSlackMessages = [];
        let messagesByChannel = {};
        let currentChannelId = null;
        let totalSlackCount = 0;

        function getInitials(name) {
            if (!name) return '?';
            const parts = name.trim().split(' ');
            if (parts.length >= 2) {
                return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
            }
            return name.substring(0, 2).toUpperCase();
        }

        function getAvatarColor(name) {
            if (!name) return '#4a154b';
            let hash = 0;
            for (let i = 0; i < name.length; i++) {
                hash = name.charCodeAt(i) + ((hash << 5) - hash);
            }
            const colors = [
                '#4a154b', '#350d36', '#1264a3', '#0f5132', '#856404',
                '#721c24', '#155724', '#004085', '#383f45', '#1d1c1d'
            ];
            return colors[Math.abs(hash) % colors.length];
        }

        function formatSlackTimestamp(timestamp) {
            if (!timestamp) return '';
            try {
                const date = new Date(timestamp);
                const now = new Date();
                const diffMs = now - date;
                const diffMins = Math.floor(diffMs / 60000);
                const diffHours = Math.floor(diffMs / 3600000);
                const diffDays = Math.floor(diffMs / 86400000);

                if (diffMins < 1) return 'now';
                if (diffMins < 60) return `${diffMins}m ago`;
                if (diffHours < 24) return `${diffHours}h ago`;
                if (diffDays < 7) return `${diffDays}d ago`;
                
                // Format as date
                const month = date.toLocaleString('default', { month: 'short' });
                const day = date.getDate();
                const year = date.getFullYear();
                const isThisYear = year === now.getFullYear();
                return isThisYear ? `${month} ${day}` : `${month} ${day}, ${year}`;
            } catch (e) {
                return timestamp;
            }
        }

        function formatSlackTime(timestamp) {
            if (!timestamp) return '';
            try {
                const date = new Date(timestamp);
                return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
            } catch (e) {
                return timestamp;
            }
        }

        function formatSlackMessage(text) {
            if (!text) return '';
            // Convert Slack markdown-like formatting
            let formatted = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\n/g, '<br>')
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.+?)\*/g, '<em>$1</em>')
                .replace(/`(.+?)`/g, '<code>$1</code>');
            return formatted;
        }

        function groupMessagesByChannel(messages) {
            const grouped = {};
            messages.forEach(msg => {
                const channelId = msg.channel_id || 'unknown';
                if (!grouped[channelId]) {
                    grouped[channelId] = {
                        channelId: channelId,
                        channelName: msg.channel_name || 'Unknown',
                        messages: []
                    };
                }
                grouped[channelId].messages.push(msg);
            });
            
            // Sort messages within each channel by timestamp
            Object.keys(grouped).forEach(channelId => {
                grouped[channelId].messages.sort((a, b) => {
                    const timeA = new Date(a.timestamp || 0).getTime();
                    const timeB = new Date(b.timestamp || 0).getTime();
                    return timeA - timeB; // Oldest first
                });
            });
            
            return grouped;
        }

        function renderSlackChannels() {
            const channels = Object.values(messagesByChannel);
            channels.sort((a, b) => {
                const lastMsgA = a.messages[a.messages.length - 1];
                const lastMsgB = b.messages[b.messages.length - 1];
                const timeA = new Date(lastMsgA?.timestamp || 0).getTime();
                const timeB = new Date(lastMsgB?.timestamp || 0).getTime();
                return timeB - timeA; // Most recent first
            });

            if (channels.length === 0) {
                slackChannelsList.innerHTML = '<div class="slack-sidebar-empty">No channels found</div>';
                return;
            }

            const channelsHTML = channels.map(channel => {
                const lastMsg = channel.messages[channel.messages.length - 1];
                const preview = lastMsg?.body ? (lastMsg.body.length > 30 ? lastMsg.body.substring(0, 30) + '...' : lastMsg.body) : 'No messages';
                const time = formatSlackTimestamp(lastMsg?.timestamp);
                const isActive = currentChannelId === channel.channelId;
                
                return `
                    <div class="slack-channel-item ${isActive ? 'active' : ''}" data-channel-id="${channel.channelId}">
                        <div class="slack-channel-name">${channel.channelName}</div>
                        <div class="slack-channel-preview">${preview}</div>
                        <div class="slack-channel-meta">
                            <span class="slack-channel-count">${channel.messages.length} msgs</span>
                            <span class="slack-channel-time">${time}</span>
                </div>
                    </div>
                `;
            }).join('');

            slackChannelsList.innerHTML = channelsHTML;

            // Add click handlers
            document.querySelectorAll('.slack-channel-item').forEach(item => {
                item.addEventListener('click', () => {
                    const channelId = item.dataset.channelId;
                    selectChannel(channelId);
                });
            });
        }

        function selectChannel(channelId) {
            currentChannelId = channelId;
            const channel = messagesByChannel[channelId];
            if (!channel) return;

            slackCurrentChannel.textContent = channel.channelName;
            slackCount.textContent = `${channel.messages.length} messages`;

            // Render messages for this channel
            renderSlackMessages(channel.messages);

            // Show input area
            const inputContainer = document.getElementById('slackInputContainer');
            if (inputContainer) {
                inputContainer.style.display = 'block';
            }

            // Update active state
            document.querySelectorAll('.slack-channel-item').forEach(item => {
                item.classList.toggle('active', item.dataset.channelId === channelId);
            });

            // Focus input
            const messageInput = document.getElementById('slackMessageInput');
            if (messageInput) {
                messageInput.focus();
            }
        }

        function renderSlackMessages(messages) {
            if (!messages || messages.length === 0) {
                slackMessagesContainer.innerHTML = '<div class="slack-empty-state"><p>No messages in this channel</p></div>';
                return;
            }

            let lastUserId = null;
            let lastDate = null;
            const messagesHTML = messages.map((msg, index) => {
                const msgDate = new Date(msg.timestamp || Date.now());
                const currentDate = msgDate.toDateString();
                const showDateDivider = lastDate !== currentDate;
                lastDate = currentDate;

                const showAvatar = lastUserId !== msg.from_id;
                lastUserId = msg.from_id;

                const initials = getInitials(msg.from_name || msg.from_id);
                const avatarColor = getAvatarColor(msg.from_name || msg.from_id);
                const timeStr = formatSlackTime(msg.timestamp);
                const formattedBody = formatSlackMessage(msg.body || '');

                let html = '';
                
                // Date divider
                if (showDateDivider) {
                    const dateStr = msgDate.toLocaleDateString('en-US', { 
                        weekday: 'long', 
                        year: 'numeric', 
                        month: 'long', 
                        day: 'numeric' 
                    });
                    html += `<div class="slack-date-divider"><span>${dateStr}</span></div>`;
                }

                // Message
                html += `
                    <div class="slack-message ${showAvatar ? 'show-avatar' : ''}" data-message-id="${msg.message_id}">
                        ${showAvatar ? `
                            <div class="slack-avatar" style="background-color: ${avatarColor}">
                                ${initials}
                            </div>
                        ` : '<div class="slack-avatar-spacer"></div>'}
                        <div class="slack-message-content">
                            ${showAvatar ? `
                                <div class="slack-message-header">
                                    <span class="slack-username">${msg.from_name || msg.from_id || 'Unknown'}</span>
                                    <span class="slack-timestamp">${timeStr}</span>
                                </div>
                            ` : ''}
                            <div class="slack-message-body">${formattedBody || '<em>No content</em>'}</div>
                        </div>
                    </div>
                `;

                return html;
            }).join('');

            slackMessagesContainer.innerHTML = messagesHTML;
            slackMessagesContainer.scrollTop = slackMessagesContainer.scrollHeight;
        }

        function updateSlackCount() {
            if (!slackCount) return;
            const total = Object.values(messagesByChannel).reduce((sum, ch) => sum + ch.messages.length, 0);
            slackCount.textContent = `${total} total messages`;
        }

        async function loadSlackMessages() {
            slackViewButton.disabled = true;
            slackViewButton.textContent = 'Loading...';
            allSlackMessages = [];
            messagesByChannel = {};
            currentChannelId = null;
            totalSlackCount = 0;

            try {
                console.log('[*] Requesting Slack messages from backend...');
                const response = await fetch('http://localhost:8000/api/slack/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        limit: 50  // Reduced from 200 to 50 for faster loading
                    })
                });

                console.log('[*] Response status:', response.status);
                const data = await response.json();
                console.log('[*] Response data:', data);

                if (response.ok && data.success) {
                    allSlackMessages = data.messages || [];
                    totalSlackCount = typeof data.total_count === 'number' ? data.total_count : allSlackMessages.length;
                    
                    // Group messages by channel
                    messagesByChannel = groupMessagesByChannel(allSlackMessages);
                    
                    // Render channels sidebar
                    renderSlackChannels();
                    
                    // Auto-select first channel if available
                    const channels = Object.keys(messagesByChannel);
                    if (channels.length > 0) {
                        selectChannel(channels[0]);
                    } else {
                        slackMessagesContainer.innerHTML = '<div class="slack-empty-state"><p>No messages found</p></div>';
                    }
                    
                    updateSlackCount();
                    console.log(`[OK] Got ${allSlackMessages.length} Slack messages in ${channels.length} channels`);
                } else {
                    const errorMsg = data.error || data.detail || JSON.stringify(data);
                    console.error('[!] Backend error:', errorMsg);
                    slackMessagesContainer.innerHTML = `<div class="slack-empty-state"><div class="slack-empty-icon">‚ö†Ô∏è</div><h3>Error</h3><p>${errorMsg}</p></div>`;
                    slackChannelsList.innerHTML = '<div class="slack-sidebar-empty">Error loading channels</div>';
                    if (slackCount) slackCount.textContent = 'Error';
                }
            } catch (error) {
                console.error('[!] Exception:', error);
                slackMessagesContainer.innerHTML = `<div class="slack-empty-state"><div class="slack-empty-icon">‚ö†Ô∏è</div><h3>Error</h3><p>Exception: ${error.message}</p></div>`;
                slackChannelsList.innerHTML = '<div class="slack-sidebar-empty">Error loading channels</div>';
                if (slackCount) slackCount.textContent = 'Error';
            }

            slackViewButton.disabled = false;
            slackViewButton.textContent = 'Refresh';
        }

        slackViewButton.addEventListener('click', loadSlackMessages);

        // Word Document Management
        const createWordDocButton = document.getElementById('createWordDocButton');
        const openWordDocButton = document.getElementById('openWordDocButton');
        const wordCreateModal = document.getElementById('wordCreateModal');
        const wordOpenModal = document.getElementById('wordOpenModal');
        const wordCreateModalClose = document.getElementById('wordCreateModalClose');
        const wordOpenModalClose = document.getElementById('wordOpenModalClose');
        const wordCreateCancel = document.getElementById('wordCreateCancel');
        const wordOpenCancel = document.getElementById('wordOpenCancel');
        const wordCreateSubmit = document.getElementById('wordCreateSubmit');
        const wordOpenSubmit = document.getElementById('wordOpenSubmit');
        const wordDocumentArea = document.getElementById('wordDocumentArea');
        const wordFilePathBrowse = document.getElementById('wordFilePathBrowse');
        const wordFilePathInput = document.getElementById('wordFilePathInput');
        const wordOpenFilePathBrowse = document.getElementById('wordOpenFilePathBrowse');
        const wordOpenFilePathInput = document.getElementById('wordOpenFilePathInput');

        // Browse button for opening documents - use native file picker
        if (wordOpenFilePathBrowse && wordOpenFilePathInput) {
            wordOpenFilePathBrowse.addEventListener('click', async () => {
                try {
                    const filePathInput = document.getElementById('wordOpenFilePath');
                    if (!filePathInput) return;
                    
                    // Get initial directory
                    const defaultPath = await getDefaultDocumentsPath();
                    const initialDir = filePathInput.value.trim() ? 
                        filePathInput.value.substring(0, filePathInput.value.lastIndexOf('\\')) : 
                        defaultPath;
                    
                    // Call backend to open native file picker
                    const response = await fetch(`http://localhost:8000/api/word/select-file?initial_path=${encodeURIComponent(initialDir)}`);
                    
                    if (!response.ok) {
                        throw new Error(`Failed to open file picker: ${response.status}`);
                    }
                    
                    const result = await response.json();
                    
                    if (result.success && result.file_path) {
                        filePathInput.value = result.file_path;
                        console.log('File selected:', result.file_path);
                    } else if (!result.cancelled) {
                        // Only show error if not cancelled by user
                        const errorMsg = result.error || 'Failed to select file';
                        console.error('File picker error:', errorMsg);
                        alert(`Error selecting file: ${errorMsg}`);
                    }
                } catch (error) {
                    console.error('Error opening file picker:', error);
                    alert(`Error opening file picker: ${error.message}`);
                }
            });
        }
        
        // Helper function to get default Documents path
        async function getDefaultDocumentsPath() {
            try {
                const response = await fetch('http://localhost:8000/api/word/list-directory');
                const data = await response.json();
                if (data.success && data.path) {
                    return data.path;
                }
            } catch (error) {
                console.error('Error getting default path:', error);
            }
            // Fallback to D: drive instead of C: drive
            return 'D:\\Documents';
        }

        // Browse button for creating documents
        if (wordFilePathBrowse && wordFilePathInput) {
            wordFilePathBrowse.addEventListener('click', async () => {
                const filePathInput = document.getElementById('wordFilePath');
                if (filePathInput) {
                    if (!filePathInput.value.trim()) {
                        // Get default Documents path from server
                        const defaultPath = await getDefaultDocumentsPath();
                        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
                        const suggestedPath = `${defaultPath}\\document_${timestamp}.docx`;
                        filePathInput.value = suggestedPath;
                    }
                    filePathInput.focus();
                    filePathInput.select();
                }
            });
        }

        // Store current document state
        let currentWordDocument = {
            filePath: null,
            title: null,
            content: ''
        };

        // Function to open Word editor
        function openWordEditor(filePath, title, initialContent) {
            currentWordDocument.filePath = filePath;
            currentWordDocument.title = title;
            currentWordDocument.content = initialContent;
            
            // Convert plain text content to HTML
            // Replace newlines with <div> tags for proper paragraph display
            let htmlContent = '';
            if (initialContent) {
                // Escape HTML special characters to prevent injection
                const escapeHtml = (text) => {
                    const div = document.createElement('div');
                    div.textContent = text;
                    return div.innerHTML;
                };
                
                // Split by newlines and wrap each line in a div
                const lines = initialContent.split('\n');
                htmlContent = lines.map(line => {
                    const escapedLine = escapeHtml(line);
                    // Use <br> for empty lines to preserve them
                    return `<div>${escapedLine || '<br>'}</div>`;
                }).join('');
            }
            
            if (wordDocumentArea) {
                const fileName = filePath.split('\\').pop() || filePath.split('/').pop() || 'Document';
                wordDocumentArea.innerHTML = `
                    <div class="word-editor-container">
                        <div class="word-editor-toolbar">
                            <!-- File Operations -->
                            <div class="word-editor-toolbar-group">
                                <button class="word-editor-btn" id="wordEditorNew" title="New Document">üìÑ New</button>
                                <button class="word-editor-btn" id="wordEditorOpen" title="Open Document">üìÇ Open</button>
                                <button class="word-editor-btn word-editor-btn-primary" id="wordEditorSave" title="Save (Ctrl+S)">üíæ Save</button>
                            </div>
                            
                            <!-- Text Formatting -->
                            <div class="word-editor-toolbar-group">
                                <button class="word-editor-btn" id="wordEditorBold" title="Bold (Ctrl+B)"><strong>B</strong></button>
                                <button class="word-editor-btn" id="wordEditorItalic" title="Italic (Ctrl+I)"><em>I</em></button>
                                <button class="word-editor-btn" id="wordEditorUnderline" title="Underline (Ctrl+U)"><u>U</u></button>
                                <button class="word-editor-btn" id="wordEditorStrikethrough" title="Strikethrough"><s>S</s></button>
                                <button class="word-editor-btn" id="wordEditorSubscript" title="Subscript">x‚ÇÇ</button>
                                <button class="word-editor-btn" id="wordEditorSuperscript" title="Superscript">x¬≤</button>
                            </div>
                            
                            <!-- Font Controls -->
                            <div class="word-editor-toolbar-group">
                                <select class="word-editor-select" id="wordEditorFontSize" title="Font Size">
                                    <option value="8">8</option>
                                    <option value="9">9</option>
                                    <option value="10">10</option>
                                    <option value="11">11</option>
                                    <option value="12" selected>12</option>
                                    <option value="14">14</option>
                                    <option value="16">16</option>
                                    <option value="18">18</option>
                                    <option value="20">20</option>
                                    <option value="24">24</option>
                                    <option value="28">28</option>
                                    <option value="36">36</option>
                                    <option value="48">48</option>
                                    <option value="72">72</option>
                                </select>
                                <select class="word-editor-select" id="wordEditorFontFamily" title="Font Family">
                                    <option value="Arial">Arial</option>
                                    <option value="Times New Roman">Times New Roman</option>
                                    <option value="Calibri" selected>Calibri</option>
                                    <option value="Courier New">Courier New</option>
                                    <option value="Verdana">Verdana</option>
                                    <option value="Georgia">Georgia</option>
                                    <option value="Comic Sans MS">Comic Sans MS</option>
                                    <option value="Impact">Impact</option>
                                    <option value="Trebuchet MS">Trebuchet MS</option>
                                    <option value="Tahoma">Tahoma</option>
                                </select>
                                <input type="color" id="wordEditorTextColor" title="Text Color" value="#000000" style="width: 40px; height: 28px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                                <button class="word-editor-btn" id="wordEditorHighlight" title="Highlight">üñçÔ∏è</button>
                            </div>
                            
                            <!-- Paragraph Formatting -->
                            <div class="word-editor-toolbar-group">
                                <button class="word-editor-btn" id="wordEditorAlignLeft" title="Align Left">‚¨Ö</button>
                                <button class="word-editor-btn" id="wordEditorAlignCenter" title="Align Center">‚¨å</button>
                                <button class="word-editor-btn" id="wordEditorAlignRight" title="Align Right">‚û°</button>
                                <button class="word-editor-btn" id="wordEditorAlignJustify" title="Justify">‚¨å‚¨å</button>
                                <button class="word-editor-btn" id="wordEditorBullets" title="Bullets">‚Ä¢ List</button>
                                <button class="word-editor-btn" id="wordEditorNumbering" title="Numbering">1. List</button>
                                <button class="word-editor-btn" id="wordEditorIndentDecrease" title="Decrease Indent">‚´∏</button>
                                <button class="word-editor-btn" id="wordEditorIndentIncrease" title="Increase Indent">‚´∑</button>
                            </div>
                            
                            <!-- Insert Options -->
                            <div class="word-editor-toolbar-group">
                                <button class="word-editor-btn" id="wordEditorInsertImage" title="Insert Image">üñºÔ∏è Image</button>
                                <button class="word-editor-btn" id="wordEditorInsertLink" title="Insert Hyperlink">üîó Link</button>
                                <button class="word-editor-btn" id="wordEditorInsertPageBreak" title="Page Break">üìÑ Page</button>
                            </div>
                            
                            <!-- Headings -->
                            <div class="word-editor-toolbar-group">
                                <select class="word-editor-select" id="wordEditorHeading" title="Heading Style" style="width: 120px;">
                                    <option value="">Normal</option>
                                    <option value="h1">Heading 1</option>
                                    <option value="h2">Heading 2</option>
                                    <option value="h3">Heading 3</option>
                                    <option value="h4">Heading 4</option>
                                    <option value="h5">Heading 5</option>
                                    <option value="h6">Heading 6</option>
                                </select>
                            </div>
                            
                            <!-- Document Tools -->
                            <div class="word-editor-toolbar-group">
                                <button class="word-editor-btn" id="wordEditorFindReplace" title="Find & Replace">üîç Find</button>
                                <button class="word-editor-btn" id="wordEditorWordCount" title="Word Count">üìä Count</button>
                                <button class="word-editor-btn" id="wordEditorPageSetup" title="Page Setup">üìê Setup</button>
                            </div>
                        </div>
                        <div class="word-editor-header">
                            <div class="word-editor-title">
                                <span style="font-weight: 600;">üìÑ ${fileName}</span>
                                <span style="font-size: 12px; color: #666; margin-left: 12px;">${filePath}</span>
                            </div>
                        </div>
                        <div class="word-editor-content-wrapper">
                            <div 
                                class="word-editor-content" 
                                id="wordEditorContent" 
                                contenteditable="true"
                                style="min-height: 500px; padding: 20px; background: white; border: 1px solid #ddd; border-radius: 4px; outline: none; font-family: 'Calibri', 'Arial', sans-serif; font-size: 12pt; line-height: 1.5;"
                            >${htmlContent || '<div><br></div>'}</div>
                        </div>
                    </div>
                `;
                
                // Set up editor event listeners
                setupWordEditor();
            }
        }

        // Function to set up Word editor event listeners
        function setupWordEditor() {
            const editorContent = document.getElementById('wordEditorContent');
            const saveBtn = document.getElementById('wordEditorSave');
            const boldBtn = document.getElementById('wordEditorBold');
            const italicBtn = document.getElementById('wordEditorItalic');
            const underlineBtn = document.getElementById('wordEditorUnderline');
            const alignLeftBtn = document.getElementById('wordEditorAlignLeft');
            const alignCenterBtn = document.getElementById('wordEditorAlignCenter');
            const alignRightBtn = document.getElementById('wordEditorAlignRight');
            const fontSizeSelect = document.getElementById('wordEditorFontSize');
            const fontFamilySelect = document.getElementById('wordEditorFontFamily');

            // Save functionality - show Save As dialog
            // NOTE: No auto-save functionality. Files are only saved when user explicitly:
            // 1. Clicks the Save button, or
            // 2. Presses Ctrl+S while editor is focused
            if (saveBtn && editorContent) {
                saveBtn.addEventListener('click', () => {
                    showSaveAsDialog();
                });
            }

            // Format buttons
            if (boldBtn && editorContent) {
                boldBtn.addEventListener('click', () => {
                    document.execCommand('bold', false, null);
                    editorContent.focus();
                });
            }

            if (italicBtn && editorContent) {
                italicBtn.addEventListener('click', () => {
                    document.execCommand('italic', false, null);
                    editorContent.focus();
                });
            }

            if (underlineBtn && editorContent) {
                underlineBtn.addEventListener('click', () => {
                    document.execCommand('underline', false, null);
                    editorContent.focus();
                });
            }

            // Alignment buttons
            if (alignLeftBtn && editorContent) {
                alignLeftBtn.addEventListener('click', () => {
                    document.execCommand('justifyLeft', false, null);
                    editorContent.focus();
                });
            }

            if (alignCenterBtn && editorContent) {
                alignCenterBtn.addEventListener('click', () => {
                    document.execCommand('justifyCenter', false, null);
                    editorContent.focus();
                });
            }

            if (alignRightBtn && editorContent) {
                alignRightBtn.addEventListener('click', () => {
                    document.execCommand('justifyRight', false, null);
                    editorContent.focus();
                });
            }

            // Font size
            if (fontSizeSelect && editorContent) {
                fontSizeSelect.addEventListener('change', (e) => {
                    document.execCommand('fontSize', false, e.target.value);
                    editorContent.focus();
                });
            }

            // Font family
            if (fontFamilySelect && editorContent) {
                fontFamilySelect.addEventListener('change', (e) => {
                    document.execCommand('fontName', false, e.target.value);
                    editorContent.focus();
                });
            }

            // Additional formatting buttons
            const strikethroughBtn = document.getElementById('wordEditorStrikethrough');
            const subscriptBtn = document.getElementById('wordEditorSubscript');
            const superscriptBtn = document.getElementById('wordEditorSuperscript');
            const textColorInput = document.getElementById('wordEditorTextColor');
            const highlightBtn = document.getElementById('wordEditorHighlight');
            const alignJustifyBtn = document.getElementById('wordEditorAlignJustify');
            const bulletsBtn = document.getElementById('wordEditorBullets');
            const numberingBtn = document.getElementById('wordEditorNumbering');
            const indentDecreaseBtn = document.getElementById('wordEditorIndentDecrease');
            const indentIncreaseBtn = document.getElementById('wordEditorIndentIncrease');
            const headingSelect = document.getElementById('wordEditorHeading');
            const insertImageBtn = document.getElementById('wordEditorInsertImage');
            const insertLinkBtn = document.getElementById('wordEditorInsertLink');
            const insertPageBreakBtn = document.getElementById('wordEditorInsertPageBreak');
            const findReplaceBtn = document.getElementById('wordEditorFindReplace');
            const wordCountBtn = document.getElementById('wordEditorWordCount');
            const pageSetupBtn = document.getElementById('wordEditorPageSetup');
            const newDocBtn = document.getElementById('wordEditorNew');
            const openDocBtn = document.getElementById('wordEditorOpen');

            // Strikethrough
            if (strikethroughBtn && editorContent) {
                strikethroughBtn.addEventListener('click', () => {
                    document.execCommand('strikeThrough', false, null);
                    editorContent.focus();
                });
            }

            // Subscript
            if (subscriptBtn && editorContent) {
                subscriptBtn.addEventListener('click', () => {
                    document.execCommand('subscript', false, null);
                    editorContent.focus();
                });
            }

            // Superscript
            if (superscriptBtn && editorContent) {
                superscriptBtn.addEventListener('click', () => {
                    document.execCommand('superscript', false, null);
                    editorContent.focus();
                });
            }

            // Text color
            if (textColorInput && editorContent) {
                textColorInput.addEventListener('change', (e) => {
                    document.execCommand('foreColor', false, e.target.value);
                    editorContent.focus();
                });
            }

            // Highlight
            if (highlightBtn && editorContent) {
                highlightBtn.addEventListener('click', () => {
                    const color = prompt('Enter highlight color (e.g., yellow, #FFFF00):', 'yellow');
                    if (color) {
                        document.execCommand('backColor', false, color);
                    }
                    editorContent.focus();
                });
            }

            // Justify alignment
            if (alignJustifyBtn && editorContent) {
                alignJustifyBtn.addEventListener('click', () => {
                    document.execCommand('justifyFull', false, null);
                    editorContent.focus();
                });
            }

            // Bullets
            if (bulletsBtn && editorContent) {
                bulletsBtn.addEventListener('click', () => {
                    document.execCommand('insertUnorderedList', false, null);
                    editorContent.focus();
                });
            }

            // Numbering
            if (numberingBtn && editorContent) {
                numberingBtn.addEventListener('click', () => {
                    document.execCommand('insertOrderedList', false, null);
                    editorContent.focus();
                });
            }

            // Indent decrease
            if (indentDecreaseBtn && editorContent) {
                indentDecreaseBtn.addEventListener('click', () => {
                    document.execCommand('outdent', false, null);
                    editorContent.focus();
                });
            }

            // Indent increase
            if (indentIncreaseBtn && editorContent) {
                indentIncreaseBtn.addEventListener('click', () => {
                    document.execCommand('indent', false, null);
                    editorContent.focus();
                });
            }

            // Heading style
            if (headingSelect && editorContent) {
                headingSelect.addEventListener('change', (e) => {
                    const heading = e.target.value;
                    if (heading) {
                        document.execCommand('formatBlock', false, `<${heading}>`);
                    } else {
                        document.execCommand('formatBlock', false, '<p>');
                    }
                    editorContent.focus();
                });
            }

            // Insert image
            if (insertImageBtn && editorContent) {
                insertImageBtn.addEventListener('click', () => {
                    const url = prompt('Enter image URL:', '');
                    if (url) {
                        const img = document.createElement('img');
                        img.src = url;
                        img.style.maxWidth = '100%';
                        img.style.height = 'auto';
                        const selection = window.getSelection();
                        if (selection.rangeCount > 0) {
                            selection.getRangeAt(0).insertNode(img);
                        } else {
                            editorContent.appendChild(img);
                        }
                        editorContent.focus();
                    }
                });
            }

            // Insert hyperlink
            if (insertLinkBtn && editorContent) {
                insertLinkBtn.addEventListener('click', () => {
                    const url = prompt('Enter URL:', 'https://');
                    const text = prompt('Enter link text:', '');
                    if (url && text) {
                        const link = document.createElement('a');
                        link.href = url;
                        link.textContent = text;
                        link.target = '_blank';
                        const selection = window.getSelection();
                        if (selection.rangeCount > 0) {
                            selection.getRangeAt(0).insertNode(link);
                        } else {
                            editorContent.appendChild(link);
                        }
                        editorContent.focus();
                    }
                });
            }

            // Insert page break
            if (insertPageBreakBtn && editorContent) {
                insertPageBreakBtn.addEventListener('click', () => {
                    const pageBreak = document.createElement('div');
                    pageBreak.style.pageBreakAfter = 'always';
                    pageBreak.style.borderTop = '2px dashed #ccc';
                    pageBreak.style.margin = '20px 0';
                    pageBreak.innerHTML = '<br>';
                    const selection = window.getSelection();
                    if (selection.rangeCount > 0) {
                        selection.getRangeAt(0).insertNode(pageBreak);
                    } else {
                        editorContent.appendChild(pageBreak);
                    }
                    editorContent.focus();
                });
            }

            // Find & Replace
            if (findReplaceBtn && editorContent) {
                findReplaceBtn.addEventListener('click', () => {
                    const find = prompt('Find:', '');
                    if (find) {
                        const replace = prompt('Replace with:', '');
                        const content = editorContent.innerHTML;
                        editorContent.innerHTML = content.replace(new RegExp(find, 'gi'), replace || '');
                        editorContent.focus();
                    }
                });
            }

            // Word count
            if (wordCountBtn && editorContent) {
                wordCountBtn.addEventListener('click', () => {
                    const text = editorContent.innerText || editorContent.textContent || '';
                    const words = text.trim().split(/\s+/).filter(w => w.length > 0);
                    const chars = text.length;
                    const charsNoSpaces = text.replace(/\s/g, '').length;
                    alert(`Word Count:\n\nWords: ${words.length}\nCharacters (with spaces): ${chars}\nCharacters (no spaces): ${charsNoSpaces}`);
                });
            }

            // Page setup
            if (pageSetupBtn && editorContent) {
                pageSetupBtn.addEventListener('click', () => {
                    alert('Page Setup:\n\nThis feature will be implemented with backend API integration.\n\nYou can configure:\n- Page size (A4, Letter, etc.)\n- Margins\n- Orientation (Portrait/Landscape)');
                });
            }

            // New document
            if (newDocBtn) {
                newDocBtn.addEventListener('click', async () => {
                    if (confirm('Create a new document? Unsaved changes will be lost.')) {
                        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
                        const defaultPath = await getDefaultDocumentsPath();
                        const filePath = `${defaultPath}\\document_${timestamp}.docx`;
                        openWordEditor(filePath, 'New Document', '');
                    }
                });
            }

            // Open document
            if (openDocBtn) {
                openDocBtn.addEventListener('click', () => {
                    const wordOpenModal = document.getElementById('wordOpenModal');
                    if (wordOpenModal) {
                        wordOpenModal.style.display = 'flex';
                    }
                });
            }

            // Keyboard shortcuts
            if (editorContent) {
                editorContent.addEventListener('keydown', (e) => {
                    // Ctrl+S to save (only when editor has focus and user explicitly presses Ctrl+S)
                    if (e.ctrlKey && e.key === 's' && document.activeElement === editorContent) {
                        e.preventDefault();
                        e.stopPropagation();
                        showSaveAsDialog();
                    }
                    // Ctrl+B for bold
                    if (e.ctrlKey && e.key === 'b') {
                        e.preventDefault();
                        document.execCommand('bold', false, null);
                    }
                    // Ctrl+I for italic
                    if (e.ctrlKey && e.key === 'i') {
                        e.preventDefault();
                        document.execCommand('italic', false, null);
                    }
                    // Ctrl+U for underline
                    if (e.ctrlKey && e.key === 'u') {
                        e.preventDefault();
                        document.execCommand('underline', false, null);
                    }
                });
            }
        }

        // Function to show Save As dialog
        async function showSaveAsDialog() {
            const saveAsModal = document.getElementById('wordSaveAsModal');
            const saveAsFolderPath = document.getElementById('wordSaveAsFolderPath');
            const saveAsFileName = document.getElementById('wordSaveAsFileName');
            
            if (saveAsModal && saveAsFolderPath && saveAsFileName) {
                // Pre-fill with current file path if available
                if (currentWordDocument.filePath) {
                    const fullPath = currentWordDocument.filePath;
                    const lastSeparator = Math.max(fullPath.lastIndexOf('\\'), fullPath.lastIndexOf('/'));
                    if (lastSeparator > 0) {
                        saveAsFolderPath.value = fullPath.substring(0, lastSeparator);
                        saveAsFileName.value = fullPath.substring(lastSeparator + 1);
                    } else {
                        saveAsFolderPath.value = '';
                        saveAsFileName.value = fullPath;
                    }
                } else {
                    // Generate default path
                    try {
                        const defaultPath = await getDefaultDocumentsPath();
                        saveAsFolderPath.value = defaultPath;
                        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
                        saveAsFileName.value = `document_${timestamp}.docx`;
                    } catch (error) {
                        console.error('Error getting default path:', error);
                        // Fallback
                        saveAsFolderPath.value = 'D:\\Documents';
                        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
                        saveAsFileName.value = `document_${timestamp}.docx`;
                    }
                }
                saveAsModal.style.display = 'flex';
                // Small delay to ensure modal is visible before focusing
                setTimeout(() => {
                    saveAsFileName.focus();
                    saveAsFileName.select();
                }, 100);
            }
        }

        // Set up Save As dialog event listeners
        const wordSaveAsModal = document.getElementById('wordSaveAsModal');
        const wordSaveAsModalClose = document.getElementById('wordSaveAsModalClose');
        const wordSaveAsCancel = document.getElementById('wordSaveAsCancel');
        const wordSaveAsSubmit = document.getElementById('wordSaveAsSubmit');
        const wordSaveAsFolderPath = document.getElementById('wordSaveAsFolderPath');
        const wordSaveAsFileName = document.getElementById('wordSaveAsFileName');
        const wordSaveAsFolderPathBrowse = document.getElementById('wordSaveAsFolderPathBrowse');

        // Close Save As modal
        if (wordSaveAsModalClose) {
            wordSaveAsModalClose.addEventListener('click', () => {
                if (wordSaveAsModal) wordSaveAsModal.style.display = 'none';
            });
        }

        if (wordSaveAsCancel) {
            wordSaveAsCancel.addEventListener('click', () => {
                if (wordSaveAsModal) wordSaveAsModal.style.display = 'none';
            });
        }

        // Folder browser state
        let currentFolderBrowserPath = null;
        let selectedFolderPath = null;

        // Browse button for Save As - use native Windows folder picker
        if (wordSaveAsFolderPathBrowse) {
            wordSaveAsFolderPathBrowse.addEventListener('click', async () => {
                await openNativeFolderPicker();
            });
        }

        // Function to open native Windows folder picker via backend
        async function openNativeFolderPicker() {
            const currentPath = wordSaveAsFolderPath?.value.trim() || null;
            
            try {
                const url = currentPath ? 
                    `http://localhost:8000/api/word/select-folder?initial_path=${encodeURIComponent(currentPath)}` :
                    'http://localhost:8000/api/word/select-folder';
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.success && data.folder_path) {
                    // User selected a folder
                    if (wordSaveAsFolderPath) {
                        wordSaveAsFolderPath.value = data.folder_path;
                    }
                } else if (data.cancelled) {
                    // User cancelled - do nothing
                    console.log('Folder selection cancelled');
                } else {
                    // Error occurred
                    alert('Error selecting folder: ' + (data.detail || data.message || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error opening folder picker:', error);
                alert('Error opening folder picker: ' + error.message + '\n\nFalling back to manual entry.');
                // Fallback: focus the input so user can type manually
                if (wordSaveAsFolderPath) {
                    wordSaveAsFolderPath.focus();
                }
            }
        }

        // Function to open folder browser dialog
        async function openFolderBrowserDialog() {
            const folderBrowserDialog = document.getElementById('wordFolderBrowserDialog');
            if (!folderBrowserDialog) return;

            // Get initial path from input or use default
            let initialPath = wordSaveAsFolderPath?.value.trim();
            if (!initialPath) {
                try {
                    initialPath = await getDefaultDocumentsPath();
                } catch (error) {
                    initialPath = 'D:\\Documents';
                }
            }

            currentFolderBrowserPath = initialPath;
            selectedFolderPath = initialPath;
            folderBrowserDialog.style.display = 'flex';
            loadFolderBrowserDirectory(initialPath);
        }

        // Function to load directory in folder browser
        async function loadFolderBrowserDirectory(path = null) {
            const folderBrowserContent = document.getElementById('wordFolderBrowserContent');
            const folderBrowserPathBreadcrumb = document.getElementById('wordFolderBrowserPathBreadcrumb');
            
            if (!folderBrowserContent) return;

            try {
                const url = path ? 
                    `http://localhost:8000/api/word/list-directory?path=${encodeURIComponent(path)}` :
                    'http://localhost:8000/api/word/list-directory';
                
                const response = await fetch(url);
                const data = await response.json();

                if (data.success) {
                    currentFolderBrowserPath = data.path;
                    selectedFolderPath = data.path;
                    updateFolderBrowserPathBreadcrumb(data.path);
                    
                    // Clear and populate content - only show directories
                    folderBrowserContent.innerHTML = '';

                    // Add parent directory row if available
                    if (data.parent_path) {
                        const parentRow = document.createElement('div');
                        parentRow.style.cssText = 'display: flex; align-items: center; gap: 8px; padding: 8px 16px; cursor: pointer; border-bottom: 1px solid #f0f0f0; transition: background 0.15s;';
                        parentRow.innerHTML = `
                            <span style="font-size: 20px;">üìÅ</span>
                            <span style="font-size: 14px; color: #333; font-weight: 500;">.. (Parent Folder)</span>
                        `;
                        parentRow.addEventListener('click', () => {
                            loadFolderBrowserDirectory(data.parent_path);
                        });
                        parentRow.addEventListener('mouseenter', () => {
                            parentRow.style.background = '#e8f4f8';
                        });
                        parentRow.addEventListener('mouseleave', () => {
                            parentRow.style.background = 'transparent';
                        });
                        folderBrowserContent.appendChild(parentRow);
                    }

                    // Add directories only
                    const directories = data.items.filter(item => item.is_directory);
                    directories.forEach(item => {
                        const row = createFolderBrowserRow(item, data.path);
                        folderBrowserContent.appendChild(row);
                    });

                    // Update navigation buttons
                    const navUpBtn = document.getElementById('wordFolderBrowserNavUp');
                    if (navUpBtn) {
                        navUpBtn.disabled = !data.parent_path;
                        navUpBtn.style.opacity = !data.parent_path ? '0.5' : '1';
                    }
                } else {
                    const errorMsg = data.detail || data.message || data.error || 'Unknown error';
                    folderBrowserContent.innerHTML = `
                        <div style="padding: 40px; text-align: center; color: #d32f2f;">
                            <div style="font-size: 48px; margin-bottom: 16px;">‚ö†Ô∏è</div>
                            <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">Error Loading Directory</div>
                            <div style="font-size: 14px; color: #666;">${errorMsg}</div>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('Error loading directory:', error);
                folderBrowserContent.innerHTML = `
                    <div style="padding: 40px; text-align: center; color: #d32f2f;">
                        <div style="font-size: 48px; margin-bottom: 16px;">‚ö†Ô∏è</div>
                        <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">Network Error</div>
                        <div style="font-size: 14px; color: #666;">${error.message || 'Failed to connect to server'}</div>
                    </div>
                `;
            }
        }

        // Create a folder row for the folder browser
        function createFolderBrowserRow(item, currentPath) {
            const row = document.createElement('div');
            row.style.cssText = 'display: flex; align-items: center; gap: 8px; padding: 8px 16px; cursor: pointer; border-bottom: 1px solid #f0f0f0; transition: background 0.15s;';
            
            row.innerHTML = `
                <span style="font-size: 20px;">üìÅ</span>
                <span style="font-size: 14px; color: #333;" title="${item.path}">${item.name}</span>
            `;

            row.addEventListener('click', () => {
                // Navigate into the folder
                loadFolderBrowserDirectory(item.path);
            });

            row.addEventListener('dblclick', () => {
                // Double-click to select and use this folder
                selectedFolderPath = item.path;
                if (wordSaveAsFolderPath) {
                    wordSaveAsFolderPath.value = item.path;
                }
                const folderBrowserDialog = document.getElementById('wordFolderBrowserDialog');
                if (folderBrowserDialog) folderBrowserDialog.style.display = 'none';
            });

            row.addEventListener('mouseenter', () => {
                row.style.background = '#e8f4f8';
            });
            row.addEventListener('mouseleave', () => {
                row.style.background = 'transparent';
            });

            return row;
        }

        // Update path breadcrumb in folder browser
        function updateFolderBrowserPathBreadcrumb(path) {
            const breadcrumb = document.getElementById('wordFolderBrowserPathBreadcrumb');
            if (!breadcrumb) return;
            
            const parts = path.split(/[\\/]/).filter(p => p);
            let breadcrumbHTML = '';
            let currentPath = '';
            
            parts.forEach((part, index) => {
                if (index === 0 && path.startsWith('\\')) {
                    currentPath = '\\' + part;
                } else {
                    currentPath = currentPath ? currentPath + '\\' + part : part;
                }
                
                breadcrumbHTML += `<span style="cursor: pointer; color: #0066cc; text-decoration: underline;" data-path="${currentPath}">${part}</span>`;
                if (index < parts.length - 1) {
                    breadcrumbHTML += '<span style="margin: 0 4px; color: #666;">\\</span>';
                }
            });
            
            breadcrumb.innerHTML = breadcrumbHTML || path;
            
            // Add click handlers to breadcrumb parts
            breadcrumb.querySelectorAll('[data-path]').forEach(span => {
                span.addEventListener('click', () => {
                    loadFolderBrowserDirectory(span.getAttribute('data-path'));
                });
            });
        }

        // Folder browser dialog event listeners
        const wordFolderBrowserDialog = document.getElementById('wordFolderBrowserDialog');
        const wordFolderBrowserDialogClose = document.getElementById('wordFolderBrowserDialogClose');
        const wordFolderBrowserCancel = document.getElementById('wordFolderBrowserCancel');
        const wordFolderBrowserSelect = document.getElementById('wordFolderBrowserSelect');
        const wordFolderBrowserNavUp = document.getElementById('wordFolderBrowserNavUp');
        const wordFolderBrowserRefresh = document.getElementById('wordFolderBrowserRefresh');

        // Close folder browser
        if (wordFolderBrowserDialogClose) {
            wordFolderBrowserDialogClose.addEventListener('click', () => {
                if (wordFolderBrowserDialog) wordFolderBrowserDialog.style.display = 'none';
            });
        }

        if (wordFolderBrowserCancel) {
            wordFolderBrowserCancel.addEventListener('click', () => {
                if (wordFolderBrowserDialog) wordFolderBrowserDialog.style.display = 'none';
            });
        }

        // Select folder button
        if (wordFolderBrowserSelect) {
            wordFolderBrowserSelect.addEventListener('click', () => {
                if (selectedFolderPath && wordSaveAsFolderPath) {
                    wordSaveAsFolderPath.value = selectedFolderPath;
                }
                if (wordFolderBrowserDialog) wordFolderBrowserDialog.style.display = 'none';
            });
        }

        // Navigation buttons
        if (wordFolderBrowserNavUp) {
            wordFolderBrowserNavUp.addEventListener('click', async () => {
                if (currentFolderBrowserPath) {
                    try {
                        const response = await fetch(`http://localhost:8000/api/word/list-directory?path=${encodeURIComponent(currentFolderBrowserPath)}`);
                        const data = await response.json();
                        if (data.success && data.parent_path) {
                            loadFolderBrowserDirectory(data.parent_path);
                        }
                    } catch (error) {
                        console.error('Error navigating up:', error);
                    }
                }
            });
        }

        if (wordFolderBrowserRefresh) {
            wordFolderBrowserRefresh.addEventListener('click', () => {
                if (currentFolderBrowserPath) {
                    loadFolderBrowserDirectory(currentFolderBrowserPath);
                }
            });
        }

        // Save As submit
        if (wordSaveAsSubmit) {
            wordSaveAsSubmit.addEventListener('click', async () => {
                const folderPath = wordSaveAsFolderPath?.value.trim();
                const fileName = wordSaveAsFileName?.value.trim();
                
                if (!folderPath) {
                    alert('Please enter a folder path');
                    wordSaveAsFolderPath?.focus();
                    return;
                }

                if (!fileName) {
                    alert('Please enter a file name');
                    wordSaveAsFileName?.focus();
                    return;
                }

                // Ensure the filename ends with .docx
                let finalFileName = fileName;
                if (!finalFileName.toLowerCase().endsWith('.docx')) {
                    finalFileName = finalFileName + '.docx';
                    if (wordSaveAsFileName) wordSaveAsFileName.value = finalFileName;
                }

                // Combine folder path and filename
                // Normalize path separators - ensure we use the EXACT folder path the user selected
                let normalizedFolder = folderPath.trim();
                
                // Remove any quotes that might have been added
                normalizedFolder = normalizedFolder.replace(/^["']|["']$/g, '');
                
                // Replace forward slashes with backslashes for Windows
                normalizedFolder = normalizedFolder.replace(/\//g, '\\');
                
                // Remove trailing slashes but keep the path intact
                normalizedFolder = normalizedFolder.replace(/\\+$/, '');
                
                // Ensure we have a valid folder path (not empty)
                if (!normalizedFolder) {
                    alert('Please select a valid folder path');
                    wordSaveAsFolderPath?.focus();
                    return;
                }
                
                // Validate that the folder path looks valid (starts with a drive letter on Windows)
                if (normalizedFolder.length < 3 || !/^[A-Za-z]:/.test(normalizedFolder)) {
                    console.warn('Folder path might be invalid:', normalizedFolder);
                }
                
                // Construct the full file path using the selected folder
                // Use proper path separator
                const finalPath = `${normalizedFolder}\\${finalFileName}`;

                // Debug: Log the path being used to verify it's correct
                console.log('=== SAVE AS DIALOG ===');
                console.log('Raw folder path input:', folderPath);
                console.log('Normalized folder path:', normalizedFolder);
                console.log('File name:', finalFileName);
                console.log('Final full path:', finalPath);
                console.log('========================');

                // Save the document using the selected folder path
                await saveWordDocument(finalPath);
                
                // Close the modal
                if (wordSaveAsModal) wordSaveAsModal.style.display = 'none';
            });
        }

        // Function to save Word document (called from Save As dialog)
        // NOTE: This function is ONLY called when user explicitly requests to save.
        // There is NO auto-save functionality - files are saved only on user action.
        async function saveWordDocument(savePath = null) {
            const editorContent = document.getElementById('wordEditorContent');
            if (!editorContent) {
                alert('No document to save');
                return;
            }

            // Use provided path (from Save As dialog) or current document path
            const filePath = savePath || currentWordDocument.filePath;
            if (!filePath) {
                alert('Please specify a file path');
                showSaveAsDialog();
                return;
            }
            
            // Debug: Log the file path being used
            console.log('saveWordDocument called with filePath:', filePath);
            console.log('savePath parameter:', savePath);
            console.log('currentWordDocument.filePath:', currentWordDocument.filePath);

            // Get HTML content to preserve formatting
            const htmlContent = editorContent.innerHTML || '';
            
            // Debug: Log the content being saved
            console.log('=== SAVE DEBUG ===');
            console.log('HTML content length:', htmlContent.length);
            console.log('HTML content preview (first 500 chars):', htmlContent.substring(0, 500));
            console.log('Editor element:', editorContent);
            console.log('Editor innerHTML length:', editorContent.innerHTML ? editorContent.innerHTML.length : 0);
            
            // Check if content is empty
            const textContent = editorContent.innerText || editorContent.textContent || '';
            console.log('Text content length:', textContent.length);
            console.log('Text content preview:', textContent.substring(0, 200));
            
            if (!textContent.trim() && !htmlContent.trim()) {
                alert('Document is empty. Please add some content before saving.');
                const saveBtn = document.getElementById('wordEditorSave');
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.textContent = 'üíæ Save';
                }
                return;
            }
            
            // Ensure we have HTML content - use text content as fallback if needed
            let contentToSave = htmlContent;
            if (!htmlContent || htmlContent.trim() === '' || htmlContent.trim() === '<br>') {
                console.warn('Warning: HTML content is empty or minimal, using text content instead');
                // If HTML is empty but text exists, create a simple paragraph
                contentToSave = `<p>${textContent.replace(/\n/g, '</p><p>')}</p>`;
                console.log('Using fallback HTML:', contentToSave);
            }
            
            const saveBtn = document.getElementById('wordEditorSave');
            
            if (saveBtn) {
                saveBtn.disabled = true;
                saveBtn.textContent = 'üíæ Saving...';
            }

            try {
                // Save HTML content with formatting preserved
                console.log('=== SENDING SAVE REQUEST ===');
                console.log('File path:', filePath);
                console.log('Content to save length:', contentToSave.length);
                console.log('Content to save preview:', contentToSave.substring(0, 300));
                
                const saveResponse = await fetch('http://localhost:8000/api/word/save-html', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        file_path: filePath,
                        html_content: contentToSave
                    })
                });
                
                console.log('Save response status:', saveResponse.status);
                console.log('Save response ok:', saveResponse.ok);

                if (!saveResponse.ok) {
                    let errorMessage = `HTTP ${saveResponse.status}: Failed to save document`;
                    try {
                        const errorData = await saveResponse.json();
                        errorMessage = errorData.detail || errorData.message || errorData.error || errorMessage;
                    } catch (e) {
                        // If response is not JSON, use status text
                        errorMessage = `${saveResponse.status}: ${saveResponse.statusText || 'Unknown error'}`;
                    }
                    throw new Error(errorMessage);
                }
                
                const saveData = await saveResponse.json();
                console.log('Save response:', saveData);
                
                if (saveData.success) {
                    // Use the file path from the response if available, otherwise use what we sent
                    const savedPath = saveData.file_path || filePath;
                    
                    // Update current document path
                    currentWordDocument.filePath = savedPath;
                    
                    // Update the editor header to show new path
                    const editorTitle = document.querySelector('.word-editor-title');
                    if (editorTitle) {
                        const fileName = savedPath.split('\\').pop() || savedPath.split('/').pop() || 'Document';
                        editorTitle.innerHTML = `<span style="font-weight: 600;">üìÑ ${fileName}</span><span style="font-size: 12px; color: #666; margin-left: 12px;">${savedPath}</span>`;
                    }
                    
                    // Show success message with the actual saved path
                    alert(`Document saved successfully!\n\nPath: ${savedPath}`);
                    
                    if (saveBtn) {
                        saveBtn.textContent = 'üíæ Saved!';
                        setTimeout(() => {
                            if (saveBtn) {
                                saveBtn.textContent = 'üíæ Save';
                                saveBtn.disabled = false;
                            }
                        }, 2000);
                    }
                } else {
                    throw new Error(saveData.detail || saveData.message || saveData.error || 'Failed to save document');
                }
            } catch (error) {
                console.error('Error saving document:', error);
                alert('Error saving document: ' + error.message);
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.textContent = 'üíæ Save';
                }
            }
        }

        // Open create modal - now directly creates and opens editor
        if (createWordDocButton) {
            createWordDocButton.addEventListener('click', async () => {
                // Generate a default file path
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
                const defaultPath = await getDefaultDocumentsPath();
                const filePath = `${defaultPath}\\document_${timestamp}.docx`;
                
                // Create document with default values
                createWordDocButton.disabled = true;
                createWordDocButton.textContent = 'Creating...';
                
                try {
                    const response = await fetch('http://localhost:8000/api/word/create', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            file_path: filePath,
                            title: 'Untitled Document',
                            content: ''
                        })
                    });

                    const data = await response.json();
                    if (response.ok && data.success) {
                        // Open the document in the editor immediately
                        openWordEditor(filePath, 'Untitled Document', '');
                    } else {
                        const errorMsg = data.detail || data.message || data.error || 'Failed to create document';
                        alert('Error creating document:\n\n' + errorMsg);
                    }
                } catch (error) {
                    console.error('Error creating document:', error);
                    alert('Error creating document: ' + error.message);
                } finally {
                    createWordDocButton.disabled = false;
                    createWordDocButton.textContent = 'Create Document';
                }
            });
        }

        // Open document modal
        if (openWordDocButton) {
            openWordDocButton.addEventListener('click', () => {
                if (wordOpenModal) wordOpenModal.style.display = 'flex';
            });
        }

        // Close modals
        if (wordCreateModalClose) {
            wordCreateModalClose.addEventListener('click', () => {
                if (wordCreateModal) wordCreateModal.style.display = 'none';
            });
        }

        if (wordOpenModalClose) {
            wordOpenModalClose.addEventListener('click', () => {
                if (wordOpenModal) wordOpenModal.style.display = 'none';
            });
        }

        if (wordCreateCancel) {
            wordCreateCancel.addEventListener('click', () => {
                if (wordCreateModal) wordCreateModal.style.display = 'none';
            });
        }

        if (wordOpenCancel) {
            wordOpenCancel.addEventListener('click', () => {
                if (wordOpenModal) wordOpenModal.style.display = 'none';
            });
        }

        // Create document
        if (wordCreateSubmit) {
            wordCreateSubmit.addEventListener('click', async () => {
                const filePath = document.getElementById('wordFilePath')?.value.trim();
                const title = document.getElementById('wordDocTitle')?.value.trim();
                const content = document.getElementById('wordDocContent')?.value.trim();

                if (!filePath) {
                    alert('Please enter a file path (e.g., C:\\Users\\YourName\\Documents\\mydocument.docx)');
                    return;
                }

                // Ensure the path ends with .docx
                if (!filePath.toLowerCase().endsWith('.docx')) {
                    filePath = filePath + '.docx';
                    document.getElementById('wordFilePath').value = filePath;
                }

                wordCreateSubmit.disabled = true;
                wordCreateSubmit.textContent = 'Creating...';

                try {
                    const response = await fetch('http://localhost:8000/api/word/create', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            file_path: filePath,
                            title: title || undefined,
                            content: content || undefined
                        })
                    });

                    const data = await response.json();
                    if (response.ok && data.success) {
                        if (wordCreateModal) wordCreateModal.style.display = 'none';
                        // Clear form
                        if (document.getElementById('wordFilePath')) document.getElementById('wordFilePath').value = '';
                        if (document.getElementById('wordDocTitle')) document.getElementById('wordDocTitle').value = '';
                        if (document.getElementById('wordDocContent')) document.getElementById('wordDocContent').value = '';
                        
                        // Open the document in the editor
                        openWordEditor(filePath, title || 'Untitled Document', content || '');
                    } else {
                        const errorMsg = data.detail || data.message || data.error || 'Failed to create document';
                        console.error('Create document error:', errorMsg);
                        alert('Error creating document:\n\n' + errorMsg + '\n\nPlease check:\n- The file path is correct and writable\n- The directory exists\n- You have permission to write to that location');
                    }
                } catch (error) {
                    console.error('Error creating document:', error);
                    alert('Error creating document: ' + error.message + '\n\nPlease check your network connection and try again.');
                } finally {
                    wordCreateSubmit.disabled = false;
                    wordCreateSubmit.textContent = 'Create Document';
                }
            });
        }

        // Open document
        if (wordOpenSubmit) {
            wordOpenSubmit.addEventListener('click', async () => {
                const filePath = document.getElementById('wordOpenFilePath')?.value.trim();

                if (!filePath) {
                    alert('Please enter a file path (e.g., C:\\Users\\YourName\\Documents\\mydocument.docx)');
                    return;
                }

                // Ensure the path ends with .docx if no extension
                if (!filePath.includes('.') && !filePath.toLowerCase().endsWith('.docx')) {
                    filePath = filePath + '.docx';
                    document.getElementById('wordOpenFilePath').value = filePath;
                }

                wordOpenSubmit.disabled = true;
                wordOpenSubmit.textContent = 'Opening...';

                try {
                    const response = await fetch('http://localhost:8000/api/word/open', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            file_path: filePath
                        })
                    });

                    const data = await response.json();
                    if (response.ok && data.success) {
                        // Close the modal
                        if (wordOpenModal) wordOpenModal.style.display = 'none';
                        
                        // Get document content and open in editor
                        const content = data.data?.content || '';
                        const fileName = filePath.split('\\').pop() || filePath.split('/').pop() || 'Document';
                        
                        // Open the document in the Word editor
                        openWordEditor(filePath, fileName, content);
                        
                        console.log('Document opened successfully:', filePath);
                    } else {
                        const errorMsg = data.detail || data.message || data.error || 'Failed to open document';
                        console.error('Open document error:', errorMsg);
                        alert('Error opening document:\n\n' + errorMsg + '\n\nPlease check:\n- The file path is correct\n- The file exists\n- The file is a valid .docx document\n- You have permission to read the file');
                    }
                } catch (error) {
                    console.error('Error opening document:', error);
                    alert('Error opening document: ' + error.message + '\n\nPlease check your network connection and try again.');
                } finally {
                    wordOpenSubmit.disabled = false;
                    wordOpenSubmit.textContent = 'Open Document';
                }
            });
        }

        // Slack send message functionality
        const slackMessageInput = document.getElementById('slackMessageInput');
        const slackSendButton = document.getElementById('slackSendButton');

        // Auto-resize textarea
        if (slackMessageInput) {
            slackMessageInput.addEventListener('input', function() {
                this.style.height = 'auto';
                this.style.height = Math.min(this.scrollHeight, 150) + 'px';
                slackSendButton.disabled = !this.value.trim() || !currentChannelId;
            });

            slackMessageInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    if (!slackSendButton.disabled) {
                        sendSlackMessage();
                    }
                }
            });
        }

        async function sendSlackMessage() {
            if (!currentChannelId || !slackMessageInput) return;
            
            const text = slackMessageInput.value.trim();
            if (!text) return;
        
            // Disable input while sending
            slackMessageInput.disabled = true;
            slackSendButton.disabled = true;
            slackSendButton.innerHTML = '<div class="slack-send-spinner"></div>';

            try {
                console.log(`[*] Sending message to channel ${currentChannelId}...`);
                const response = await fetch('http://localhost:8000/api/slack/send', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        channel_id: currentChannelId,
                        text: text
                    })
                });

                console.log('[*] Response status:', response.status);
                const data = await response.json();
                console.log('[*] Response data:', data);

                if (response.ok && data.success) {
                    // Clear input
                    slackMessageInput.value = '';
                    slackMessageInput.style.height = 'auto';
                    
                    // Reload messages to show the new one
                    await loadSlackMessages();
                    
                    // Re-select the current channel
                    if (currentChannelId) {
                        selectChannel(currentChannelId);
                    }
                } else {
                    const errorMsg = data.error || data.detail || JSON.stringify(data);
                    console.error('[!] Backend error:', errorMsg);
                    alert(`Failed to send message: ${errorMsg}`);
                }
            } catch (error) {
                console.error('[!] Exception:', error);
                alert(`Failed to send message: ${error.message}`);
            } finally {
                // Re-enable input
                slackMessageInput.disabled = false;
                slackSendButton.disabled = false;
                slackSendButton.innerHTML = `
                    <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                        <path d="M18 2L9 11M18 2L12 18L9 11M18 2L2 8L9 11" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                `;
                slackMessageInput.focus();
            }
        }

        if (slackSendButton) {
            slackSendButton.addEventListener('click', sendSlackMessage);
        }
    </script>
</body>
</html>
