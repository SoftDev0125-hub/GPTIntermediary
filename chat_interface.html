<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChatGPT Assistant - AI-Powered Automation</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <script>
        for(let i = 0; i < 30; i++) {
            let particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.left = Math.random() * 100 + '%';
            particle.style.animationDelay = Math.random() * 15 + 's';
            particle.style.animationDuration = (Math.random() * 10 + 10) + 's';
            document.body.appendChild(particle);
        }
    </script>

    <div class="container">
        <div class="tab-bar">
            <button class="tab-button active" data-tab="chat">Chat</button>
            <button class="tab-button" data-tab="email">Email</button>
            <button class="tab-button" data-tab="whatsapp">WhatsApp</button>
            <button class="tab-button" data-tab="telegram">Telegram</button>
            <button class="tab-button" data-tab="slack">Slack</button>
        </div>

        <div id="chat" class="tab-content active">
            <div class="header">
                <div class="header-content">
                    <h1>ChatGPT Assistant</h1>
                    <div class="status-badge">Online</div>
                </div>
            </div>

            <div class="chat-container" id="chatContainer">
                <div class="message system">
                    <div class="message-content">
                        <strong>Welcome to ChatGPT Assistant!</strong><br>
                        Your AI-powered automation system is ready. Try:<br>
                        &bull; "Launch calculator" or "Open notepad"<br>
                        &bull; "Send email to user@example.com"<br>
                        &bull; Or ask any question!
                    </div>
                </div>
            </div>

            <div class="typing-indicator" id="typingIndicator">
                <span></span>
                <span></span>
                <span></span>
            </div>

            <div class="input-container">
                <div class="input-wrapper">
                    <input 
                        type="text" 
                        id="messageInput" 
                        placeholder="Type your message or command..."
                        autocomplete="off"
                    />
                    <button id="sendButton" class="btn">Send</button>
                </div>
            </div>
        </div>

        <div id="email" class="tab-content">
            <div class="header">
                <div class="header-content">
                    <h1>Email Management</h1>
                    <div class="status-badge">Ready</div>
                </div>
            </div>

            <div class="email-container">
                <div class="email-header">
                    <h2>Inbox</h2>
                    <div class="email-count" id="emailCount">Unread: --</div>
                    <div class="button-group">
                        <button id="unreadButton" class="btn">Unread Mail</button>
                        <button id="refreshButton" class="btn btn-secondary">Refresh</button>
                    </div>
                </div>


                <div class="email-scroll-area">
                    <div class="pagination-controls pagination-top" id="paginationControlsTop" style="display: none;">
                        <button id="prevButtonTop" class="btn btn-pagination">‚Üê Previous</button>
                        <div class="page-numbers" id="pageNumbers"></div>
                        <button id="nextButtonTop" class="btn btn-pagination">Next ‚Üí</button>
                    </div>
                    <div id="emailList" class="email-list">
                        <div class="empty-state">
                            <div class="empty-state-text">Mail</div>
                            <p>Click "Unread Mail" to load your emails</p>
                        </div>
                    </div>
                    <div class="pagination-controls" id="paginationControls" style="display: none;">
                        <button id="prevButton" class="btn btn-pagination">‚Üê Previous</button>
                        <div class="page-numbers" id="pageNumbersBottom"></div>
                        <button id="nextButton" class="btn btn-pagination">Next ‚Üí</button>
                    </div>
                </div>

                <!-- Email Detail Modal - Beautiful Dialog -->
                <div class="email-detail-modal" id="emailDetailModal" style="display: none;">
                    <div class="email-detail-overlay"></div>
                    <div class="email-detail-container">
                        <div class="email-detail-header">
                            <div class="email-detail-header-content">
                                <h2 id="detailSubject" class="email-detail-subject">Subject</h2>
                                <button class="email-close-btn" id="closeEmailBtn" aria-label="Close">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <line x1="18" y1="6" x2="6" y2="18"></line>
                                        <line x1="6" y1="6" x2="18" y2="18"></line>
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <div class="email-detail-info">
                            <div class="email-detail-info-row">
                                <div class="email-detail-info-item">
                                    <span class="email-detail-label">From:</span>
                                    <span id="detailFrom" class="email-detail-value">sender@example.com</span>
                                </div>
                                <div class="email-detail-info-item">
                                    <span class="email-detail-label">Date:</span>
                                    <span id="detailDate" class="email-detail-value">Date</span>
                                </div>
                            </div>
                        </div>
                        <div class="email-detail-body-container">
                            <div class="email-detail-body" id="detailBody">
                                <!-- Email body content here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="whatsapp" class="tab-content">
            <div class="whatsapp-container">
                <!-- WhatsApp Sidebar -->
                <div class="whatsapp-sidebar">
                    <div class="whatsapp-sidebar-header">
                        <h2>Chats</h2>
                        <button id="whatsappRefreshButton" class="whatsapp-refresh-btn">Refresh</button>
                </div>
                    <div class="whatsapp-sidebar-content" id="whatsappChatsList">
                        <div class="whatsapp-sidebar-empty">Click "Refresh" to load chats</div>
                    </div>
                </div>

                <!-- WhatsApp Main Area -->
                <div class="whatsapp-main">
                    <!-- QR Code Area (shown when not connected) -->
                    <div id="whatsappQRCode" style="display: flex; text-align: center; padding: 20px; height: 100%; flex-direction: column; justify-content: center; align-items: center; overflow: auto;">
                        <h3 style="color: #e2e8f0; margin-bottom: 15px;">WhatsApp Connection</h3>
                        <div style="background: rgba(37, 211, 102, 0.1); padding: 20px; border-radius: 10px; margin-bottom: 15px; border: 1px solid rgba(37, 211, 102, 0.3); max-width: 700px; width: 100%;">
                            <p style="color: #e2e8f0; margin-bottom: 15px;">
                                Connect your <strong>personal WhatsApp account</strong> using WhatsApp Web.
                            </p>
                            <p style="color: #94a3b8; margin-bottom: 15px;">
                                Scan the QR code below with your WhatsApp mobile app:
                            </p>
                            <ol style="text-align: left; color: #94a3b8; margin: 15px 0; padding-left: 20px;">
                                <li>Open WhatsApp on your phone</li>
                                <li>Tap Menu (three dots) or Settings</li>
                                <li>Tap "Linked Devices" or "WhatsApp Web"</li>
                                <li>Tap "Link a Device"</li>
                                <li>Point your phone at the QR code below</li>
                            </ol>
                            <button id="refreshQRButton" onclick="loadQRCode()" style="background: #25d366; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; margin: 15px 0; font-size: 0.9em; font-weight: 500;">
                                üîÑ Refresh QR Code
                            </button>
                            <div id="connectionStatus" style="margin-top: 15px; color: #94a3b8; min-height: 20px;">
                                <span style="color: #94a3b8;">‚è≥ Loading QR code...</span>
                            </div>
                    </div>
                </div>

                    <!-- WhatsApp Messages Area (shown when connected) -->
                    <div class="whatsapp-header" id="whatsappHeader" style="display: none;">
                        <div class="whatsapp-header-content">
                            <h2 id="whatsappCurrentChat">Select a chat</h2>
                            <div class="whatsapp-header-info" id="whatsappCount">-- messages</div>
                        </div>
                            </div>
                    <div class="whatsapp-messages-container" id="whatsappMessagesContainer" style="display: none;">
                        <div class="whatsapp-empty-state">
                            <div class="whatsapp-empty-icon">üí¨</div>
                            <h3>Welcome to WhatsApp</h3>
                            <p>Select a chat from the sidebar or click "Refresh" to load your messages</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="telegram" class="tab-content">
            <div class="telegram-container">
                <!-- Telegram Sidebar -->
                <div class="telegram-sidebar">
                    <div class="telegram-sidebar-header">
                        <h2>Chats</h2>
                        <button id="telegramShowButton" class="telegram-refresh-btn">Refresh</button>
                </div>
                    <div class="telegram-sidebar-content" id="telegramChatsList">
                        <div class="telegram-sidebar-empty">Click "Refresh" to load chats</div>
                    </div>
                </div>

                <!-- Telegram Main Area -->
                <div class="telegram-main">
                    <div class="telegram-header">
                        <div class="telegram-header-content">
                            <h2 id="telegramCurrentChat">Select a chat</h2>
                            <div class="telegram-header-info" id="telegramCount">-- messages</div>
                        </div>
                    </div>
                    <div class="telegram-messages-container" id="telegramMessagesContainer">
                        <div class="telegram-empty-state">
                            <div class="telegram-empty-icon">‚úàÔ∏è</div>
                            <h3>Welcome to Telegram</h3>
                            <p>Select a chat from the sidebar or click "Refresh" to load your messages</p>
                </div>
                        </div>
                    <div class="telegram-input-container" id="telegramInputContainer" style="display: none;">
                        <div class="telegram-input-wrapper">
                            <textarea 
                                id="telegramMessageInput" 
                                class="telegram-message-input" 
                                placeholder="Type a message..."
                                rows="1"
                            ></textarea>
                            <button id="telegramSendButton" class="telegram-send-button" disabled>
                                <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                                    <path d="M18 2L9 11M18 2L12 18L9 11M18 2L2 8L9 11" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </button>
                            </div>
                            </div>
                </div>
            </div>
        </div>

        <div id="slack" class="tab-content">
            <div class="slack-container">
                <!-- Slack Sidebar -->
                <div class="slack-sidebar">
                    <div class="slack-sidebar-header">
                        <h2>Channels & Conversations</h2>
                        <button id="slackViewButton" class="slack-refresh-btn">Refresh</button>
                </div>
                    <div class="slack-sidebar-content" id="slackChannelsList">
                        <div class="slack-sidebar-empty">Click "Refresh" to load channels</div>
                    </div>
                </div>

                <!-- Slack Main Area -->
                <div class="slack-main">
                    <div class="slack-header">
                        <div class="slack-header-content">
                            <h2 id="slackCurrentChannel">Select a channel</h2>
                            <div class="slack-header-info" id="slackCount">-- messages</div>
                        </div>
                    </div>
                    <div class="slack-messages-container" id="slackMessagesContainer">
                        <div class="slack-empty-state">
                            <div class="slack-empty-icon">üí¨</div>
                            <h3>Welcome to Slack</h3>
                            <p>Select a channel from the sidebar or click "Refresh" to load your messages</p>
                </div>
                        </div>
                    <div class="slack-input-container" id="slackInputContainer" style="display: none;">
                        <div class="slack-input-wrapper">
                            <textarea 
                                id="slackMessageInput" 
                                class="slack-message-input" 
                                placeholder="Message #channel"
                                rows="1"
                            ></textarea>
                            <button id="slackSendButton" class="slack-send-button" disabled>
                                <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                                    <path d="M18 2L9 11M18 2L12 18L9 11M18 2L2 8L9 11" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </button>
                            </div>
                            </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', () => {
                const tabName = button.dataset.tab;
                
                document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                button.classList.add('active');
                document.getElementById(tabName).classList.add('active');
                
                if (tabName === 'chat') {
                    document.getElementById('messageInput').focus();
                }
            });
        });

        const chatContainer = document.getElementById('chatContainer');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const typingIndicator = document.getElementById('typingIndicator');

        function addMessage(text, type = 'assistant') {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            // Format the message to preserve line breaks and add proper paragraph spacing
            let formattedText = text
                .replace(/\n\n/g, '</p><p>') // Double newlines become new paragraphs
                .replace(/\n/g, '<br>') // Single newlines become line breaks
                .replace(/^(.+)$/, '<p>$1</p>'); // Wrap in paragraph tags
            
            // Enhance emoji and icon display
            formattedText = enhanceIconsAndEmojis(formattedText);
            
            contentDiv.innerHTML = formattedText;
            
            messageDiv.appendChild(contentDiv);
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        function enhanceIconsAndEmojis(text) {
            // Wrap standalone emojis in a span for better styling
            text = text.replace(/([\u{1F300}-\u{1F9FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}])/gu, '<span class="emoji-icon">$1</span>');
            
            // Convert common text patterns to visual icons
            text = text.replace(/\b(‚úì|‚úîÔ∏è|‚úÖ)/g, '<span class="icon-success">$1</span>');
            text = text.replace(/\b(‚úó|‚ùå|‚õî)/g, '<span class="icon-error">$1</span>');
            text = text.replace(/\b(‚ÑπÔ∏è|‚Ñπ|üí°)/g, '<span class="icon-info">$1</span>');
            text = text.replace(/\b(‚ö†Ô∏è|‚ö†|‚ö°)/g, '<span class="icon-warning">$1</span>');
            
            // Enhance bullet points with icons
            text = text.replace(/‚Ä¢/g, '<span class="bullet-icon">‚Ä¢</span>');
            text = text.replace(/‚Üí/g, '<span class="arrow-icon">‚Üí</span>');
            
            return text;
        }

        async function sendMessage() {
            const message = messageInput.value.trim();
            if (!message) return;

            addMessage(message, 'user');
            messageInput.value = '';
            sendButton.disabled = true;

            typingIndicator.classList.add('active');

            try {
                const response = await fetch('http://localhost:5000/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ message: message })
                });

                const data = await response.json();
                typingIndicator.classList.remove('active');

                if (response.ok) {
                    addMessage(data.response, 'assistant');
                } else {
                    addMessage(`ERROR: ${data.error || 'Unknown error'}`, 'error');
                }
            } catch (error) {
                typingIndicator.classList.remove('active');
                addMessage(`CONNECTION ERROR: ${error.message}`, 'error');
            }

            sendButton.disabled = false;
            messageInput.focus();
        }

        sendButton.addEventListener('click', sendMessage);
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });

        const unreadButton = document.getElementById('unreadButton');
        const refreshButton = document.getElementById('refreshButton');
        const emailList = document.getElementById('emailList');
        const emailCount = document.getElementById('emailCount');

        let allEmails = [];
        let totalUnread = 0;
        let currentPage = 1;
        const emailsPerPage = 10;

        function getTotalPages() {
            return Math.ceil(allEmails.length / emailsPerPage);
        }

        function goToPage(pageNum) {
            const totalPages = getTotalPages();
            if (pageNum < 1 || pageNum > totalPages) return;
            currentPage = pageNum;
            renderEmails();
        }

        function updateEmailCount() {
            if (!emailCount) return;
            const shown = allEmails.length;
            const total = totalUnread || 0;
            emailCount.textContent = `Showing ${shown} / ${total} unread`;
        }

        // Get credentials from environment (exposed by backend)
        async function getUserCredentials() {
            try {
                const response = await fetch('http://localhost:5000/get_user_credentials');
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Error fetching credentials:', error);
                return null;
            }
        }

        function renderEmails() {
            const totalPages = getTotalPages();
            const startIdx = (currentPage - 1) * emailsPerPage;
            const endIdx = startIdx + emailsPerPage;
            const paginatedEmails = allEmails.slice(startIdx, endIdx);

            const emailItems = paginatedEmails.map((email, index) => `
                <div class="email-item" data-email-index="${startIdx + index}">
                    <div class="email-from">From: ${email.from_email || 'Unknown'}</div>
                    <div class="email-subject">${email.subject || '(No Subject)'}</div>
                    <div class="email-date">${email.date || new Date().toLocaleDateString()}</div>
                </div>
            `).join('');

            emailList.innerHTML = emailItems;
            updateEmailCount();

            // Add click handlers to email items
            document.querySelectorAll('.email-item').forEach(item => {
                item.addEventListener('click', () => {
                    const emailIndex = parseInt(item.dataset.emailIndex);
                    showEmailDetail(allEmails[emailIndex]);
                });
            });

            // Update pagination controls (both top and bottom)
            updatePaginationControls(totalPages);
        }

        function showEmailDetail(email) {
            const modal = document.getElementById('emailDetailModal');
            const detailSubject = document.getElementById('detailSubject');
            const detailFrom = document.getElementById('detailFrom');
            const detailDate = document.getElementById('detailDate');
            const detailBody = document.getElementById('detailBody');

            // Populate modal with email data
            detailSubject.textContent = email.subject || '(No Subject)';
            detailFrom.textContent = email.from_email || email.from || 'Unknown';
            detailDate.textContent = email.date || new Date().toLocaleDateString();
            
            // Format body content with better readability
            const bodyContent = email.body || 'No content available';
            
            // Clear previous content
            detailBody.innerHTML = '';
            detailBody.className = 'email-detail-body';
            
            // Check if body contains HTML
            if (bodyContent.includes('<') && bodyContent.includes('>')) {
                // Render as HTML (with sanitization) - like Gmail
                detailBody.innerHTML = sanitizeHtml(bodyContent);
                detailBody.className = 'email-detail-body email-detail-body-html';
            } else {
                // Render as plain text with better formatting
                const formattedText = bodyContent
                    .replace(/\n\n+/g, '\n\n') // Normalize multiple line breaks
                    .replace(/\n/g, '<br>'); // Convert line breaks to HTML
                detailBody.innerHTML = `<div class="email-text-content">${formattedText}</div>`;
                detailBody.className = 'email-detail-body email-detail-body-text';
            }

            // Show modal with animation
            modal.style.display = 'flex';
            setTimeout(() => {
                modal.classList.add('email-modal-visible');
            }, 10);
            
            // Prevent body scroll when modal is open
            document.body.style.overflow = 'hidden';
            
            // Mark email as read in Gmail
            markEmailAsRead(email);
        }

        function closeEmailDetail() {
            const modal = document.getElementById('emailDetailModal');
            modal.classList.remove('email-modal-visible');
            setTimeout(() => {
                modal.style.display = 'none';
                document.body.style.overflow = '';
            }, 300);
        }

        async function markEmailAsRead(email) {
            try {
                // Get credentials
                const creds = await getUserCredentials();
                if (!creds || !creds.access_token) {
                    console.warn('Cannot mark email as read: credentials missing');
                    return;
                }
                
                // Call API to mark email as read
                const response = await fetch('http://localhost:8000/api/email/mark-read', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        user_credentials: creds,
                        message_id: email.message_id
                    })
                });
                
                if (response.ok) {
                    console.log(`[OK] Email marked as read: ${email.message_id}`);
                } else {
                    const error = await response.json();
                    console.error('Error marking email as read:', error.detail);
                }
            } catch (error) {
                console.error('Exception marking email as read:', error);
            }
        }

        function sanitizeHtml(html) {
            // Create a temporary container to parse HTML
            const temp = document.createElement('div');
            temp.innerHTML = html;
            
            // Remove potentially dangerous scripts and style elements
            const scripts = temp.querySelectorAll('script, style');
            scripts.forEach(el => el.remove());
            
            // Remove event handlers from all elements
            const allElements = temp.querySelectorAll('*');
            allElements.forEach(el => {
                // Remove all on* attributes (onclick, onload, etc.)
                Array.from(el.attributes).forEach(attr => {
                    if (attr.name.startsWith('on')) {
                        el.removeAttribute(attr.name);
                    }
                });
                
                // Make links safe to open in browser
                if (el.tagName === 'A') {
                    el.target = '_blank';
                    el.rel = 'noopener noreferrer';
                }
            });
            
            return temp.innerHTML;
        }

        function updatePaginationControls(totalPages) {
            const paginationControlsTop = document.getElementById('paginationControlsTop');
            const paginationControls = document.getElementById('paginationControls');
            const prevButton = document.getElementById('prevButton');
            const nextButton = document.getElementById('nextButton');
            const prevButtonTop = document.getElementById('prevButtonTop');
            const nextButtonTop = document.getElementById('nextButtonTop');

            if (totalPages > 1) {
                // Show both pagination controls
                paginationControlsTop.style.display = 'flex';
                paginationControls.style.display = 'flex';
                
                // Update button states for both top and bottom
                prevButton.disabled = currentPage === 1;
                nextButton.disabled = currentPage === totalPages;
                prevButtonTop.disabled = currentPage === 1;
                nextButtonTop.disabled = currentPage === totalPages;
                
                // Generate page numbers for both top and bottom (same structure)
                generatePageNumbers(totalPages, 'pageNumbers');
                generatePageNumbers(totalPages, 'pageNumbersBottom');
            } else {
                paginationControlsTop.style.display = 'none';
                paginationControls.style.display = 'none';
            }
        }

        function generatePageNumbers(totalPages, containerId = 'pageNumbers') {
            const pageNumbers = document.getElementById(containerId);
            if (!pageNumbers) return;
            
            let numbersHTML = '';
            
            // Show up to 7 page numbers with ellipsis for large page counts
            const maxVisible = 7;
            
            if (totalPages <= maxVisible) {
                // Show all pages
                for (let i = 1; i <= totalPages; i++) {
                    numbersHTML += `<button class="page-number ${i === currentPage ? 'active' : ''}" data-page="${i}">${i}</button>`;
                }
            } else {
                // Show first page
                numbersHTML += `<button class="page-number ${currentPage === 1 ? 'active' : ''}" data-page="1">1</button>`;
                
                if (currentPage > 3) {
                    numbersHTML += `<span class="page-ellipsis">...</span>`;
                }
                
                // Show pages around current page
                const start = Math.max(2, currentPage - 1);
                const end = Math.min(totalPages - 1, currentPage + 1);
                
                for (let i = start; i <= end; i++) {
                    numbersHTML += `<button class="page-number ${i === currentPage ? 'active' : ''}" data-page="${i}">${i}</button>`;
                }
                
                if (currentPage < totalPages - 2) {
                    numbersHTML += `<span class="page-ellipsis">...</span>`;
                }
                
                // Show last page
                numbersHTML += `<button class="page-number ${currentPage === totalPages ? 'active' : ''}" data-page="${totalPages}">${totalPages}</button>`;
            }
            
            pageNumbers.innerHTML = numbersHTML;
            
            // Add click handlers to page number buttons
            pageNumbers.querySelectorAll('.page-number').forEach(btn => {
                btn.addEventListener('click', () => {
                    const page = parseInt(btn.dataset.page);
                    goToPage(page);
                });
            });
        }

        async function loadUnreadEmails() {
            unreadButton.disabled = true;
            unreadButton.textContent = 'Loading...';
            allEmails = [];
            totalUnread = 0;
            currentPage = 1;

            try {
                // Get real credentials
                console.log('[*] Fetching credentials...');
                const creds = await getUserCredentials();
                console.log('[*] Got credentials:', {
                    access_token: creds?.access_token ? creds.access_token.substring(0, 20) + '...' : 'NONE',
                    refresh_token: creds?.refresh_token ? creds.refresh_token.substring(0, 20) + '...' : 'NONE',
                    email: creds?.email
                });
                
                if (!creds || !creds.access_token) {
                    console.error('[!] Credentials missing');
                    emailList.innerHTML = '<div class="empty-state"><div class="empty-state-text">Error</div><p>Gmail credentials not found. Please restart the app.</p></div>';
                    if (emailCount) emailCount.textContent = 'Showing 0 / -- unread';
                    unreadButton.disabled = false;
                    unreadButton.textContent = 'Unread Mail';
                    return;
                }

                console.log('[*] Requesting unread emails from backend...');
                const response = await fetch('http://localhost:8000/api/email/unread', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        user_credentials: creds,
                        max_results: 1000
                    })
                });

                console.log('[*] Response status:', response.status);
                const data = await response.json();
                console.log('[*] Response data:', data);

                if (response.ok && data.success) {
                    allEmails = data.emails || [];
                    totalUnread = typeof data.total_unread === 'number' ? data.total_unread : allEmails.length;
                    updateEmailCount();
                    console.log(`[OK] Got ${allEmails.length} emails`);
                    if (allEmails.length === 0) {
                        emailList.innerHTML = '<div class="empty-state"><div class="empty-state-text">OK</div><p>No unread emails</p></div>';
                    } else {
                        renderEmails();
                    }
                } else {
                    const errorMsg = data.error || data.detail || JSON.stringify(data);
                    console.error('[!] Backend error:', errorMsg);
                    emailList.innerHTML = `<div class="empty-state"><div class="empty-state-text">Error</div><p>${errorMsg}</p></div>`;
                    if (emailCount) emailCount.textContent = 'Showing 0 / -- unread';
                }
            } catch (error) {
                console.error('[!] Exception:', error);
                emailList.innerHTML = `<div class="empty-state"><div class="empty-state-text">Error</div><p>Exception: ${error.message}</p></div>`;
                if (emailCount) emailCount.textContent = 'Showing 0 / -- unread';
            }

            unreadButton.disabled = false;
            unreadButton.textContent = 'Unread Mail';
        }

        unreadButton.addEventListener('click', loadUnreadEmails);
        refreshButton.addEventListener('click', loadUnreadEmails);

        document.getElementById('prevButton').addEventListener('click', () => {
            goToPage(currentPage - 1);
        });

        document.getElementById('nextButton').addEventListener('click', () => {
            goToPage(currentPage + 1);
        });

        document.getElementById('prevButtonTop').addEventListener('click', () => {
            goToPage(currentPage - 1);
        });

        document.getElementById('nextButtonTop').addEventListener('click', () => {
            goToPage(currentPage + 1);
        });

        // Close email detail modal
        document.getElementById('closeEmailBtn').addEventListener('click', closeEmailDetail);
        
        // Close modal when clicking outside of it
        // Close modal when clicking on overlay or outside
        const emailDetailModal = document.getElementById('emailDetailModal');
        if (emailDetailModal) {
            emailDetailModal.addEventListener('click', (e) => {
                // Close if clicking on overlay or modal background (not the container)
                if (e.target.id === 'emailDetailModal' || e.target.classList.contains('email-detail-overlay')) {
                    closeEmailDetail();
                }
            });
            
            // Prevent closing when clicking inside the container
            const emailDetailContainer = emailDetailModal.querySelector('.email-detail-container');
            if (emailDetailContainer) {
                emailDetailContainer.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
            }
            
            // Close on ESC key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && emailDetailModal.style.display === 'flex') {
                    closeEmailDetail();
                }
            });
        }

        messageInput.focus();

        // WhatsApp functionality
        const whatsappRefreshButton = document.getElementById('whatsappRefreshButton');
        const whatsappChatsList = document.getElementById('whatsappChatsList');
        const whatsappMessagesContainer = document.getElementById('whatsappMessagesContainer');
        const whatsappCurrentChat = document.getElementById('whatsappCurrentChat');
        const whatsappCount = document.getElementById('whatsappCount');
        const whatsappQRCode = document.getElementById('whatsappQRCode');
        const whatsappHeader = document.getElementById('whatsappHeader');
        
        let allWhatsAppMessages = [];
        let whatsappMessagesByChat = {};
        let currentWhatsAppChatId = null;
        let totalWhatsAppCount = 0;
        let isLoadingWhatsAppMessages = false;
        let connectionPollInterval = null;

        function updateWhatsAppCount() {
            if (!whatsappCount) return;
            if (currentWhatsAppChatId && whatsappMessagesByChat[currentWhatsAppChatId]) {
                whatsappCount.textContent = `${whatsappMessagesByChat[currentWhatsAppChatId].messages.length} messages`;
            } else {
                const total = Object.values(whatsappMessagesByChat).reduce((sum, ch) => sum + ch.messages.length, 0);
                whatsappCount.textContent = `${total} total messages`;
            }
        }

        function groupMessagesByChat(messages) {
            const grouped = {};
            
            messages.forEach(msg => {
                // Determine the chat identifier - prioritize phone number for consistency
                // For sent messages, use the chat_name/chat_id (the recipient)
                // For received messages, use from_number or from_name (the sender)
                let chatId = null;
                let chatDisplayName = null;
                
                if (msg.is_sent) {
                    // Message sent by user - group by recipient (chat_name/chat_id)
                    chatId = msg.chat_id || msg.chat_name || msg.from_number || 'unknown';
                    chatDisplayName = (msg.chat_name && msg.chat_name !== 'Unknown') 
                        ? msg.chat_name 
                        : (msg.from_number && msg.from_number !== 'Unknown' ? msg.from_number : 'Unknown');
                } else {
                    // Message received - group by sender (from_number or from_name)
                    // Use phone number as primary identifier for consistency
                    chatId = msg.from_number || msg.from_name || msg.chat_id || msg.chat_name || 'unknown';
                    
                    // For display name, prefer name over phone number
                    if (msg.from_name && msg.from_name !== 'Unknown' && msg.from_name !== 'You') {
                        chatDisplayName = msg.from_name;
                    } else if (msg.from_number && msg.from_number !== 'Unknown') {
                        chatDisplayName = msg.from_number;
                    } else if (msg.chat_name && msg.chat_name !== 'Unknown') {
                        chatDisplayName = msg.chat_name;
                    } else {
                        chatDisplayName = 'Unknown';
                    }
                }
                
                // Normalize chatId to ensure consistency
                // Remove spaces, normalize phone format, convert to lowercase for comparison
                if (chatId && chatId !== 'unknown' && chatId !== 'Unknown') {
                    let normalizedId = chatId.toString().trim();
                    // Normalize phone numbers (remove spaces, dashes, parentheses)
                    if (normalizedId.includes('+') || /^\d/.test(normalizedId.replace(/[\s\-\(\)]/g, ''))) {
                        normalizedId = normalizedId.replace(/[\s\-\(\)]/g, '');
                    }
                    // Use normalized ID for grouping
                    const lookupKey = normalizedId.toLowerCase();
                    
                    // Check if we already have this chat with a different key
                    let existingChatId = null;
                    for (const key in grouped) {
                        const existingChat = grouped[key];
                        const existingNormalized = key.toString().trim().replace(/[\s\-\(\)]/g, '').toLowerCase();
                        if (existingNormalized === lookupKey || 
                            existingChat.chatName === chatDisplayName ||
                            (existingChat.chatName && chatDisplayName && 
                             existingChat.chatName.replace(/[\s\-\(\)]/g, '').toLowerCase() === 
                             chatDisplayName.replace(/[\s\-\(\)]/g, '').toLowerCase())) {
                            existingChatId = key;
                            break;
                        }
                    }
                    
                    if (existingChatId) {
                        // Merge into existing chat
                        chatId = existingChatId;
                        // Update display name if we have a better one (name over phone)
                        if (chatDisplayName !== 'Unknown' && 
                            (!grouped[chatId].chatName || 
                             (grouped[chatId].chatName && grouped[chatId].chatName.match(/^\+\d/) && !chatDisplayName.match(/^\+\d/)))) {
                            grouped[chatId].chatName = chatDisplayName;
                        }
                    } else {
                        // Create new chat group using normalized ID
                        chatId = lookupKey;
                        if (!grouped[chatId]) {
                            grouped[chatId] = {
                                chatId: chatId,
                                chatName: chatDisplayName,
                                messages: []
                            };
                        }
                    }
                } else {
                    // Handle unknown/empty chatId
                    if (!grouped[chatId]) {
                        grouped[chatId] = {
                            chatId: chatId,
                            chatName: chatDisplayName,
                            messages: []
                        };
                    }
                }
                
                // Add message to the appropriate chat
                grouped[chatId].messages.push(msg);
            });
            
            // Sort messages within each chat by timestamp
            Object.values(grouped).forEach(chat => {
                chat.messages.sort((a, b) => {
                    const timeA = new Date(a.timestamp || 0).getTime();
                    const timeB = new Date(b.timestamp || 0).getTime();
                    return timeA - timeB;
                });
            });
            
            // Log grouping results for debugging
            console.log(`[WhatsApp] Grouped ${messages.length} messages into ${Object.keys(grouped).length} chats`);
            Object.keys(grouped).forEach(chatId => {
                console.log(`  - Chat: ${grouped[chatId].chatName} (${chatId}): ${grouped[chatId].messages.length} messages`);
            });
            
            return grouped;
        }

        function renderWhatsAppChats() {
            if (!whatsappChatsList) return;
            
            const chats = Object.values(whatsappMessagesByChat);
            console.log(`[WhatsApp] Rendering ${chats.length} chats in sidebar`);
            
            if (chats.length === 0) {
                whatsappChatsList.innerHTML = '<div class="whatsapp-sidebar-empty">No chats found</div>';
                return;
            }
            
            chats.sort((a, b) => {
                const aLastMsg = a.messages && a.messages.length > 0 ? a.messages[a.messages.length - 1] : null;
                const bLastMsg = b.messages && b.messages.length > 0 ? b.messages[b.messages.length - 1] : null;
                
                if (!aLastMsg && !bLastMsg) return 0;
                if (!aLastMsg) return 1;
                if (!bLastMsg) return -1;
                
                const aTime = new Date(aLastMsg.timestamp || 0).getTime();
                const bTime = new Date(bLastMsg.timestamp || 0).getTime();
                return bTime - aTime;
            });
            
            const fragment = document.createDocumentFragment();
            const tempDiv = document.createElement('div');
            
            chats.forEach(chat => {
                // Get the last message for preview
                const sortedMessages = [...chat.messages].sort((a, b) => {
                    const timeA = new Date(a.timestamp || 0).getTime();
                    const timeB = new Date(b.timestamp || 0).getTime();
                    return timeB - timeA; // Most recent first
                });
                const lastMessage = sortedMessages[0];
                const preview = lastMessage ? (lastMessage.body || '[Media]').substring(0, 30) : 'No messages';
                const time = lastMessage ? formatWhatsAppTime(lastMessage.timestamp) : '';
                
                // Display contact name or phone number
                const displayName = chat.chatName || 'Unknown';
                const messageCount = chat.messages.length;
                
                tempDiv.innerHTML = `
                    <div class="whatsapp-chat-item ${currentWhatsAppChatId === chat.chatId ? 'active' : ''}" data-chat-id="${chat.chatId}">
                        <div class="whatsapp-chat-avatar">
                            ${displayName.charAt(0).toUpperCase()}
                        </div>
                        <div class="whatsapp-chat-info">
                            <div class="whatsapp-chat-name">${displayName}</div>
                            <div class="whatsapp-chat-preview">${preview}${preview.length >= 30 ? '...' : ''}</div>
                        </div>
                        <div class="whatsapp-chat-meta">
                            <span class="whatsapp-chat-time">${time}</span>
                            ${messageCount > 0 ? `<span class="whatsapp-chat-count">${messageCount}</span>` : ''}
                        </div>
                    </div>
                `;
                fragment.appendChild(tempDiv.firstElementChild.cloneNode(true));
            });

            whatsappChatsList.textContent = '';
            whatsappChatsList.appendChild(fragment);

            document.querySelectorAll('.whatsapp-chat-item').forEach(item => {
                item.addEventListener('click', () => {
                    const chatId = item.dataset.chatId;
                    selectWhatsAppChat(chatId);
                });
            });
        }

        function selectWhatsAppChat(chatId) {
            currentWhatsAppChatId = chatId;
            const chat = whatsappMessagesByChat[chatId];
            if (!chat) return;

            whatsappCurrentChat.textContent = chat.chatName;
            updateWhatsAppCount();
            renderWhatsAppMessages(chat.messages);

            whatsappHeader.style.display = 'flex';
            whatsappMessagesContainer.style.display = 'block';

            document.querySelectorAll('.whatsapp-chat-item').forEach(item => {
                item.classList.toggle('active', item.dataset.chatId === chatId);
            });
        }

        function formatWhatsAppTime(timestamp) {
            if (!timestamp) return '';
            try {
                const date = new Date(timestamp);
                const now = new Date();
                const diff = now - date;
                const days = Math.floor(diff / (1000 * 60 * 60 * 24));
                
                if (days === 0) {
                    return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
                } else if (days === 1) {
                    return 'Yesterday';
                } else if (days < 7) {
                    return date.toLocaleDateString('en-US', { weekday: 'short' });
                } else {
                    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                }
            } catch {
                return timestamp;
            }
        }

        function renderWhatsAppMessages(messages) {
            if (!whatsappMessagesContainer || !messages || messages.length === 0) {
                if (whatsappMessagesContainer) {
                    whatsappMessagesContainer.innerHTML = '<div class="whatsapp-empty-state"><p>No messages in this chat</p></div>';
                }
                return;
            }

            const fragment = document.createDocumentFragment();
            const tempDiv = document.createElement('div');
            
            let lastDate = null;
            messages.forEach((msg) => {
                const msgDate = new Date(msg.timestamp || Date.now());
                const currentDate = msgDate.toDateString();
                const showDateDivider = lastDate !== currentDate;
                lastDate = currentDate;

                const timeStr = formatWhatsAppTime(msg.timestamp);
                
                // Check if message is sent by user - prioritize is_sent field, then check from_name
                // The backend should set is_sent correctly, but we have fallbacks
                let isSent = false;
                
                if (msg.is_sent === true) {
                    isSent = true;
                } else if (msg.from_name === 'You' || msg.from_name === 'Me') {
                    isSent = true;
                } else if (msg.from_name && msg.from_name.toLowerCase().trim() === 'you') {
                    isSent = true;
                }
                
                // Debug: Log detection for first few messages
                if (messages.indexOf(msg) < 5) {
                    console.log(`[WhatsApp Render] Message ${messages.indexOf(msg)}: from_name="${msg.from_name}", is_sent=${msg.is_sent}, final_isSent=${isSent}, body="${(msg.body || '').substring(0, 30)}"`);
                }
                
                const formattedBody = formatWhatsAppMessage(msg.body || '');

                if (showDateDivider) {
                    // Format date like WhatsApp: "Yesterday", "Wednesday", or "11/29/2025"
                    const now = new Date();
                    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    const msgDateOnly = new Date(msgDate.getFullYear(), msgDate.getMonth(), msgDate.getDate());
                    const diffDays = Math.floor((today - msgDateOnly) / (1000 * 60 * 60 * 24));
                    
                    let dateStr = '';
                    if (diffDays === 0) {
                        dateStr = 'Today';
                    } else if (diffDays === 1) {
                        dateStr = 'Yesterday';
                    } else if (diffDays < 7) {
                        dateStr = msgDate.toLocaleDateString('en-US', { weekday: 'long' });
                    } else {
                        dateStr = msgDate.toLocaleDateString('en-US', { month: 'numeric', day: 'numeric', year: 'numeric' });
                    }
                    
                    tempDiv.innerHTML = `<div class="whatsapp-date-divider"><span>${dateStr}</span></div>`;
                    fragment.appendChild(tempDiv.firstElementChild.cloneNode(true));
                }

                // Ensure classes are correctly applied
                const wrapperClass = isSent ? 'whatsapp-message-wrapper sent' : 'whatsapp-message-wrapper received';
                
                // Use phone number if name is Unknown
                const displayName = (!isSent && msg.from_name && msg.from_name !== 'Unknown') 
                    ? msg.from_name 
                    : (msg.from_number && msg.from_number !== 'Unknown' ? msg.from_number : 'Unknown');
                
                // Format time for bubble (e.g., "8:15 AM")
                const bubbleTime = msgDate.toLocaleTimeString('en-US', { 
                    hour: 'numeric', 
                    minute: '2-digit', 
                    hour12: true 
                });
                
                // Read receipt for sent messages (double blue checkmark)
                const readReceipt = isSent ? '<span class="whatsapp-sent-indicator">‚úì‚úì</span>' : '';
                
                tempDiv.innerHTML = `
                    <div class="${wrapperClass}" data-is-sent="${isSent}" data-from-name="${displayName}" data-chat-name="${msg.chat_name || 'Unknown'}">
                        <div class="whatsapp-message-bubble">
                            <div class="whatsapp-message-text">${formattedBody || '<em>No content</em>'}</div>
                            <div class="whatsapp-message-time">
                                ${bubbleTime}
                                ${readReceipt}
                            </div>
                        </div>
                    </div>
                `;
                fragment.appendChild(tempDiv.firstElementChild.cloneNode(true));
            });

            whatsappMessagesContainer.textContent = '';
            whatsappMessagesContainer.appendChild(fragment);
            
            requestAnimationFrame(() => {
                whatsappMessagesContainer.scrollTo({
                    top: whatsappMessagesContainer.scrollHeight,
                    behavior: 'smooth'
                });
            });
        }

        function formatWhatsAppMessage(text) {
            if (!text) return '';
            return text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\n/g, '<br>');
        }

        async function checkWhatsAppConnection() {
            try {
                const response = await fetch('http://localhost:8000/api/whatsapp/status');
                const data = await response.json();
                return data.connected || false;
            } catch (error) {
                console.error('Error checking connection:', error);
                return false;
            }
        }

        async function loadQRCode() {
            try {
                console.log('[WhatsApp] Requesting QR code...');
                
                // Show loading state
                if (whatsappQRCode) {
                    whatsappQRCode.style.display = 'flex';
                    const statusDiv = document.getElementById('connectionStatus');
                    if (statusDiv) {
                        statusDiv.innerHTML = '<span style="color: #94a3b8;">‚è≥ Loading QR code... Please wait...</span>';
                    }
                }
                
                const response = await fetch('http://localhost:8000/api/whatsapp/qr-code');
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('[WhatsApp] HTTP error:', response.status, errorText);
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('[WhatsApp] QR code response:', { 
                    success: data.success,
                    connected: data.connected, 
                    has_qr: !!data.qr_code, 
                    qr_length: data.qr_code ? data.qr_code.length : 0,
                    message: data.message 
                });
                
                if (data.connected) {
                    if (whatsappQRCode) whatsappQRCode.style.display = 'none';
                    if (whatsappMessagesContainer) {
                        whatsappMessagesContainer.innerHTML = '<div class="whatsapp-empty-state"><p>Connected! Click "Refresh" to load messages.</p></div>';
                        whatsappMessagesContainer.style.display = 'block';
                    }
                    return true;
                } else {
                    if (whatsappQRCode) {
                        whatsappQRCode.style.display = 'flex';
                        if (whatsappHeader) whatsappHeader.style.display = 'none';
                        if (whatsappMessagesContainer) whatsappMessagesContainer.style.display = 'none';
                        
                        if (data.qr_code) {
                            console.log('[WhatsApp] QR code received, length:', data.qr_code.length);
                            const qrImage = document.createElement('img');
                            
                            // Create data URL
                            const dataUrl = `data:image/png;base64,${data.qr_code}`;
                            console.log('[WhatsApp] Data URL created, length:', dataUrl.length);
                            
                            qrImage.src = dataUrl;
                            // Make QR code much larger and centered
                            qrImage.style.width = '600px';
                            qrImage.style.height = '600px';
                            qrImage.style.maxWidth = '90vw';
                            qrImage.style.maxHeight = '90vh';
                            qrImage.style.objectFit = 'contain';
                            qrImage.style.margin = '20px auto';
                            qrImage.style.display = 'block';
                            qrImage.style.border = '4px solid rgba(37, 211, 102, 0.8)';
                            qrImage.style.borderRadius = '15px';
                            qrImage.style.padding = '20px';
                            qrImage.style.background = 'white';
                            qrImage.style.boxShadow = '0 8px 24px rgba(0, 0, 0, 0.4)';
                            qrImage.style.imageRendering = 'crisp-edges'; // Better quality
                            qrImage.alt = 'WhatsApp QR Code';
                            
                            // Add error handler for image loading
                            qrImage.onerror = function(e) {
                                console.error('[WhatsApp] Failed to load QR code image:', e);
                                const statusDiv = document.getElementById('connectionStatus');
                                if (statusDiv) {
                                    statusDiv.innerHTML = '<span style="color: #ef4444;">‚ùå Failed to load QR code image. The base64 data may be invalid. Check backend logs.</span>';
                                }
                            };
                            
                            qrImage.onload = function() {
                                console.log('[WhatsApp] QR code image loaded successfully, dimensions:', qrImage.width, 'x', qrImage.height);
                                const statusDiv = document.getElementById('connectionStatus');
                                if (statusDiv) {
                                    statusDiv.innerHTML = '<span style="color: #10b981;">‚úì QR code displayed. Scan with your WhatsApp app.</span>';
                                }
                            };
                            
                            // Remove any existing QR images
                            const existingQr = whatsappQRCode.querySelectorAll('img');
                            existingQr.forEach(img => img.remove());
                            
                            // Insert QR code after the instructions div
                            const instructionsDiv = whatsappQRCode.querySelector('div[style*="background"]');
                            if (instructionsDiv && instructionsDiv.parentNode) {
                                instructionsDiv.parentNode.insertBefore(qrImage, instructionsDiv.nextSibling);
                            } else {
                                // Fallback: append to container
                                whatsappQRCode.appendChild(qrImage);
                            }
                            
                            if (!connectionPollInterval) {
                                startConnectionPolling();
                            }
                        } else {
                            console.warn('[WhatsApp] No QR code in response. Response data:', data);
                            const statusDiv = document.getElementById('connectionStatus');
                            if (statusDiv) {
                                statusDiv.innerHTML = `<span style="color: #ef4444;">‚ùå ${data.message || 'QR code not available. Check backend logs for details.'}</span>`;
                            }
                        }
                        
                        const statusDiv = document.getElementById('connectionStatus');
                        if (statusDiv) {
                            if (data.qr_code) {
                            statusDiv.innerHTML = `<span style="color: #f59e0b;">‚ö†Ô∏è ${data.message || 'Please scan the QR code above with your WhatsApp mobile app'}</span>`;
                    } else {
                                statusDiv.innerHTML = `<span style="color: #ef4444;">‚ùå ${data.message || 'QR code not available. Please check backend logs or try refreshing.'}</span>`;
                        }
                    }
                    }
                    return !!data.qr_code;
                }
            } catch (error) {
                console.error('[!] Error loading QR code:', error);
                if (whatsappQRCode) {
                    whatsappQRCode.style.display = 'flex';
                    const statusDiv = document.getElementById('connectionStatus');
                    if (statusDiv) {
                        statusDiv.innerHTML = `<span style="color: #ef4444;">‚ùå Error: ${error.message}. Make sure the backend server is running.</span>`;
                    }
                }
                if (whatsappMessagesContainer) {
                    whatsappMessagesContainer.style.display = 'none';
                }
                return false;
            }
        }

        let qrRefreshInterval = null;

        function startConnectionPolling() {
            if (connectionPollInterval) {
                clearInterval(connectionPollInterval);
            }
            
            const statusDiv = document.getElementById('connectionStatus');
            let qrRefreshCount = 0;
            
            // Refresh QR code every 20 seconds (QR codes expire)
            if (qrRefreshInterval) {
                clearInterval(qrRefreshInterval);
            }
            qrRefreshInterval = setInterval(() => {
                qrRefreshCount++;
                console.log(`[WhatsApp] Refreshing QR code (attempt ${qrRefreshCount})...`);
                loadQRCode();
            }, 20000); // Refresh every 20 seconds
            
            connectionPollInterval = setInterval(async () => {
                const isConnected = await checkWhatsAppConnection();
                if (isConnected) {
                    if (statusDiv) statusDiv.innerHTML = '<span style="color: #10b981;">‚úì Connected! Loading messages...</span>';
                    clearInterval(connectionPollInterval);
                    connectionPollInterval = null;
                    if (qrRefreshInterval) {
                        clearInterval(qrRefreshInterval);
                        qrRefreshInterval = null;
                    }
                    if (whatsappQRCode) whatsappQRCode.style.display = 'none';
                    if (whatsappMessagesContainer) {
                        whatsappMessagesContainer.innerHTML = '<div class="whatsapp-empty-state"><p>Connected! Loading messages...</p></div>';
                        whatsappMessagesContainer.style.display = 'block';
                    }
                    // Auto-load messages after connection
                    setTimeout(() => {
                        loadWhatsAppMessages();
                    }, 1000);
                } else {
                    if (statusDiv) {
                        const timeLeft = 20 - (qrRefreshCount * 3 % 20);
                        statusDiv.innerHTML = `<span style="color: #f59e0b;">‚è≥ Waiting for QR code scan... (QR refreshes every 20s)</span>`;
                }
                }
            }, 2000); // Check every 2 seconds instead of 3
        }

        async function loadWhatsAppMessages() {
            if (isLoadingWhatsAppMessages) {
                return;
            }
            
            isLoadingWhatsAppMessages = true;
            whatsappRefreshButton.disabled = true;
            whatsappRefreshButton.textContent = 'Loading...';
            // Preserve current messages until new ones are loaded successfully

            try {
                const isConnected = await checkWhatsAppConnection();
                
                if (!isConnected) {
                    const qrLoaded = await loadQRCode();
                    if (!qrLoaded) {
                        if (whatsappMessagesContainer) {
                            whatsappMessagesContainer.innerHTML = '<div class="whatsapp-empty-state"><p>Please wait while we prepare the QR code...</p></div>';
                            whatsappMessagesContainer.style.display = 'block';
                        }
                        setTimeout(loadQRCode, 2000);
                    }
                    isLoadingWhatsAppMessages = false;
                    whatsappRefreshButton.disabled = false;
                    whatsappRefreshButton.textContent = 'Refresh';
                    return;
                }

                if (whatsappMessagesContainer) {
                    whatsappMessagesContainer.innerHTML = '<div class="whatsapp-empty-state"><p>Loading WhatsApp messages...</p></div>';
                    whatsappMessagesContainer.style.display = 'block';
                }
                
                const response = await fetch('http://localhost:8000/api/whatsapp/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        limit: 1000  // Increased limit to get more messages
                    })
                });
                    
                    if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.detail || 'Failed to fetch messages');
                    }
                    
                const data = await response.json();

                    if (whatsappQRCode) whatsappQRCode.style.display = 'none';

                    if (data.success) {
                    // Only update messages after successful load
                    allWhatsAppMessages = data.messages || [];
                    totalWhatsAppCount = data.total_count || allWhatsAppMessages.length;
                        
                        whatsappMessagesByChat = groupMessagesByChat(allWhatsAppMessages);
                        
                    if (allWhatsAppMessages.length === 0) {
                            whatsappMessagesContainer.innerHTML = '<div class="whatsapp-empty-state"><p>No WhatsApp messages found</p></div>';
                            whatsappMessagesContainer.style.display = 'block';
                    } else {
                            renderWhatsAppChats();
                            
                            if (Object.keys(whatsappMessagesByChat).length > 0) {
                                    const firstChatId = Object.keys(whatsappMessagesByChat)[0];
                                    selectWhatsAppChat(firstChatId);
                            }
                        }
                        updateWhatsAppCount();
                } else {
                    const errorMsg = data.error || data.detail || 'Unknown error';
                        if (whatsappMessagesContainer) {
                            whatsappMessagesContainer.innerHTML = `<div class="whatsapp-empty-state"><p>${errorMsg}</p></div>`;
                            whatsappMessagesContainer.style.display = 'block';
                        }
                }
            } catch (error) {
                console.error('[!] Error:', error);
                    if (whatsappMessagesContainer) {
                    whatsappMessagesContainer.innerHTML = `<div class="whatsapp-empty-state"><p>Error: ${error.message}</p></div>`;
                        whatsappMessagesContainer.style.display = 'block';
                    }
            } finally {
                isLoadingWhatsAppMessages = false;
                whatsappRefreshButton.disabled = false;
                whatsappRefreshButton.textContent = 'Refresh';
            }
        }

        if (whatsappRefreshButton) {
        whatsappRefreshButton.addEventListener('click', loadWhatsAppMessages);
        }

        // Auto-load QR code when WhatsApp tab is first opened
        const whatsappTabButton = document.querySelector('[data-tab="whatsapp"]');
        if (whatsappTabButton) {
            // Check if WhatsApp tab is active on page load
            const checkInitialTab = () => {
                const whatsappTab = document.getElementById('whatsapp');
                if (whatsappTab && whatsappTab.classList.contains('active')) {
                    console.log('[WhatsApp] Tab is active on load, checking connection...');
                    checkWhatsAppConnection().then(isConnected => {
                        if (!isConnected) {
                            loadQRCode();
                        }
                    });
                }
            };
            
            // Check immediately and also after a short delay
            setTimeout(checkInitialTab, 500);
        }

        // Check connection status on tab switch
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', () => {
                if (button.dataset.tab === 'whatsapp') {
                    // Check if we already have messages loaded
                    const hasMessages = allWhatsAppMessages && allWhatsAppMessages.length > 0;
                    const hasChats = whatsappMessagesByChat && Object.keys(whatsappMessagesByChat).length > 0;
                    
                    if (hasMessages || hasChats) {
                        // Restore previous state - we have messages, so show them
                        console.log('[WhatsApp] Restoring previous state with', allWhatsAppMessages.length, 'messages');
                        
                        // Render chats if not already rendered
                        if (hasChats) {
                            renderWhatsAppChats();
                            
                            // Restore selected chat if there was one
                            if (currentWhatsAppChatId && whatsappMessagesByChat[currentWhatsAppChatId]) {
                                selectWhatsAppChat(currentWhatsAppChatId);
                            } else if (Object.keys(whatsappMessagesByChat).length > 0) {
                                // Select first chat if no previous selection
                                const firstChatId = Object.keys(whatsappMessagesByChat)[0];
                                selectWhatsAppChat(firstChatId);
                            }
                        }
                        
                        // Hide QR code, show messages and header
                        if (whatsappQRCode) whatsappQRCode.style.display = 'none';
                        if (whatsappHeader) whatsappHeader.style.display = 'flex';
                        if (whatsappMessagesContainer) {
                            whatsappMessagesContainer.style.display = 'block';
                            // Make sure the selected chat's messages are visible
                            if (currentWhatsAppChatId && whatsappMessagesByChat[currentWhatsAppChatId]) {
                                renderWhatsAppMessages(whatsappMessagesByChat[currentWhatsAppChatId].messages);
                            }
                        }
                    } else {
                        // No messages loaded yet - check connection
                        if (whatsappQRCode) {
                            whatsappQRCode.style.display = 'flex';
                        }
                        if (whatsappHeader) whatsappHeader.style.display = 'none';
                        if (whatsappMessagesContainer) whatsappMessagesContainer.style.display = 'none';
                        
                        checkWhatsAppConnection().then(isConnected => {
                            if (!isConnected) {
                                console.log('[WhatsApp] Not connected, loading QR code...');
                                loadQRCode();
                            } else {
                                console.log('[WhatsApp] Already connected but no messages loaded');
                                if (whatsappQRCode) whatsappQRCode.style.display = 'none';
                                if (whatsappMessagesContainer) {
                                    whatsappMessagesContainer.innerHTML = '<div class="whatsapp-empty-state"><p>Connected! Click "Refresh" to load messages.</p></div>';
                                    whatsappMessagesContainer.style.display = 'block';
                                }
                            }
                        });
                    }
                }
            });
        });
        
        // Telegram message sending
        let currentTelegramChatId = null;
        const telegramMessageInput = document.getElementById('telegramMessageInput');
        const telegramSendButton = document.getElementById('telegramSendButton');

        // Auto-resize textarea
        if (telegramMessageInput) {
            telegramMessageInput.addEventListener('input', function() {
                this.style.height = 'auto';
                this.style.height = Math.min(this.scrollHeight, 150) + 'px';
                if (telegramSendButton) {
                    telegramSendButton.disabled = !this.value.trim() || !currentTelegramChatId;
                }
            });

            telegramMessageInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    if (telegramSendButton && !telegramSendButton.disabled) {
                        sendTelegramMessage();
                    }
                }
            });
        }

        // Send button click handler
        if (telegramSendButton) {
            telegramSendButton.addEventListener('click', sendTelegramMessage);
        }

        async function sendTelegramMessage() {
            console.log(`[DEBUG] sendTelegramMessage called, currentTelegramChatId: ${currentTelegramChatId}`);
            if (!currentTelegramChatId || !telegramMessageInput) {
                console.error('[DEBUG] Cannot send: missing currentTelegramChatId or telegramMessageInput');
                alert('Please select a chat first');
                return;
            }
            
            const text = telegramMessageInput.value.trim();
            if (!text) {
                console.error('[DEBUG] Cannot send: empty message text');
                return;
            }

            // Disable input while sending
            telegramMessageInput.disabled = true;
            if (telegramSendButton) {
                telegramSendButton.disabled = true;
                telegramSendButton.innerHTML = '<div class="telegram-send-spinner"></div>';
            }

            try {
                console.log(`[*] Sending message to Telegram chat ${currentTelegramChatId}...`);
                const response = await fetch('http://localhost:8000/api/telegram/send', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        chat_id: currentTelegramChatId,
                        text: text
                    })
                });

                console.log('[*] Response status:', response.status);
                const data = await response.json();
                console.log('[*] Response data:', data);

                if (response.ok && data.success) {
                    // Clear input
                    telegramMessageInput.value = '';
                    telegramMessageInput.style.height = 'auto';
                    
                    // Reload messages to show the new one
                    await loadTelegramMessages();
                    
                    // Re-select the current chat
                    if (currentTelegramChatId) {
                        selectTelegramChat(currentTelegramChatId);
                    }
                } else {
                    const errorMsg = data.error || data.detail || JSON.stringify(data);
                    console.error('[!] Backend error:', errorMsg);
                    alert(`Failed to send message: ${errorMsg}`);
                }
            } catch (error) {
                console.error('[!] Exception:', error);
                alert(`Failed to send message: ${error.message}`);
            } finally {
                // Re-enable input
                telegramMessageInput.disabled = false;
                if (telegramSendButton) {
                    telegramSendButton.disabled = !telegramMessageInput.value.trim() || !currentTelegramChatId;
                    telegramSendButton.innerHTML = `
                        <svg width="20" height="20" viewBox="0 0 20 20" viewBox="0 0 20 20" fill="none">
                            <path d="M18 2L9 11M18 2L12 18L9 11M18 2L2 8L9 11" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    `;
                }
            }
        }

        // Telegram functionality
        const telegramShowButton = document.getElementById('telegramShowButton');
        const telegramMessagesContainer = document.getElementById('telegramMessagesContainer');
        const telegramChatsList = document.getElementById('telegramChatsList');
        const telegramCurrentChat = document.getElementById('telegramCurrentChat');
        const telegramCount = document.getElementById('telegramCount');
        let allTelegramMessages = [];
        let messagesByChat = {};
        let currentChatId = null;
        let totalTelegramCount = 0;

        function getTelegramInitials(name) {
            if (!name) return '?';
            const parts = name.trim().split(' ');
            if (parts.length >= 2) {
                return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
            }
            return name.substring(0, 2).toUpperCase();
        }

        function getTelegramAvatarColor(name) {
            if (!name) return '#3390ec';
            let hash = 0;
            for (let i = 0; i < name.length; i++) {
                hash = name.charCodeAt(i) + ((hash << 5) - hash);
            }
            const colors = [
                '#3390ec', '#e17076', '#fdcb6e', '#6c5ce7', '#a29bfe',
                '#fd79a8', '#00b894', '#00cec9', '#55efc4', '#74b9ff'
            ];
            return colors[Math.abs(hash) % colors.length];
        }

        function formatTelegramTimestamp(timestamp) {
            if (!timestamp) return '';
            try {
                const date = new Date(timestamp);
                const now = new Date();
                const diffMs = now - date;
                const diffMins = Math.floor(diffMs / 60000);
                const diffHours = Math.floor(diffMs / 3600000);
                const diffDays = Math.floor(diffMs / 86400000);

                if (diffMins < 1) return 'now';
                if (diffMins < 60) return `${diffMins}m`;
                if (diffHours < 24) return `${diffHours}h`;
                if (diffDays < 7) return `${diffDays}d`;
                
                const month = date.toLocaleString('default', { month: 'short' });
                const day = date.getDate();
                return `${month} ${day}`;
            } catch (e) {
                return timestamp;
            }
        }

        function formatTelegramTime(timestamp) {
            if (!timestamp) return '';
            try {
                const date = new Date(timestamp);
                return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: false });
            } catch (e) {
                return timestamp;
            }
        }

        function formatTelegramMessage(text) {
            if (!text) return '';
            let formatted = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\n/g, '<br>')
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.+?)\*/g, '<em>$1</em>')
                .replace(/`(.+?)`/g, '<code>$1</code>');
            return formatted;
        }

        function groupMessagesByChat(messages) {
            const grouped = {};
            messages.forEach(msg => {
                const chatId = msg.chat_id || 'unknown';
                if (!grouped[chatId]) {
                    grouped[chatId] = {
                        chatId: chatId,
                        chatName: msg.chat_name || 'Unknown',
                        messages: []
                    };
                }
                grouped[chatId].messages.push(msg);
            });
            
            // Sort messages within each chat by timestamp
            Object.keys(grouped).forEach(chatId => {
                grouped[chatId].messages.sort((a, b) => {
                    const timeA = new Date(a.timestamp || 0).getTime();
                    const timeB = new Date(b.timestamp || 0).getTime();
                    return timeA - timeB; // Oldest first
                });
            });
            
            return grouped;
        }

        function renderTelegramChats() {
            const chats = Object.values(messagesByChat);
            chats.sort((a, b) => {
                const lastMsgA = a.messages[a.messages.length - 1];
                const lastMsgB = b.messages[b.messages.length - 1];
                const timeA = new Date(lastMsgA?.timestamp || 0).getTime();
                const timeB = new Date(lastMsgB?.timestamp || 0).getTime();
                return timeB - timeA; // Most recent first
            });

            if (chats.length === 0) {
                telegramChatsList.innerHTML = '<div class="telegram-sidebar-empty">No chats found</div>';
                return;
            }

            const chatsHTML = chats.map(chat => {
                const lastMsg = chat.messages[chat.messages.length - 1];
                const preview = lastMsg?.body ? (lastMsg.body.length > 30 ? lastMsg.body.substring(0, 30) + '...' : lastMsg.body) : 'No messages';
                const time = formatTelegramTimestamp(lastMsg?.timestamp);
                const isActive = currentChatId === chat.chatId;
                const initials = getTelegramInitials(chat.chatName);
                const avatarColor = getTelegramAvatarColor(chat.chatName);
                
                return `
                    <div class="telegram-chat-item ${isActive ? 'active' : ''}" data-chat-id="${chat.chatId}">
                        <div class="telegram-chat-avatar" style="background-color: ${avatarColor}">
                            ${initials}
                </div>
                        <div class="telegram-chat-info">
                            <div class="telegram-chat-name">${chat.chatName}</div>
                            <div class="telegram-chat-preview">${preview}</div>
                        </div>
                        <div class="telegram-chat-meta">
                            <span class="telegram-chat-time">${time}</span>
                            ${chat.messages.filter(m => !m.is_read && !m.is_sent).length > 0 ? 
                                `<span class="telegram-chat-unread">${chat.messages.filter(m => !m.is_read && !m.is_sent).length}</span>` : ''}
                        </div>
                    </div>
                `;
            }).join('');

            telegramChatsList.innerHTML = chatsHTML;

            // Add click handlers
            document.querySelectorAll('.telegram-chat-item').forEach(item => {
                item.addEventListener('click', () => {
                    const chatId = item.dataset.chatId;
                    selectTelegramChat(chatId);
                });
            });
        }

        function selectTelegramChat(chatId) {
            currentChatId = chatId;
            currentTelegramChatId = chatId;  // Update for send function
            const chat = messagesByChat[chatId];
            if (!chat) return;

            telegramCurrentChat.textContent = chat.chatName;
            telegramCount.textContent = `${chat.messages.length} messages`;

            // Render messages for this chat
            renderTelegramMessages(chat.messages);

            // Show input area
            const telegramInputContainer = document.getElementById('telegramInputContainer');
            if (telegramInputContainer) {
                telegramInputContainer.style.display = 'block';
            }

            // Update active state
            document.querySelectorAll('.telegram-chat-item').forEach(item => {
                item.classList.toggle('active', item.dataset.chatId === chatId);
            });

            // Focus input and update send button state
            const messageInput = document.getElementById('telegramMessageInput');
            if (messageInput) {
                messageInput.focus();
                // Update send button state
                if (telegramSendButton) {
                    telegramSendButton.disabled = !messageInput.value.trim() || !currentTelegramChatId;
                    console.log(`[DEBUG] Chat selected: ${chatId}, currentTelegramChatId: ${currentTelegramChatId}, send button disabled: ${telegramSendButton.disabled}`);
                }
            }
        }

        function renderTelegramMessages(messages) {
            if (!messages || messages.length === 0) {
                telegramMessagesContainer.innerHTML = '<div class="telegram-empty-state"><p>No messages in this chat</p></div>';
                return;
            }

            let lastDate = null;
            const messagesHTML = messages.map((msg, index) => {
                const msgDate = new Date(msg.timestamp || Date.now());
                const currentDate = msgDate.toDateString();
                const showDateDivider = lastDate !== currentDate;
                lastDate = currentDate;

                const timeStr = formatTelegramTime(msg.timestamp);
                const formattedBody = formatTelegramMessage(msg.body || '');
                const isSent = msg.is_sent || false;

                let html = '';
                
                // Date divider
                if (showDateDivider) {
                    const dateStr = msgDate.toLocaleDateString('en-US', { 
                        weekday: 'long', 
                        year: 'numeric', 
                        month: 'long', 
                        day: 'numeric' 
                    });
                    html += `<div class="telegram-date-divider"><span>${dateStr}</span></div>`;
                }

                // Message bubble
                html += `
                    <div class="telegram-message-wrapper ${isSent ? 'sent' : 'received'}">
                        <div class="telegram-message-bubble">
                            <div class="telegram-message-text">${formattedBody || '<em>No content</em>'}</div>
                            <div class="telegram-message-time">${timeStr}</div>
                        </div>
                    </div>
                `;

                return html;
            }).join('');

            telegramMessagesContainer.innerHTML = messagesHTML;
            telegramMessagesContainer.scrollTop = telegramMessagesContainer.scrollHeight;
        }

        function updateTelegramCount() {
            if (!telegramCount) return;
            const total = Object.values(messagesByChat).reduce((sum, ch) => sum + ch.messages.length, 0);
            telegramCount.textContent = `${total} total messages`;
        }

        async function loadTelegramMessages() {
            telegramShowButton.disabled = true;
            telegramShowButton.textContent = 'Loading...';
            allTelegramMessages = [];
            messagesByChat = {};
            currentChatId = null;
            totalTelegramCount = 0;

            try {
                console.log('[*] Requesting Telegram messages from backend...');
                const response = await fetch('http://localhost:8000/api/telegram/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        limit: 50  // Reduced from 200 to 50 for faster loading
                    })
                });

                console.log('[*] Response status:', response.status);
                
                // Handle non-OK responses (like 500 errors)
                if (!response.ok) {
                    let errorData;
                    try {
                        errorData = await response.json();
                    } catch (e) {
                        // If response is not JSON, create error object
                        const errorText = await response.text();
                        errorData = { detail: errorText || `HTTP ${response.status}: ${response.statusText}` };
                    }
                    const errorMsg = errorData.detail || errorData.error || errorData.message || JSON.stringify(errorData);
                    console.error('[!] Backend error (HTTP ' + response.status + '):', errorMsg);
                    throw new Error(errorMsg);
                }
                
                const data = await response.json();
                console.log('[*] Response data:', data);

                if (data.success) {
                    allTelegramMessages = data.messages || [];
                    totalTelegramCount = typeof data.total_count === 'number' ? data.total_count : allTelegramMessages.length;
                    
                    // Group messages by chat
                    messagesByChat = groupMessagesByChat(allTelegramMessages);
                    
                    // Render chats sidebar
                    renderTelegramChats();
                    
                    // Auto-select first chat if available
                    const chats = Object.keys(messagesByChat);
                    if (chats.length > 0) {
                        selectTelegramChat(chats[0]);
                    } else {
                        telegramMessagesContainer.innerHTML = '<div class="telegram-empty-state"><p>No messages found</p></div>';
                    }
                    
                    updateTelegramCount();
                    console.log(`[OK] Got ${allTelegramMessages.length} Telegram messages in ${chats.length} chats`);
                } else {
                    const errorMsg = data.error || data.detail || JSON.stringify(data);
                    console.error('[!] Backend error:', errorMsg);
                    
                    // Check if it's an authentication error
                    if (errorMsg.includes('not authorized') || errorMsg.includes('authenticate') || errorMsg.includes('AUTH_KEY_UNREGISTERED') || errorMsg.includes('invalid or expired') || errorMsg.includes('too many times') || errorMsg.includes('rate limit')) {
                        const isInvalidSession = errorMsg.includes('AUTH_KEY_UNREGISTERED') || errorMsg.includes('invalid or expired');
                        const needsVerificationCode = errorMsg.includes('Verification code') || errorMsg.includes('verification code required');
                        const isRateLimited = errorMsg.includes('too many times') || errorMsg.includes('rate limit') || errorMsg.includes('tried logging in too many');
                        
                        // Format error message - replace newlines with <br> for HTML display
                        const formattedErrorMsg = errorMsg.replace(/\n/g, '<br>');
                        
                        telegramMessagesContainer.innerHTML = `
                            <div class="telegram-empty-state">
                                <div class="telegram-empty-icon">üîê</div>
                                <h3>${isRateLimited ? 'Rate Limited - Please Wait' : isInvalidSession ? 'Invalid Session File' : needsVerificationCode ? 'Verification Code Required' : 'Authentication Required'}</h3>
                                <div style="margin-top: 12px; padding: 16px; background: rgba(0,0,0,0.05); border-radius: 8px; max-width: 600px; text-align: left; margin-left: auto; margin-right: auto;">
                                    <p style="font-size: 13px; color: #2b2b2b; line-height: 1.8; white-space: pre-line; margin: 0; font-family: 'Segoe UI', sans-serif;">${formattedErrorMsg}</p>
                                </div>
                                <p style="margin-top: 20px; font-size: 13px; color: #707579; max-width: 500px; line-height: 1.6;">
                                    ${needsVerificationCode ? 
                                        'This app doesn\'t have a verification code input. ' : 
                                        isInvalidSession ? 
                                            'Your Telegram session file is invalid or expired. ' : 
                                            'Your Telegram client is not authenticated. '
                                    }
                                    ${needsVerificationCode ? 
                                        'Please run the authentication script in your terminal:' : 
                                        'Please follow these steps:'
                                    }
                                </p>
                                ${isRateLimited ? `
                                    <div style="margin-top: 20px; text-align: left; max-width: 500px; background: rgba(255, 193, 7, 0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #ffc107;">
                                        <div style="color: #707579; font-size: 13px; line-height: 1.8;">
                                            <p style="margin-bottom: 12px; font-weight: 600; color: #856404;">‚ö†Ô∏è Rate Limit Active</p>
                                            <p>Telegram has temporarily blocked authentication attempts. This usually happens when:</p>
                                            <ul style="margin: 8px 0; padding-left: 20px;">
                                                <li>Too many verification code requests were made</li>
                                                <li>Multiple failed authentication attempts occurred</li>
                                            </ul>
                                            <p style="margin-top: 12px; font-weight: 600;">What to do:</p>
                                            <ol style="margin: 8px 0; padding-left: 20px;">
                                                <li><strong>Wait 24 hours</strong> for the rate limit to reset</li>
                                                <li>Then try authenticating again: <code style="background: rgba(0,0,0,0.1); padding: 2px 6px; border-radius: 4px;">python authenticate_telegram.py</code></li>
                                                <li>Make sure to enter the verification code correctly on the first try</li>
                                            </ol>
                                        </div>
                                    </div>
                                ` : needsVerificationCode ? `
                                    <div style="margin-top: 20px; text-align: left; max-width: 500px; background: rgba(0,0,0,0.05); padding: 16px; border-radius: 8px;">
                                        <div style="color: #707579; font-size: 13px; line-height: 1.8;">
                                            <p style="margin-bottom: 12px; font-weight: 600; color: #2b2b2b;">Run this command in your terminal:</p>
                                            <code style="display: block; background: rgba(0,0,0,0.1); padding: 12px; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 13px; color: #2b2b2b; margin-bottom: 12px;">
                                                python authenticate_telegram.py
                                            </code>
                                            <p style="margin-top: 12px;">This will open a window where you can enter your verification code from the Telegram app.</p>
                                        </div>
                                    </div>
                                ` : `
                                    <div style="margin-top: 20px; text-align: left; max-width: 500px; background: rgba(0,0,0,0.05); padding: 16px; border-radius: 8px;">
                                        <ol style="color: #707579; font-size: 13px; line-height: 1.8; margin-left: 20px;">
                                            <li>Stop your backend server (Ctrl+C)</li>
                                            <li>Run: <code style="background: rgba(0,0,0,0.1); padding: 2px 6px; border-radius: 4px;">python authenticate_telegram.py</code></li>
                                            <li>Follow the prompts to enter your phone number and verification code</li>
                                            <li>Restart your backend server</li>
                                            <li>Click "Refresh" again</li>
                                        </ol>
                                    </div>
                                    <button id="deleteTelegramSessionBtn" class="telegram-delete-session-btn" style="margin-top: 20px; padding: 10px 20px; background: #e17076; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
                                        Delete Session File (requires server restart)
                                    </button>
                                `}
                            </div>
                        `;
                        
                        // Add click handler for delete session button
                        const deleteBtn = document.getElementById('deleteTelegramSessionBtn');
                        if (deleteBtn) {
                            deleteBtn.addEventListener('click', async () => {
                                if (confirm('This will delete your Telegram session file. You will need to restart the server and authenticate again. Continue?')) {
                                    try {
                                        const response = await fetch('http://localhost:8000/api/telegram/delete-session', {
                                            method: 'POST'
                                        });
                                        const data = await response.json();
                                        if (response.ok && data.success) {
                                            alert(data.message || 'Session file deleted. Please restart your backend server and click Refresh to authenticate.');
                                        } else {
                                            alert('Failed to delete session file: ' + (data.detail || data.message || 'Unknown error'));
                                        }
                                    } catch (error) {
                                        alert('Error deleting session file: ' + error.message);
                                    }
                                }
                            });
                        }
                    } else {
                        telegramMessagesContainer.innerHTML = `<div class="telegram-empty-state"><div class="telegram-empty-icon">‚ö†Ô∏è</div><h3>Error</h3><p>${errorMsg}</p></div>`;
                    }
                    telegramChatsList.innerHTML = '<div class="telegram-sidebar-empty">Error loading chats</div>';
                    if (telegramCount) telegramCount.textContent = 'Error';
        }
            } catch (error) {
                console.error('[!] Exception:', error);
                const errorMsg = error.message || 'Unknown error';
                
                // Check if it's an authentication error
                if (errorMsg.includes('not authorized') || errorMsg.includes('authenticate') || errorMsg.includes('AUTH_KEY_UNREGISTERED') || errorMsg.includes('invalid or expired')) {
                    const isInvalidSession = errorMsg.includes('AUTH_KEY_UNREGISTERED') || errorMsg.includes('invalid or expired');
                    const needsVerificationCode = errorMsg.includes('Verification code') || errorMsg.includes('verification code required');
                    
                    telegramMessagesContainer.innerHTML = `
                        <div class="telegram-empty-state">
                            <div class="telegram-empty-icon">üîê</div>
                            <h3>${isInvalidSession ? 'Invalid Session File' : needsVerificationCode ? 'Verification Code Required' : 'Authentication Required'}</h3>
                            <p>Exception: ${errorMsg}</p>
                                <p style="margin-top: 16px; font-size: 13px; color: #707579; max-width: 500px; line-height: 1.6;">
                                    ${isRateLimited ? 
                                        'Telegram has temporarily blocked authentication attempts due to too many login attempts. ' : 
                                        needsVerificationCode ? 
                                            'This app doesn\'t have a verification code input. ' : 
                                            isInvalidSession ? 
                                                'Your Telegram session file is invalid or expired. ' : 
                                                'Your Telegram client is not authenticated. '
                                    }
                                    ${isRateLimited ? 
                                        'Please wait 24 hours before trying to authenticate again. ' : 
                                        needsVerificationCode ? 
                                            'Please run the authentication script in your terminal:' : 
                                            'Please follow these steps:'
                                    }
                                </p>
                            ${needsVerificationCode ? `
                                <div style="margin-top: 20px; text-align: left; max-width: 500px; background: rgba(0,0,0,0.05); padding: 16px; border-radius: 8px;">
                                    <div style="color: #707579; font-size: 13px; line-height: 1.8;">
                                        <p style="margin-bottom: 12px; font-weight: 600; color: #2b2b2b;">Run this command in your terminal:</p>
                                        <code style="display: block; background: rgba(0,0,0,0.1); padding: 12px; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 13px; color: #2b2b2b; margin-bottom: 12px;">
                                            python authenticate_telegram.py
                                        </code>
                                        <p style="margin-top: 12px;">This will open a window where you can enter your verification code from the Telegram app.</p>
                                    </div>
                                </div>
                            ` : `
                                <div style="margin-top: 20px; text-align: left; max-width: 500px; background: rgba(0,0,0,0.05); padding: 16px; border-radius: 8px;">
                                    <ol style="color: #707579; font-size: 13px; line-height: 1.8; margin-left: 20px;">
                                        <li>Stop your backend server (Ctrl+C)</li>
                                        <li>Run: <code style="background: rgba(0,0,0,0.1); padding: 2px 6px; border-radius: 4px;">python authenticate_telegram.py</code></li>
                                        <li>Follow the prompts to enter your phone number and verification code</li>
                                        <li>Restart your backend server</li>
                                        <li>Click "Refresh" again</li>
                                    </ol>
                                </div>
                                <button id="deleteTelegramSessionBtn2" class="telegram-delete-session-btn" style="margin-top: 20px; padding: 10px 20px; background: #e17076; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
                                    Delete Session File (requires server restart)
                                </button>
                            `}
                        </div>
                    `;
                    
                    // Add click handler for delete session button
                    const deleteBtn = document.getElementById('deleteTelegramSessionBtn2');
                    if (deleteBtn) {
                        deleteBtn.addEventListener('click', async () => {
                            if (confirm('This will delete your Telegram session file. You will need to restart the server and authenticate again. Continue?')) {
                                try {
                                    const response = await fetch('http://localhost:8000/api/telegram/delete-session', {
                                        method: 'POST'
                                    });
                                    const data = await response.json();
                                    if (response.ok && data.success) {
                                        alert('Session file deleted. Please restart your backend server and click Refresh to authenticate.');
                                    } else {
                                        alert('Failed to delete session file: ' + (data.detail || data.message || 'Unknown error'));
                                    }
                                } catch (error) {
                                    alert('Error deleting session file: ' + error.message);
                                }
                            }
                        });
                    }
                } else {
                    telegramMessagesContainer.innerHTML = `<div class="telegram-empty-state"><div class="telegram-empty-icon">‚ö†Ô∏è</div><h3>Error</h3><p>Exception: ${errorMsg}</p></div>`;
                }
                telegramChatsList.innerHTML = '<div class="telegram-sidebar-empty">Error loading chats</div>';
                if (telegramCount) telegramCount.textContent = 'Error';
            }

            telegramShowButton.disabled = false;
            telegramShowButton.textContent = 'Refresh';
        }

        telegramShowButton.addEventListener('click', loadTelegramMessages);

        // Slack functionality
        const slackViewButton = document.getElementById('slackViewButton');
        const slackMessagesContainer = document.getElementById('slackMessagesContainer');
        const slackChannelsList = document.getElementById('slackChannelsList');
        const slackCurrentChannel = document.getElementById('slackCurrentChannel');
        const slackCount = document.getElementById('slackCount');
        let allSlackMessages = [];
        let messagesByChannel = {};
        let currentChannelId = null;
        let totalSlackCount = 0;

        function getInitials(name) {
            if (!name) return '?';
            const parts = name.trim().split(' ');
            if (parts.length >= 2) {
                return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
            }
            return name.substring(0, 2).toUpperCase();
        }

        function getAvatarColor(name) {
            if (!name) return '#4a154b';
            let hash = 0;
            for (let i = 0; i < name.length; i++) {
                hash = name.charCodeAt(i) + ((hash << 5) - hash);
            }
            const colors = [
                '#4a154b', '#350d36', '#1264a3', '#0f5132', '#856404',
                '#721c24', '#155724', '#004085', '#383f45', '#1d1c1d'
            ];
            return colors[Math.abs(hash) % colors.length];
        }

        function formatSlackTimestamp(timestamp) {
            if (!timestamp) return '';
            try {
                const date = new Date(timestamp);
                const now = new Date();
                const diffMs = now - date;
                const diffMins = Math.floor(diffMs / 60000);
                const diffHours = Math.floor(diffMs / 3600000);
                const diffDays = Math.floor(diffMs / 86400000);

                if (diffMins < 1) return 'now';
                if (diffMins < 60) return `${diffMins}m ago`;
                if (diffHours < 24) return `${diffHours}h ago`;
                if (diffDays < 7) return `${diffDays}d ago`;
                
                // Format as date
                const month = date.toLocaleString('default', { month: 'short' });
                const day = date.getDate();
                const year = date.getFullYear();
                const isThisYear = year === now.getFullYear();
                return isThisYear ? `${month} ${day}` : `${month} ${day}, ${year}`;
            } catch (e) {
                return timestamp;
            }
        }

        function formatSlackTime(timestamp) {
            if (!timestamp) return '';
            try {
                const date = new Date(timestamp);
                return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
            } catch (e) {
                return timestamp;
            }
        }

        function formatSlackMessage(text) {
            if (!text) return '';
            // Convert Slack markdown-like formatting
            let formatted = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\n/g, '<br>')
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.+?)\*/g, '<em>$1</em>')
                .replace(/`(.+?)`/g, '<code>$1</code>');
            return formatted;
        }

        function groupMessagesByChannel(messages) {
            const grouped = {};
            messages.forEach(msg => {
                const channelId = msg.channel_id || 'unknown';
                if (!grouped[channelId]) {
                    grouped[channelId] = {
                        channelId: channelId,
                        channelName: msg.channel_name || 'Unknown',
                        messages: []
                    };
                }
                grouped[channelId].messages.push(msg);
            });
            
            // Sort messages within each channel by timestamp
            Object.keys(grouped).forEach(channelId => {
                grouped[channelId].messages.sort((a, b) => {
                    const timeA = new Date(a.timestamp || 0).getTime();
                    const timeB = new Date(b.timestamp || 0).getTime();
                    return timeA - timeB; // Oldest first
                });
            });
            
            return grouped;
        }

        function renderSlackChannels() {
            const channels = Object.values(messagesByChannel);
            channels.sort((a, b) => {
                const lastMsgA = a.messages[a.messages.length - 1];
                const lastMsgB = b.messages[b.messages.length - 1];
                const timeA = new Date(lastMsgA?.timestamp || 0).getTime();
                const timeB = new Date(lastMsgB?.timestamp || 0).getTime();
                return timeB - timeA; // Most recent first
            });

            if (channels.length === 0) {
                slackChannelsList.innerHTML = '<div class="slack-sidebar-empty">No channels found</div>';
                return;
            }

            const channelsHTML = channels.map(channel => {
                const lastMsg = channel.messages[channel.messages.length - 1];
                const preview = lastMsg?.body ? (lastMsg.body.length > 30 ? lastMsg.body.substring(0, 30) + '...' : lastMsg.body) : 'No messages';
                const time = formatSlackTimestamp(lastMsg?.timestamp);
                const isActive = currentChannelId === channel.channelId;
                
                return `
                    <div class="slack-channel-item ${isActive ? 'active' : ''}" data-channel-id="${channel.channelId}">
                        <div class="slack-channel-name">${channel.channelName}</div>
                        <div class="slack-channel-preview">${preview}</div>
                        <div class="slack-channel-meta">
                            <span class="slack-channel-count">${channel.messages.length} msgs</span>
                            <span class="slack-channel-time">${time}</span>
                </div>
                    </div>
                `;
            }).join('');

            slackChannelsList.innerHTML = channelsHTML;

            // Add click handlers
            document.querySelectorAll('.slack-channel-item').forEach(item => {
                item.addEventListener('click', () => {
                    const channelId = item.dataset.channelId;
                    selectChannel(channelId);
                });
            });
        }

        function selectChannel(channelId) {
            currentChannelId = channelId;
            const channel = messagesByChannel[channelId];
            if (!channel) return;

            slackCurrentChannel.textContent = channel.channelName;
            slackCount.textContent = `${channel.messages.length} messages`;

            // Render messages for this channel
            renderSlackMessages(channel.messages);

            // Show input area
            const inputContainer = document.getElementById('slackInputContainer');
            if (inputContainer) {
                inputContainer.style.display = 'block';
            }

            // Update active state
            document.querySelectorAll('.slack-channel-item').forEach(item => {
                item.classList.toggle('active', item.dataset.channelId === channelId);
            });

            // Focus input
            const messageInput = document.getElementById('slackMessageInput');
            if (messageInput) {
                messageInput.focus();
            }
        }

        function renderSlackMessages(messages) {
            if (!messages || messages.length === 0) {
                slackMessagesContainer.innerHTML = '<div class="slack-empty-state"><p>No messages in this channel</p></div>';
                return;
            }

            let lastUserId = null;
            let lastDate = null;
            const messagesHTML = messages.map((msg, index) => {
                const msgDate = new Date(msg.timestamp || Date.now());
                const currentDate = msgDate.toDateString();
                const showDateDivider = lastDate !== currentDate;
                lastDate = currentDate;

                const showAvatar = lastUserId !== msg.from_id;
                lastUserId = msg.from_id;

                const initials = getInitials(msg.from_name || msg.from_id);
                const avatarColor = getAvatarColor(msg.from_name || msg.from_id);
                const timeStr = formatSlackTime(msg.timestamp);
                const formattedBody = formatSlackMessage(msg.body || '');

                let html = '';
                
                // Date divider
                if (showDateDivider) {
                    const dateStr = msgDate.toLocaleDateString('en-US', { 
                        weekday: 'long', 
                        year: 'numeric', 
                        month: 'long', 
                        day: 'numeric' 
                    });
                    html += `<div class="slack-date-divider"><span>${dateStr}</span></div>`;
                }

                // Message
                html += `
                    <div class="slack-message ${showAvatar ? 'show-avatar' : ''}" data-message-id="${msg.message_id}">
                        ${showAvatar ? `
                            <div class="slack-avatar" style="background-color: ${avatarColor}">
                                ${initials}
                            </div>
                        ` : '<div class="slack-avatar-spacer"></div>'}
                        <div class="slack-message-content">
                            ${showAvatar ? `
                                <div class="slack-message-header">
                                    <span class="slack-username">${msg.from_name || msg.from_id || 'Unknown'}</span>
                                    <span class="slack-timestamp">${timeStr}</span>
                                </div>
                            ` : ''}
                            <div class="slack-message-body">${formattedBody || '<em>No content</em>'}</div>
                        </div>
                    </div>
                `;

                return html;
            }).join('');

            slackMessagesContainer.innerHTML = messagesHTML;
            slackMessagesContainer.scrollTop = slackMessagesContainer.scrollHeight;
        }

        function updateSlackCount() {
            if (!slackCount) return;
            const total = Object.values(messagesByChannel).reduce((sum, ch) => sum + ch.messages.length, 0);
            slackCount.textContent = `${total} total messages`;
        }

        async function loadSlackMessages() {
            slackViewButton.disabled = true;
            slackViewButton.textContent = 'Loading...';
            allSlackMessages = [];
            messagesByChannel = {};
            currentChannelId = null;
            totalSlackCount = 0;

            try {
                console.log('[*] Requesting Slack messages from backend...');
                const response = await fetch('http://localhost:8000/api/slack/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        limit: 50  // Reduced from 200 to 50 for faster loading
                    })
                });

                console.log('[*] Response status:', response.status);
                const data = await response.json();
                console.log('[*] Response data:', data);

                if (response.ok && data.success) {
                    allSlackMessages = data.messages || [];
                    totalSlackCount = typeof data.total_count === 'number' ? data.total_count : allSlackMessages.length;
                    
                    // Group messages by channel
                    messagesByChannel = groupMessagesByChannel(allSlackMessages);
                    
                    // Render channels sidebar
                    renderSlackChannels();
                    
                    // Auto-select first channel if available
                    const channels = Object.keys(messagesByChannel);
                    if (channels.length > 0) {
                        selectChannel(channels[0]);
                    } else {
                        slackMessagesContainer.innerHTML = '<div class="slack-empty-state"><p>No messages found</p></div>';
                    }
                    
                    updateSlackCount();
                    console.log(`[OK] Got ${allSlackMessages.length} Slack messages in ${channels.length} channels`);
                } else {
                    const errorMsg = data.error || data.detail || JSON.stringify(data);
                    console.error('[!] Backend error:', errorMsg);
                    slackMessagesContainer.innerHTML = `<div class="slack-empty-state"><div class="slack-empty-icon">‚ö†Ô∏è</div><h3>Error</h3><p>${errorMsg}</p></div>`;
                    slackChannelsList.innerHTML = '<div class="slack-sidebar-empty">Error loading channels</div>';
                    if (slackCount) slackCount.textContent = 'Error';
                }
            } catch (error) {
                console.error('[!] Exception:', error);
                slackMessagesContainer.innerHTML = `<div class="slack-empty-state"><div class="slack-empty-icon">‚ö†Ô∏è</div><h3>Error</h3><p>Exception: ${error.message}</p></div>`;
                slackChannelsList.innerHTML = '<div class="slack-sidebar-empty">Error loading channels</div>';
                if (slackCount) slackCount.textContent = 'Error';
            }

            slackViewButton.disabled = false;
            slackViewButton.textContent = 'Refresh';
        }

        slackViewButton.addEventListener('click', loadSlackMessages);

        // Slack send message functionality
        const slackMessageInput = document.getElementById('slackMessageInput');
        const slackSendButton = document.getElementById('slackSendButton');

        // Auto-resize textarea
        if (slackMessageInput) {
            slackMessageInput.addEventListener('input', function() {
                this.style.height = 'auto';
                this.style.height = Math.min(this.scrollHeight, 150) + 'px';
                slackSendButton.disabled = !this.value.trim() || !currentChannelId;
            });

            slackMessageInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    if (!slackSendButton.disabled) {
                        sendSlackMessage();
                    }
                }
            });
        }

        async function sendSlackMessage() {
            if (!currentChannelId || !slackMessageInput) return;
            
            const text = slackMessageInput.value.trim();
            if (!text) return;
        
            // Disable input while sending
            slackMessageInput.disabled = true;
            slackSendButton.disabled = true;
            slackSendButton.innerHTML = '<div class="slack-send-spinner"></div>';

            try {
                console.log(`[*] Sending message to channel ${currentChannelId}...`);
                const response = await fetch('http://localhost:8000/api/slack/send', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        channel_id: currentChannelId,
                        text: text
                    })
                });

                console.log('[*] Response status:', response.status);
                const data = await response.json();
                console.log('[*] Response data:', data);

                if (response.ok && data.success) {
                    // Clear input
                    slackMessageInput.value = '';
                    slackMessageInput.style.height = 'auto';
                    
                    // Reload messages to show the new one
                    await loadSlackMessages();
                    
                    // Re-select the current channel
                    if (currentChannelId) {
                        selectChannel(currentChannelId);
                    }
                } else {
                    const errorMsg = data.error || data.detail || JSON.stringify(data);
                    console.error('[!] Backend error:', errorMsg);
                    alert(`Failed to send message: ${errorMsg}`);
                }
            } catch (error) {
                console.error('[!] Exception:', error);
                alert(`Failed to send message: ${error.message}`);
            } finally {
                // Re-enable input
                slackMessageInput.disabled = false;
                slackSendButton.disabled = false;
                slackSendButton.innerHTML = `
                    <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                        <path d="M18 2L9 11M18 2L12 18L9 11M18 2L2 8L9 11" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                `;
                slackMessageInput.focus();
            }
        }

        if (slackSendButton) {
            slackSendButton.addEventListener('click', sendSlackMessage);
        }
    </script>
</body>
</html>
