<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChatGPT Assistant - AI-Powered Automation</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <script>
        for(let i = 0; i < 30; i++) {
            let particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.left = Math.random() * 100 + '%';
            particle.style.animationDelay = Math.random() * 15 + 's';
            particle.style.animationDuration = (Math.random() * 10 + 10) + 's';
            document.body.appendChild(particle);
        }
    </script>

    <div class="container">
        <div class="tab-bar">
            <button class="tab-button active" data-tab="chat">Chat</button>
            <button class="tab-button" data-tab="email">Email</button>
            <button class="tab-button" data-tab="word">Word</button>
            <button class="tab-button" data-tab="excel">Excel</button>
            <button class="tab-button" data-tab="telegram">Telegram</button>
            <button class="tab-button" data-tab="slack">Slack</button>
        </div>

        <div id="chat" class="tab-content active">
            <div class="header">
                <div class="header-content">
                    <h1>ChatGPT Assistant</h1>
                    <div class="status-badge">Online</div>
                </div>
            </div>

            <div class="chat-container" id="chatContainer">
                <div class="message system">
                    <div class="message-content">
                        <div class="welcome-header">
                            <div class="welcome-icon">‚ú®</div>
                            <h2>Welcome to ChatGPT Assistant!</h2>
                            <p class="welcome-subtitle">Your AI-powered automation system is ready to help</p>
                        </div>
                        <div class="help-features">
                            <div class="feature-item">
                                <span class="feature-icon">üöÄ</span>
                                <div class="feature-content">
                                    <strong>Launch Applications</strong>
                                    <p>Try: "Launch calculator" or "Open notepad"</p>
                                </div>
                            </div>
                            <div class="feature-item">
                                <span class="feature-icon">üìß</span>
                                <div class="feature-content">
                                    <strong>Send Emails</strong>
                                    <p>Try: "Send email to user@example.com"</p>
                                </div>
                            </div>
                            <div class="feature-item">
                                <span class="feature-icon">üí¨</span>
                                <div class="feature-content">
                                    <strong>Ask Questions</strong>
                                    <p>Ask me anything - I'm here to help!</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="typing-indicator" id="typingIndicator">
                <span></span>
                <span></span>
                <span></span>
            </div>

            <div class="input-container">
                <div class="input-wrapper">
                    <input 
                        type="text" 
                        id="messageInput" 
                        placeholder="Type your message or command..."
                        autocomplete="off"
                    />
                    <button id="sendButton" class="btn">Send</button>
                </div>
            </div>
        </div>

        <div id="email" class="tab-content">
            <div class="header">
                <div class="header-content">
                    <h1>Email Management</h1>
                    <div class="status-badge">Ready</div>
                </div>
            </div>

            <div class="email-container">
                <div class="email-header">
                    <h2>Inbox</h2>
                    <div class="email-count" id="emailCount">Unread: --</div>
                    <div class="button-group">
                        <button id="unreadButton" class="btn">Unread Mail</button>
                        <button id="refreshButton" class="btn btn-secondary">Refresh</button>
                    </div>
                </div>


                <div class="email-scroll-area">
                    <div class="pagination-controls pagination-top" id="paginationControlsTop" style="display: none;">
                        <button id="prevButtonTop" class="btn btn-pagination">‚Üê Previous</button>
                        <div class="page-numbers" id="pageNumbers"></div>
                        <button id="nextButtonTop" class="btn btn-pagination">Next ‚Üí</button>
                    </div>
                    <div id="emailList" class="email-list">
                        <div class="empty-state">
                            <div class="empty-state-text">Mail</div>
                            <p>Click "Unread Mail" to load your emails</p>
                        </div>
                    </div>
                    <div class="pagination-controls" id="paginationControls" style="display: none;">
                        <button id="prevButton" class="btn btn-pagination">‚Üê Previous</button>
                        <div class="page-numbers" id="pageNumbersBottom"></div>
                        <button id="nextButton" class="btn btn-pagination">Next ‚Üí</button>
                    </div>
                </div>

                <!-- Email Detail Modal - Beautiful Dialog -->
                <div class="email-detail-modal" id="emailDetailModal" style="display: none;">
                    <div class="email-detail-overlay"></div>
                    <div class="email-detail-container">
                        <div class="email-detail-header">
                            <div class="email-detail-header-content">
                                <h2 id="detailSubject" class="email-detail-subject">Subject</h2>
                                <button class="email-close-btn" id="closeEmailBtn" aria-label="Close">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <line x1="18" y1="6" x2="6" y2="18"></line>
                                        <line x1="6" y1="6" x2="18" y2="18"></line>
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <div class="email-detail-info">
                            <div class="email-detail-info-row">
                                <div class="email-detail-info-item">
                                    <span class="email-detail-label">From:</span>
                                    <span id="detailFrom" class="email-detail-value">sender@example.com</span>
                                </div>
                                <div class="email-detail-info-item">
                                    <span class="email-detail-label">Date:</span>
                                    <span id="detailDate" class="email-detail-value">Date</span>
                                </div>
                            </div>
                        </div>
                        <div class="email-detail-body-container">
                            <div class="email-detail-body" id="detailBody">
                                <!-- Email body content here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Excel Tab -->
        <div id="excel" class="tab-content">
            <div class="header">
                <div class="header-content">
                    <h1>Microsoft Excel</h1>
                    <div class="status-badge">Ready</div>
                </div>
            </div>

            <div class="excel-container">
                <div class="excel-header">
                    <h2>Excel Spreadsheets</h2>
                    <div class="button-group">
                        <button id="createExcelButton" class="btn">Create Spreadsheet</button>
                        <button id="openExcelButton" class="btn btn-secondary">Open Spreadsheet</button>
                    </div>
                </div>

                <div class="excel-scroll-area">
                    <div id="excelSpreadsheetArea" class="excel-spreadsheet-area">
                        <div class="empty-state">
                            <div class="empty-state-text">üìä</div>
                            <h3>Excel Spreadsheet Manager</h3>
                            <p>Create a new spreadsheet or open an existing one to get started</p>
                            <div style="margin-top: 20px; text-align: left; max-width: 600px; background: rgba(0,0,0,0.05); padding: 16px; border-radius: 8px;">
                                <p style="font-weight: 600; margin-bottom: 12px;">Available Features:</p>
                                <ul style="margin: 8px 0; padding-left: 20px; line-height: 1.8;">
                                    <li>Create and open Excel spreadsheets (.xlsx)</li>
                                    <li>Edit cells with formulas and data</li>
                                    <li>Apply formatting (bold, italic, colors, borders)</li>
                                    <li>Work with multiple sheets</li>
                                    <li>Add formulas (SUM, AVERAGE, COUNT, etc.)</li>
                                    <li>Sort and filter data</li>
                                    <li>Merge and unmerge cells</li>
                                    <li>Adjust column widths and row heights</li>
                                    <li>Save and export spreadsheets</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Excel Create Modal -->
                <div class="excel-modal" id="excelCreateModal" style="display: none;">
                    <div class="excel-modal-content">
                        <div class="excel-modal-header">
                            <h3>Create New Spreadsheet</h3>
                            <button class="excel-modal-close" id="excelCreateModalClose">&times;</button>
                        </div>
                        <div class="excel-modal-body">
                            <div class="form-group">
                                <label for="excelFilePath">File Path:</label>
                                <div style="display: flex; gap: 8px; align-items: center;">
                                    <input type="text" id="excelFilePath" placeholder="D:\Documents\spreadsheet.xlsx" style="flex: 1;" />
                                    <button type="button" id="excelFilePathBrowse" class="btn btn-secondary" style="white-space: nowrap; padding: 8px 16px;">Browse</button>
                                </div>
                                <small>Enter the full path where the spreadsheet should be saved</small>
                            </div>
                            <div class="form-group">
                                <label for="excelSheetName">Sheet Name:</label>
                                <input type="text" id="excelSheetName" placeholder="Sheet1" value="Sheet1" />
                            </div>
                        </div>
                        <div class="excel-modal-footer">
                            <button class="btn btn-secondary" id="excelCreateCancel">Cancel</button>
                            <button class="btn" id="excelCreateSubmit">Create Spreadsheet</button>
                        </div>
                    </div>
                </div>

                <!-- Excel Open Modal -->
                <div class="excel-modal" id="excelOpenModal" style="display: none;">
                    <div class="excel-modal-content">
                        <div class="excel-modal-header">
                            <h3>Open Spreadsheet</h3>
                            <button class="excel-modal-close" id="excelOpenModalClose">&times;</button>
                        </div>
                        <div class="excel-modal-body">
                            <div class="form-group">
                                <label for="excelOpenFilePath">File Path:</label>
                                <div style="display: flex; gap: 8px; align-items: center;">
                                    <input type="text" id="excelOpenFilePath" placeholder="D:\Documents\spreadsheet.xlsx" style="flex: 1;" />
                                    <button type="button" id="excelOpenFilePathBrowse" class="btn btn-secondary" style="white-space: nowrap; padding: 8px 16px;">üìÅ Browse</button>
                                </div>
                                <input type="file" id="excelOpenFilePathInput" accept=".xlsx,.xls" style="display: none;" />
                                <small style="display: block; margin-top: 8px; color: #64748b;">
                                    üí° Click Browse to select a file, or type the full path manually.<br>
                                    Examples: <code style="color: #6366f1;">D:\Documents\data.xlsx</code> or <code style="color: #6366f1;">C:\Users\YourName\Desktop\report.xlsx</code>
                                </small>
                            </div>
                        </div>
                        <div class="excel-modal-footer">
                            <button class="btn btn-secondary" id="excelOpenCancel">Cancel</button>
                            <button class="btn" id="excelOpenSubmit">Open Spreadsheet</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Excel Save As Modal -->
        <div class="excel-modal" id="excelSaveAsModal" style="display: none;">
            <div class="excel-modal-content">
                <div class="excel-modal-header">
                    <h3>Save Spreadsheet As</h3>
                    <button class="excel-modal-close" id="excelSaveAsModalClose">&times;</button>
                </div>
                <div class="excel-modal-body">
                    <div class="form-group">
                        <label for="excelSaveAsFolderPath">Folder Path:</label>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <input type="text" id="excelSaveAsFolderPath" placeholder="D:\Documents" style="flex: 1;" />
                            <button type="button" id="excelSaveAsFolderPathBrowse" class="btn btn-secondary" style="white-space: nowrap; padding: 8px 16px;">Browse Folder</button>
                        </div>
                        <small>Select the folder where you want to save the spreadsheet</small>
                    </div>
                    <div class="form-group" style="margin-top: 16px;">
                        <label for="excelSaveAsFileName">File Name:</label>
                        <input type="text" id="excelSaveAsFileName" placeholder="spreadsheet.xlsx" style="width: 100%;" />
                        <small>Enter the file name (include .xlsx extension or it will be added automatically)</small>
                    </div>
                </div>
                <div class="excel-modal-footer">
                    <button class="btn btn-secondary" id="excelSaveAsCancel">Cancel</button>
                    <button class="btn" id="excelSaveAsSubmit">Save</button>
                </div>
            </div>
        </div>


        <div id="telegram" class="tab-content">
            <div class="telegram-container">
                <!-- Telegram Sidebar -->
                <div class="telegram-sidebar">
                    <div class="telegram-sidebar-header">
                        <h2>Chats</h2>
                        <button id="telegramShowButton" class="telegram-refresh-btn">Refresh</button>
                </div>
                    <div class="telegram-sidebar-content" id="telegramChatsList">
                        <div class="telegram-sidebar-empty">Click "Refresh" to load chats</div>
                    </div>
                </div>

                <!-- Telegram Main Area -->
                <div class="telegram-main">
                    <div class="telegram-header">
                        <div class="telegram-header-content">
                            <h2 id="telegramCurrentChat">Select a chat</h2>
                            <div class="telegram-header-info" id="telegramCount">-- messages</div>
                        </div>
                    </div>
                    <div class="telegram-messages-container" id="telegramMessagesContainer">
                        <div class="telegram-empty-state">
                            <div class="telegram-empty-icon">‚úàÔ∏è</div>
                            <h3>Welcome to Telegram</h3>
                            <p>Select a chat from the sidebar or click "Refresh" to load your messages</p>
                </div>
                        </div>
                    <div class="telegram-input-container" id="telegramInputContainer" style="display: none;">
                        <div class="telegram-input-wrapper">
                            <textarea 
                                id="telegramMessageInput" 
                                class="telegram-message-input" 
                                placeholder="Type a message..."
                                rows="1"
                            ></textarea>
                            <button id="telegramSendButton" class="telegram-send-button" disabled>
                                <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                                    <path d="M18 2L9 11M18 2L12 18L9 11M18 2L2 8L9 11" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </button>
                            </div>
                            </div>
                </div>
            </div>
        </div>

        <div id="word" class="tab-content">
            <div class="header">
                <div class="header-content">
                    <h1>Microsoft Word</h1>
                    <div class="status-badge">Ready</div>
                </div>
            </div>

            <div class="word-container">
                <div class="word-header">
                    <h2>Word Documents</h2>
                    <div class="button-group">
                        <button id="createWordDocButton" class="btn">Create Document</button>
                        <button id="openWordDocButton" class="btn btn-secondary">Open Document</button>
                    </div>
                </div>

                <div class="word-scroll-area">
                    <div id="wordDocumentArea" class="word-document-area">
                        <div class="empty-state">
                            <div class="empty-state-text">üìÑ</div>
                            <h3>Word Document Manager</h3>
                            <p>Create a new document or open an existing one to get started</p>
                            <div style="margin-top: 20px; text-align: left; max-width: 600px; background: rgba(0,0,0,0.05); padding: 16px; border-radius: 8px;">
                                <p style="font-weight: 600; margin-bottom: 12px;">Available Features:</p>
                                <ul style="margin: 8px 0; padding-left: 20px; line-height: 1.8;">
                                    <li>Create and open Word documents</li>
                                    <li>Add formatted text (bold, italic, underline, fonts, colors)</li>
                                    <li>Format paragraphs (alignment, spacing, indentation)</li>
                                    <li>Add headings, lists, and tables</li>
                                    <li>Find and replace text</li>
                                    <li>Configure page setup (margins, orientation, page size)</li>
                                    <li>Save documents</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Word Document Creation Modal -->
                <div class="word-modal" id="wordCreateModal" style="display: none;">
                    <div class="word-modal-content">
                        <div class="word-modal-header">
                            <h3>Create New Document</h3>
                            <button class="word-modal-close" id="wordCreateModalClose">&times;</button>
                        </div>
                        <div class="word-modal-body">
                            <div class="form-group">
                                <label for="wordFilePath">File Path:</label>
                                <div style="display: flex; gap: 8px; align-items: center;">
                                    <input type="text" id="wordFilePath" placeholder="C:\Users\Username\Documents\document.docx" style="flex: 1;" />
                                    <button type="button" id="wordFilePathBrowse" class="btn btn-secondary" style="white-space: nowrap; padding: 8px 16px;">Browse</button>
                                </div>
                                <input type="file" id="wordFilePathInput" accept=".docx" style="display: none;" />
                                <small>Enter the full path where you want to save the document, or click Browse to select a location</small>
                            </div>
                            <div class="form-group">
                                <label for="wordDocTitle">Document Title (optional):</label>
                                <input type="text" id="wordDocTitle" placeholder="My Document" />
                            </div>
                            <div class="form-group">
                                <label for="wordDocContent">Initial Content (optional):</label>
                                <textarea id="wordDocContent" rows="5" placeholder="Enter initial content for your document..."></textarea>
                            </div>
                        </div>
                        <div class="word-modal-footer">
                            <button class="btn btn-secondary" id="wordCreateCancel">Cancel</button>
                            <button class="btn" id="wordCreateSubmit">Create Document</button>
                        </div>
                    </div>
                </div>

                <!-- Word Document Open Modal -->
                <div class="word-modal" id="wordOpenModal" style="display: none;">
                    <div class="word-modal-content">
                        <div class="word-modal-header">
                            <h3>Open Document</h3>
                            <button class="word-modal-close" id="wordOpenModalClose">&times;</button>
                        </div>
                        <div class="word-modal-body">
                            <div class="form-group">
                                <label for="wordOpenFilePath">File Path:</label>
                                <div style="display: flex; gap: 8px; align-items: center;">
                                    <input type="text" id="wordOpenFilePath" placeholder="C:\Users\Username\Documents\document.docx" style="flex: 1;" />
                                    <button type="button" id="wordOpenFilePathBrowse" class="btn btn-secondary" style="white-space: nowrap; padding: 8px 16px;">Browse</button>
                                </div>
                                <input type="file" id="wordOpenFilePathInput" accept=".docx" style="display: none;" />
                                <small>Enter the full path to the Word document you want to open, or click Browse to select a file</small>
                            </div>
                        </div>
                        <div class="word-modal-footer">
                            <button class="btn btn-secondary" id="wordOpenCancel">Cancel</button>
                            <button class="btn" id="wordOpenSubmit">Open Document</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Word Document Save As Modal -->
        <div class="word-modal" id="wordSaveAsModal" style="display: none;">
            <div class="word-modal-content">
                <div class="word-modal-header">
                    <h3>Save As</h3>
                    <button class="word-modal-close" id="wordSaveAsModalClose">&times;</button>
                </div>
                <div class="word-modal-body">
                    <div class="form-group">
                        <label for="wordSaveAsFolderPath">Folder Path:</label>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <input type="text" id="wordSaveAsFolderPath" placeholder="C:\Users\Username\Documents" style="flex: 1;" />
                            <button type="button" id="wordSaveAsFolderPathBrowse" class="btn btn-secondary" style="white-space: nowrap; padding: 8px 16px;">Browse Folder</button>
                        </div>
                        <small>Select the folder where you want to save the document</small>
                    </div>
                    <div class="form-group" style="margin-top: 16px;">
                        <label for="wordSaveAsFileName">File Name:</label>
                        <input type="text" id="wordSaveAsFileName" placeholder="document.docx" style="width: 100%;" />
                        <small>Enter the file name (include .docx extension or it will be added automatically)</small>
                    </div>
                </div>
                <div class="word-modal-footer">
                    <button class="btn btn-secondary" id="wordSaveAsCancel">Cancel</button>
                    <button class="btn" id="wordSaveAsSubmit">Save</button>
                </div>
            </div>
        </div>

        <!-- Folder Browser Dialog for Save As -->
        <div class="word-modal" id="wordFolderBrowserDialog" style="display: none; z-index: 2001;">
            <div class="word-modal-content" style="max-width: 800px; width: 90%; max-height: 85vh; display: flex; flex-direction: column;">
                <div class="word-modal-header" style="flex-shrink: 0;">
                    <h3>Select Folder</h3>
                    <button class="word-modal-close" id="wordFolderBrowserDialogClose">&times;</button>
                </div>
                
                <!-- Navigation Bar -->
                <div style="padding: 8px 16px; background: #f5f5f5; border-bottom: 1px solid #ddd; display: flex; align-items: center; gap: 8px; flex-shrink: 0;">
                    <button type="button" id="wordFolderBrowserNavUp" class="word-nav-btn" title="Up" style="width: 32px; height: 32px; padding: 0; border: 1px solid #ccc; background: white; border-radius: 2px; cursor: pointer;">‚Üë</button>
                    <div id="wordFolderBrowserPathBreadcrumb" style="flex: 1; padding: 4px 8px; background: white; border: 1px solid #ccc; border-radius: 2px; font-size: 12px; color: #333; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                        <!-- Path breadcrumb will be shown here -->
                    </div>
                    <button type="button" id="wordFolderBrowserRefresh" class="word-nav-btn" title="Refresh" style="width: 32px; height: 32px; padding: 0; border: 1px solid #ccc; background: white; border-radius: 2px; cursor: pointer;">‚Üª</button>
                </div>

                <!-- Folder List -->
                <div style="flex: 1; overflow-y: auto; background: white; padding: 4px 0; min-height: 300px;">
                    <div id="wordFolderBrowserContent" style="padding: 8px;">
                        <!-- Folders will be listed here -->
                    </div>
                </div>

                <!-- Bottom Section -->
                <div style="padding: 12px 16px; background: #f5f5f5; border-top: 1px solid #ddd; flex-shrink: 0; display: flex; justify-content: flex-end; gap: 8px;">
                    <button class="btn btn-secondary" id="wordFolderBrowserCancel">Cancel</button>
                    <button class="btn" id="wordFolderBrowserSelect">Select Folder</button>
                </div>
            </div>
        </div>

        <!-- File Browser Dialog (Windows-style) -->
        <div class="word-modal" id="wordFileBrowserDialog" style="display: none; z-index: 2000;">
            <div class="word-modal-content" style="max-width: 900px; width: 90%; max-height: 85vh; display: flex; flex-direction: column;">
                <div class="word-modal-header" style="flex-shrink: 0;">
                    <h3 id="wordBrowserDialogTitle">Open</h3>
                    <button class="word-modal-close" id="wordFileBrowserDialogClose">&times;</button>
                </div>
                
                <!-- Navigation Bar -->
                <div style="padding: 8px 16px; background: #f5f5f5; border-bottom: 1px solid #ddd; display: flex; align-items: center; gap: 8px; flex-shrink: 0;">
                    <button type="button" id="wordBrowserNavBack" class="word-nav-btn" title="Back" style="width: 32px; height: 32px; padding: 0; border: 1px solid #ccc; background: white; border-radius: 2px; cursor: pointer;">‚Üê</button>
                    <button type="button" id="wordBrowserNavForward" class="word-nav-btn" title="Forward" style="width: 32px; height: 32px; padding: 0; border: 1px solid #ccc; background: white; border-radius: 2px; cursor: pointer;">‚Üí</button>
                    <button type="button" id="wordBrowserNavUp" class="word-nav-btn" title="Up" style="width: 32px; height: 32px; padding: 0; border: 1px solid #ccc; background: white; border-radius: 2px; cursor: pointer;">‚Üë</button>
                    <div id="wordBrowserPathBreadcrumb" style="flex: 1; padding: 4px 8px; background: white; border: 1px solid #ccc; border-radius: 2px; font-size: 12px; color: #333; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                        <!-- Path breadcrumb will be shown here -->
                    </div>
                    <button type="button" id="wordBrowserRefresh" class="word-nav-btn" title="Refresh" style="width: 32px; height: 32px; padding: 0; border: 1px solid #ccc; background: white; border-radius: 2px; cursor: pointer;">‚Üª</button>
                </div>

                <!-- Main Content Area -->
                <div style="display: flex; flex: 1; min-height: 0; overflow: hidden;">
                    <!-- Left Sidebar -->
                    <div style="width: 220px; background: #f9f9f9; border-right: 1px solid #ddd; padding: 12px; overflow-y: auto; flex-shrink: 0;">
                        <div style="margin-bottom: 16px;">
                            <div style="font-size: 11px; font-weight: 600; color: #666; margin-bottom: 8px; text-transform: uppercase;">Quick Access</div>
                            <div id="wordBrowserQuickAccess" style="display: flex; flex-direction: column; gap: 2px;">
                                <!-- Quick access items will be added here -->
                            </div>
                        </div>
                        <div>
                            <div style="font-size: 11px; font-weight: 600; color: #666; margin-bottom: 8px; text-transform: uppercase;">Folders</div>
                            <div id="wordBrowserFolderTree" style="display: flex; flex-direction: column; gap: 2px;">
                                <!-- Folder tree will be added here -->
                            </div>
                        </div>
                    </div>

                    <!-- Main File List -->
                    <div style="flex: 1; display: flex; flex-direction: column; overflow: hidden;">
                        <!-- File List Header -->
                        <div style="padding: 8px 16px; background: #f5f5f5; border-bottom: 1px solid #ddd; display: grid; grid-template-columns: 2fr 1.5fr 1fr; gap: 16px; font-size: 12px; font-weight: 600; color: #666; flex-shrink: 0;">
                            <div>Name</div>
                            <div>Date modified</div>
                            <div>Type</div>
                        </div>
                        <!-- File List Content -->
                        <div id="wordBrowserDialogContent" style="flex: 1; overflow-y: auto; background: white; padding: 4px 0;">
                            <!-- Files and folders will be listed here -->
                        </div>
                    </div>
                </div>

                <!-- Bottom Section -->
                <div style="padding: 12px 16px; background: #f5f5f5; border-top: 1px solid #ddd; flex-shrink: 0;">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
                        <label style="font-size: 12px; color: #333; white-space: nowrap;">File name:</label>
                        <input type="text" id="wordBrowserFileName" style="flex: 1; padding: 4px 8px; border: 1px solid #ccc; border-radius: 2px; font-size: 12px;" placeholder="Enter file name or select from list" />
                    </div>
                    <div style="display: flex; align-items: center; gap: 12px; justify-content: flex-end;">
                        <label style="font-size: 12px; color: #333; white-space: nowrap;">Files of type:</label>
                        <select id="wordBrowserFileType" style="padding: 4px 8px; border: 1px solid #ccc; border-radius: 2px; font-size: 12px; background: white;">
                            <option value=".docx">Word Documents (*.docx)</option>
                            <option value="*">All Files (*.*)</option>
                        </select>
                    </div>
                </div>

                <!-- Footer Buttons -->
                <div class="word-modal-footer" style="flex-shrink: 0;">
                    <button class="btn" id="wordFileBrowserDialogOpen" style="min-width: 80px;">Open</button>
                    <button class="btn btn-secondary" id="wordFileBrowserDialogCancel" style="min-width: 80px;">Cancel</button>
                </div>
            </div>
        </div>

        <div id="slack" class="tab-content">
            <div class="slack-container">
                <!-- Slack Sidebar -->
                <div class="slack-sidebar">
                    <div class="slack-sidebar-header">
                        <h2>Channels & Conversations</h2>
                        <button id="slackViewButton" class="slack-refresh-btn">Refresh</button>
                </div>
                    <div class="slack-sidebar-content" id="slackChannelsList">
                        <div class="slack-sidebar-empty">Click "Refresh" to load channels</div>
                    </div>
                </div>

                <!-- Slack Main Area -->
                <div class="slack-main">
                    <div class="slack-header">
                        <div class="slack-header-content">
                            <h2 id="slackCurrentChannel">Select a channel</h2>
                            <div class="slack-header-info" id="slackCount">-- messages</div>
                        </div>
                    </div>
                    <div class="slack-messages-container" id="slackMessagesContainer">
                        <div class="slack-empty-state">
                            <div class="slack-empty-icon">üí¨</div>
                            <h3>Welcome to Slack</h3>
                            <p>Select a channel from the sidebar or click "Refresh" to load your messages</p>
                </div>
                        </div>
                    <div class="slack-input-container" id="slackInputContainer" style="display: none;">
                        <div class="slack-input-wrapper">
                            <textarea 
                                id="slackMessageInput" 
                                class="slack-message-input" 
                                placeholder="Message #channel"
                                rows="1"
                            ></textarea>
                            <button id="slackSendButton" class="slack-send-button" disabled>
                                <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                                    <path d="M18 2L9 11M18 2L12 18L9 11M18 2L2 8L9 11" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </button>
                            </div>
                            </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', (e) => {
                // Prevent any keyboard shortcuts from triggering when clicking tabs
                e.preventDefault();
                e.stopPropagation();
                
                const tabName = button.dataset.tab;
                
                document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                button.classList.add('active');
                document.getElementById(tabName).classList.add('active');
                
                if (tabName === 'chat') {
                    document.getElementById('messageInput').focus();
                }
                
                // Explicitly ensure no save is triggered when switching tabs
                // The save function should only be called explicitly via the Save button or Ctrl+S
                return false;
            });
        });

        const chatContainer = document.getElementById('chatContainer');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const typingIndicator = document.getElementById('typingIndicator');

        function addMessage(text, type = 'assistant') {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            // Format the message to preserve line breaks and add proper paragraph spacing
            let formattedText = text
                .replace(/\n\n/g, '</p><p>') // Double newlines become new paragraphs
                .replace(/\n/g, '<br>') // Single newlines become line breaks
                .replace(/^(.+)$/, '<p>$1</p>'); // Wrap in paragraph tags
            
            // Enhance emoji and icon display
            formattedText = enhanceIconsAndEmojis(formattedText);
            
            contentDiv.innerHTML = formattedText;
            
            messageDiv.appendChild(contentDiv);
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        function enhanceIconsAndEmojis(text) {
            // Wrap standalone emojis in a span for better styling
            text = text.replace(/([\u{1F300}-\u{1F9FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}])/gu, '<span class="emoji-icon">$1</span>');
            
            // Convert common text patterns to visual icons
            text = text.replace(/\b(‚úì|‚úîÔ∏è|‚úÖ)/g, '<span class="icon-success">$1</span>');
            text = text.replace(/\b(‚úó|‚ùå|‚õî)/g, '<span class="icon-error">$1</span>');
            text = text.replace(/\b(‚ÑπÔ∏è|‚Ñπ|üí°)/g, '<span class="icon-info">$1</span>');
            text = text.replace(/\b(‚ö†Ô∏è|‚ö†|‚ö°)/g, '<span class="icon-warning">$1</span>');
            
            // Enhance bullet points with icons
            text = text.replace(/‚Ä¢/g, '<span class="bullet-icon">‚Ä¢</span>');
            text = text.replace(/‚Üí/g, '<span class="arrow-icon">‚Üí</span>');
            
            return text;
        }

        async function sendMessage() {
            const message = messageInput.value.trim();
            if (!message) return;

            addMessage(message, 'user');
            messageInput.value = '';
            sendButton.disabled = true;

            typingIndicator.classList.add('active');

            // Get user_id from localStorage (set during login)
            const userId = localStorage.getItem('user_id');
            
            // Validate user_id
            let userIdInt = null;
            if (userId) {
                const parsed = parseInt(userId, 10);
                if (!isNaN(parsed) && parsed > 0) {
                    userIdInt = parsed;
                } else {
                    console.warn('[CHAT] Invalid user_id in localStorage:', userId);
                }
            } else {
                // Try to get user_id from token if not in localStorage
                const authToken = localStorage.getItem('auth_token');
                if (authToken) {
                    try {
                        const tokenParts = authToken.split('.');
                        if (tokenParts.length === 3) {
                            const payload = JSON.parse(atob(tokenParts[1]));
                            if (payload.user_id) {
                                userIdInt = parseInt(payload.user_id, 10);
                                localStorage.setItem('user_id', userIdInt.toString());
                                console.log('[CHAT] Extracted user_id from token:', userIdInt);
                            }
                        }
                    } catch (e) {
                        console.warn('[CHAT] Could not extract user_id from token');
                    }
                }
                
                if (!userIdInt) {
                    console.warn('[CHAT] No user_id found. Chat will work but conversations will not be saved to database.');
                }
            }

            try {
                const response = await fetch('http://localhost:5000/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        message: message,
                        user_id: userIdInt  // Send validated user_id
                    })
                });

                const data = await response.json();
                typingIndicator.classList.remove('active');

                if (response.ok) {
                    addMessage(data.response, 'assistant');
                } else {
                    addMessage(`ERROR: ${data.error || 'Unknown error'}`, 'error');
                }
            } catch (error) {
                typingIndicator.classList.remove('active');
                addMessage(`CONNECTION ERROR: ${error.message}`, 'error');
            }

            sendButton.disabled = false;
            messageInput.focus();
        }

        sendButton.addEventListener('click', sendMessage);
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });

        const unreadButton = document.getElementById('unreadButton');
        const refreshButton = document.getElementById('refreshButton');
        const emailList = document.getElementById('emailList');
        const emailCount = document.getElementById('emailCount');

        let allEmails = [];
        let totalUnread = 0;
        let currentPage = 1;
        const emailsPerPage = 10;

        function getTotalPages() {
            return Math.ceil(allEmails.length / emailsPerPage);
        }

        function goToPage(pageNum) {
            const totalPages = getTotalPages();
            if (pageNum < 1 || pageNum > totalPages) return;
            currentPage = pageNum;
            renderEmails();
        }

        function updateEmailCount() {
            if (!emailCount) return;
            const shown = allEmails.length;
            const total = totalUnread || 0;
            emailCount.textContent = `Showing ${shown} / ${total} unread`;
        }

        // Get credentials from environment (exposed by backend)
        async function getUserCredentials() {
            try {
                const response = await fetch('http://localhost:5000/get_user_credentials');
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Error fetching credentials:', error);
                return null;
            }
        }

        function renderEmails() {
            const totalPages = getTotalPages();
            const startIdx = (currentPage - 1) * emailsPerPage;
            const endIdx = startIdx + emailsPerPage;
            const paginatedEmails = allEmails.slice(startIdx, endIdx);

            const emailItems = paginatedEmails.map((email, index) => `
                <div class="email-item" data-email-index="${startIdx + index}">
                    <div class="email-from">From: ${email.from_email || 'Unknown'}</div>
                    <div class="email-subject">${email.subject || '(No Subject)'}</div>
                    <div class="email-date">${email.date || new Date().toLocaleDateString()}</div>
                </div>
            `).join('');

            emailList.innerHTML = emailItems;
            updateEmailCount();

            // Add click handlers to email items
            document.querySelectorAll('.email-item').forEach(item => {
                item.addEventListener('click', () => {
                    const emailIndex = parseInt(item.dataset.emailIndex);
                    showEmailDetail(allEmails[emailIndex]);
                });
            });

            // Update pagination controls (both top and bottom)
            updatePaginationControls(totalPages);
        }

        function showEmailDetail(email) {
            const modal = document.getElementById('emailDetailModal');
            const detailSubject = document.getElementById('detailSubject');
            const detailFrom = document.getElementById('detailFrom');
            const detailDate = document.getElementById('detailDate');
            const detailBody = document.getElementById('detailBody');

            // Populate modal with email data
            detailSubject.textContent = email.subject || '(No Subject)';
            detailFrom.textContent = email.from_email || email.from || 'Unknown';
            detailDate.textContent = email.date || new Date().toLocaleDateString();
            
            // Format body content with better readability
            const bodyContent = email.body || 'No content available';
            
            // Clear previous content
            detailBody.innerHTML = '';
            detailBody.className = 'email-detail-body';
            
            // Check if body contains HTML
            if (bodyContent.includes('<') && bodyContent.includes('>')) {
                // Render as HTML (with sanitization) - like Gmail
                detailBody.innerHTML = sanitizeHtml(bodyContent);
                detailBody.className = 'email-detail-body email-detail-body-html';
            } else {
                // Render as plain text with better formatting
                const formattedText = bodyContent
                    .replace(/\n\n+/g, '\n\n') // Normalize multiple line breaks
                    .replace(/\n/g, '<br>'); // Convert line breaks to HTML
                detailBody.innerHTML = `<div class="email-text-content">${formattedText}</div>`;
                detailBody.className = 'email-detail-body email-detail-body-text';
            }

            // Show modal with animation
            modal.style.display = 'flex';
            setTimeout(() => {
                modal.classList.add('email-modal-visible');
            }, 10);
            
            // Prevent body scroll when modal is open
            document.body.style.overflow = 'hidden';
            
            // Mark email as read in Gmail
            markEmailAsRead(email);
        }

        function closeEmailDetail() {
            const modal = document.getElementById('emailDetailModal');
            modal.classList.remove('email-modal-visible');
            setTimeout(() => {
                modal.style.display = 'none';
                document.body.style.overflow = '';
            }, 300);
        }

        async function markEmailAsRead(email) {
            try {
                // Get credentials
                const creds = await getUserCredentials();
                if (!creds || !creds.access_token) {
                    console.warn('Cannot mark email as read: credentials missing');
                    return;
                }
                
                // Call API to mark email as read
                const response = await fetch('http://localhost:8000/api/email/mark-read', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        user_credentials: creds,
                        message_id: email.message_id
                    })
                });
                
                if (response.ok) {
                    console.log(`[OK] Email marked as read: ${email.message_id}`);
                } else {
                    const error = await response.json();
                    console.error('Error marking email as read:', error.detail);
                }
            } catch (error) {
                console.error('Exception marking email as read:', error);
            }
        }

        function sanitizeHtml(html) {
            // Create a temporary container to parse HTML
            const temp = document.createElement('div');
            temp.innerHTML = html;
            
            // Remove potentially dangerous scripts and style elements
            const scripts = temp.querySelectorAll('script, style');
            scripts.forEach(el => el.remove());
            
            // Remove event handlers from all elements
            const allElements = temp.querySelectorAll('*');
            allElements.forEach(el => {
                // Remove all on* attributes (onclick, onload, etc.)
                Array.from(el.attributes).forEach(attr => {
                    if (attr.name.startsWith('on')) {
                        el.removeAttribute(attr.name);
                    }
                });
                
                // Make links safe to open in browser
                if (el.tagName === 'A') {
                    el.target = '_blank';
                    el.rel = 'noopener noreferrer';
                }
            });
            
            return temp.innerHTML;
        }

        function updatePaginationControls(totalPages) {
            const paginationControlsTop = document.getElementById('paginationControlsTop');
            const paginationControls = document.getElementById('paginationControls');
            const prevButton = document.getElementById('prevButton');
            const nextButton = document.getElementById('nextButton');
            const prevButtonTop = document.getElementById('prevButtonTop');
            const nextButtonTop = document.getElementById('nextButtonTop');

            if (totalPages > 1) {
                // Show both pagination controls
                paginationControlsTop.style.display = 'flex';
                paginationControls.style.display = 'flex';
                
                // Update button states for both top and bottom
                prevButton.disabled = currentPage === 1;
                nextButton.disabled = currentPage === totalPages;
                prevButtonTop.disabled = currentPage === 1;
                nextButtonTop.disabled = currentPage === totalPages;
                
                // Generate page numbers for both top and bottom (same structure)
                generatePageNumbers(totalPages, 'pageNumbers');
                generatePageNumbers(totalPages, 'pageNumbersBottom');
            } else {
                paginationControlsTop.style.display = 'none';
                paginationControls.style.display = 'none';
            }
        }

        function generatePageNumbers(totalPages, containerId = 'pageNumbers') {
            const pageNumbers = document.getElementById(containerId);
            if (!pageNumbers) return;
            
            let numbersHTML = '';
            
            // Show up to 7 page numbers with ellipsis for large page counts
            const maxVisible = 7;
            
            if (totalPages <= maxVisible) {
                // Show all pages
                for (let i = 1; i <= totalPages; i++) {
                    numbersHTML += `<button class="page-number ${i === currentPage ? 'active' : ''}" data-page="${i}">${i}</button>`;
                }
            } else {
                // Show first page
                numbersHTML += `<button class="page-number ${currentPage === 1 ? 'active' : ''}" data-page="1">1</button>`;
                
                if (currentPage > 3) {
                    numbersHTML += `<span class="page-ellipsis">...</span>`;
                }
                
                // Show pages around current page
                const start = Math.max(2, currentPage - 1);
                const end = Math.min(totalPages - 1, currentPage + 1);
                
                for (let i = start; i <= end; i++) {
                    numbersHTML += `<button class="page-number ${i === currentPage ? 'active' : ''}" data-page="${i}">${i}</button>`;
                }
                
                if (currentPage < totalPages - 2) {
                    numbersHTML += `<span class="page-ellipsis">...</span>`;
                }
                
                // Show last page
                numbersHTML += `<button class="page-number ${currentPage === totalPages ? 'active' : ''}" data-page="${totalPages}">${totalPages}</button>`;
            }
            
            pageNumbers.innerHTML = numbersHTML;
            
            // Add click handlers to page number buttons
            pageNumbers.querySelectorAll('.page-number').forEach(btn => {
                btn.addEventListener('click', () => {
                    const page = parseInt(btn.dataset.page);
                    goToPage(page);
                });
            });
        }

        async function loadUnreadEmails() {
            unreadButton.disabled = true;
            unreadButton.textContent = 'Loading...';
            allEmails = [];
            totalUnread = 0;
            currentPage = 1;

            try {
                // Get real credentials
                console.log('[*] Fetching credentials...');
                const creds = await getUserCredentials();
                console.log('[*] Got credentials:', {
                    access_token: creds?.access_token ? creds.access_token.substring(0, 20) + '...' : 'NONE',
                    refresh_token: creds?.refresh_token ? creds.refresh_token.substring(0, 20) + '...' : 'NONE',
                    email: creds?.email
                });
                
                if (!creds || !creds.access_token) {
                    console.error('[!] Credentials missing');
                    emailList.innerHTML = '<div class="empty-state"><div class="empty-state-text">Error</div><p>Gmail credentials not found. Please restart the app.</p></div>';
                    if (emailCount) emailCount.textContent = 'Showing 0 / -- unread';
                    unreadButton.disabled = false;
                    unreadButton.textContent = 'Unread Mail';
                    return;
                }

                console.log('[*] Requesting unread emails from backend...');
                const response = await fetch('http://localhost:8000/api/email/unread', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        user_credentials: creds,
                        max_results: 1000
                    })
                });

                console.log('[*] Response status:', response.status);
                const data = await response.json();
                console.log('[*] Response data:', data);

                if (response.ok && data.success) {
                    allEmails = data.emails || [];
                    totalUnread = typeof data.total_unread === 'number' ? data.total_unread : allEmails.length;
                    updateEmailCount();
                    console.log(`[OK] Got ${allEmails.length} emails`);
                    if (allEmails.length === 0) {
                        emailList.innerHTML = '<div class="empty-state"><div class="empty-state-text">OK</div><p>No unread emails</p></div>';
                    } else {
                        renderEmails();
                    }
                } else {
                    const errorMsg = data.error || data.detail || JSON.stringify(data);
                    console.error('[!] Backend error:', errorMsg);
                    emailList.innerHTML = `<div class="empty-state"><div class="empty-state-text">Error</div><p>${errorMsg}</p></div>`;
                    if (emailCount) emailCount.textContent = 'Showing 0 / -- unread';
                }
            } catch (error) {
                console.error('[!] Exception:', error);
                emailList.innerHTML = `<div class="empty-state"><div class="empty-state-text">Error</div><p>Exception: ${error.message}</p></div>`;
                if (emailCount) emailCount.textContent = 'Showing 0 / -- unread';
            }

            unreadButton.disabled = false;
            unreadButton.textContent = 'Unread Mail';
        }

        unreadButton.addEventListener('click', loadUnreadEmails);
        refreshButton.addEventListener('click', loadUnreadEmails);

        document.getElementById('prevButton').addEventListener('click', () => {
            goToPage(currentPage - 1);
        });

        document.getElementById('nextButton').addEventListener('click', () => {
            goToPage(currentPage + 1);
        });

        document.getElementById('prevButtonTop').addEventListener('click', () => {
            goToPage(currentPage - 1);
        });

        document.getElementById('nextButtonTop').addEventListener('click', () => {
            goToPage(currentPage + 1);
        });

        // Close email detail modal
        document.getElementById('closeEmailBtn').addEventListener('click', closeEmailDetail);
        
        // Close modal when clicking outside of it
        // Close modal when clicking on overlay or outside
        const emailDetailModal = document.getElementById('emailDetailModal');
        if (emailDetailModal) {
            emailDetailModal.addEventListener('click', (e) => {
                // Close if clicking on overlay or modal background (not the container)
                if (e.target.id === 'emailDetailModal' || e.target.classList.contains('email-detail-overlay')) {
                    closeEmailDetail();
                }
            });
            
            // Prevent closing when clicking inside the container
            const emailDetailContainer = emailDetailModal.querySelector('.email-detail-container');
            if (emailDetailContainer) {
                emailDetailContainer.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
            }
            
            // Close on ESC key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && emailDetailModal.style.display === 'flex') {
                    closeEmailDetail();
                }
            });
        }

        messageInput.focus();


        // Telegram functionality
        
        // Telegram message sending
        let currentTelegramChatId = null;
        const telegramMessageInput = document.getElementById('telegramMessageInput');
        const telegramSendButton = document.getElementById('telegramSendButton');

        // Auto-resize textarea
        if (telegramMessageInput) {
            telegramMessageInput.addEventListener('input', function() {
                this.style.height = 'auto';
                this.style.height = Math.min(this.scrollHeight, 150) + 'px';
                if (telegramSendButton) {
                    telegramSendButton.disabled = !this.value.trim() || !currentTelegramChatId;
                }
            });

            telegramMessageInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    if (telegramSendButton && !telegramSendButton.disabled) {
                        sendTelegramMessage();
                    }
                }
            });
        }

        // Send button click handler
        if (telegramSendButton) {
            telegramSendButton.addEventListener('click', sendTelegramMessage);
        }

        async function sendTelegramMessage() {
            console.log(`[DEBUG] sendTelegramMessage called, currentTelegramChatId: ${currentTelegramChatId}`);
            if (!currentTelegramChatId || !telegramMessageInput) {
                console.error('[DEBUG] Cannot send: missing currentTelegramChatId or telegramMessageInput');
                alert('Please select a chat first');
                return;
            }
            
            const text = telegramMessageInput.value.trim();
            if (!text) {
                console.error('[DEBUG] Cannot send: empty message text');
                return;
            }

            // Disable input while sending
            telegramMessageInput.disabled = true;
            if (telegramSendButton) {
                telegramSendButton.disabled = true;
                telegramSendButton.innerHTML = '<div class="telegram-send-spinner"></div>';
            }

            try {
                console.log(`[*] Sending message to Telegram chat ${currentTelegramChatId}...`);
                const response = await fetch('http://localhost:8000/api/telegram/send', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        chat_id: currentTelegramChatId,
                        text: text
                    })
                });

                console.log('[*] Response status:', response.status);
                const data = await response.json();
                console.log('[*] Response data:', data);

                if (response.ok && data.success) {
                    // Clear input
                    telegramMessageInput.value = '';
                    telegramMessageInput.style.height = 'auto';
                    
                    // Reload messages to show the new one
                    await loadTelegramMessages();
                    
                    // Re-select the current chat
                    if (currentTelegramChatId) {
                        selectTelegramChat(currentTelegramChatId);
                    }
                } else {
                    const errorMsg = data.error || data.detail || JSON.stringify(data);
                    console.error('[!] Backend error:', errorMsg);
                    alert(`Failed to send message: ${errorMsg}`);
                }
            } catch (error) {
                console.error('[!] Exception:', error);
                alert(`Failed to send message: ${error.message}`);
            } finally {
                // Re-enable input
                telegramMessageInput.disabled = false;
                if (telegramSendButton) {
                    telegramSendButton.disabled = !telegramMessageInput.value.trim() || !currentTelegramChatId;
                    telegramSendButton.innerHTML = `
                        <svg width="20" height="20" viewBox="0 0 20 20" viewBox="0 0 20 20" fill="none">
                            <path d="M18 2L9 11M18 2L12 18L9 11M18 2L2 8L9 11" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    `;
                }
            }
        }

        // Telegram functionality
        const telegramShowButton = document.getElementById('telegramShowButton');
        const telegramMessagesContainer = document.getElementById('telegramMessagesContainer');
        const telegramChatsList = document.getElementById('telegramChatsList');
        const telegramCurrentChat = document.getElementById('telegramCurrentChat');
        const telegramCount = document.getElementById('telegramCount');
        let allTelegramMessages = [];
        let messagesByChat = {};
        let currentChatId = null;
        let totalTelegramCount = 0;

        function getTelegramInitials(name) {
            if (!name) return '?';
            const parts = name.trim().split(' ');
            if (parts.length >= 2) {
                return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
            }
            return name.substring(0, 2).toUpperCase();
        }

        function getTelegramAvatarColor(name) {
            if (!name) return '#3390ec';
            let hash = 0;
            for (let i = 0; i < name.length; i++) {
                hash = name.charCodeAt(i) + ((hash << 5) - hash);
            }
            const colors = [
                '#3390ec', '#e17076', '#fdcb6e', '#6c5ce7', '#a29bfe',
                '#fd79a8', '#00b894', '#00cec9', '#55efc4', '#74b9ff'
            ];
            return colors[Math.abs(hash) % colors.length];
        }

        function formatTelegramTimestamp(timestamp) {
            if (!timestamp) return '';
            try {
                const date = new Date(timestamp);
                const now = new Date();
                const diffMs = now - date;
                const diffMins = Math.floor(diffMs / 60000);
                const diffHours = Math.floor(diffMs / 3600000);
                const diffDays = Math.floor(diffMs / 86400000);

                if (diffMins < 1) return 'now';
                if (diffMins < 60) return `${diffMins}m`;
                if (diffHours < 24) return `${diffHours}h`;
                if (diffDays < 7) return `${diffDays}d`;
                
                const month = date.toLocaleString('default', { month: 'short' });
                const day = date.getDate();
                return `${month} ${day}`;
            } catch (e) {
                return timestamp;
            }
        }

        function formatTelegramTime(timestamp) {
            if (!timestamp) return '';
            try {
                const date = new Date(timestamp);
                return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: false });
            } catch (e) {
                return timestamp;
            }
        }

        function formatTelegramMessage(text) {
            if (!text) return '';
            let formatted = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\n/g, '<br>')
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.+?)\*/g, '<em>$1</em>')
                .replace(/`(.+?)`/g, '<code>$1</code>');
            return formatted;
        }

        function groupMessagesByChat(messages) {
            const grouped = {};
            messages.forEach(msg => {
                const chatId = msg.chat_id || 'unknown';
                if (!grouped[chatId]) {
                    grouped[chatId] = {
                        chatId: chatId,
                        chatName: msg.chat_name || 'Unknown',
                        messages: []
                    };
                }
                grouped[chatId].messages.push(msg);
            });
            
            // Sort messages within each chat by timestamp
            Object.keys(grouped).forEach(chatId => {
                grouped[chatId].messages.sort((a, b) => {
                    const timeA = new Date(a.timestamp || 0).getTime();
                    const timeB = new Date(b.timestamp || 0).getTime();
                    return timeA - timeB; // Oldest first
                });
            });
            
            return grouped;
        }

        function renderTelegramChats() {
            const chats = Object.values(messagesByChat);
            chats.sort((a, b) => {
                const lastMsgA = a.messages[a.messages.length - 1];
                const lastMsgB = b.messages[b.messages.length - 1];
                const timeA = new Date(lastMsgA?.timestamp || 0).getTime();
                const timeB = new Date(lastMsgB?.timestamp || 0).getTime();
                return timeB - timeA; // Most recent first
            });

            if (chats.length === 0) {
                telegramChatsList.innerHTML = '<div class="telegram-sidebar-empty">No chats found</div>';
                return;
            }

            const chatsHTML = chats.map(chat => {
                const lastMsg = chat.messages[chat.messages.length - 1];
                const preview = lastMsg?.body ? (lastMsg.body.length > 30 ? lastMsg.body.substring(0, 30) + '...' : lastMsg.body) : 'No messages';
                const time = formatTelegramTimestamp(lastMsg?.timestamp);
                const isActive = currentChatId === chat.chatId;
                const initials = getTelegramInitials(chat.chatName);
                const avatarColor = getTelegramAvatarColor(chat.chatName);
                
                return `
                    <div class="telegram-chat-item ${isActive ? 'active' : ''}" data-chat-id="${chat.chatId}">
                        <div class="telegram-chat-avatar" style="background-color: ${avatarColor}">
                            ${initials}
                </div>
                        <div class="telegram-chat-info">
                            <div class="telegram-chat-name">${chat.chatName}</div>
                            <div class="telegram-chat-preview">${preview}</div>
                        </div>
                        <div class="telegram-chat-meta">
                            <span class="telegram-chat-time">${time}</span>
                            ${chat.messages.filter(m => !m.is_read && !m.is_sent).length > 0 ? 
                                `<span class="telegram-chat-unread">${chat.messages.filter(m => !m.is_read && !m.is_sent).length}</span>` : ''}
                        </div>
                    </div>
                `;
            }).join('');

            telegramChatsList.innerHTML = chatsHTML;

            // Add click handlers
            document.querySelectorAll('.telegram-chat-item').forEach(item => {
                item.addEventListener('click', () => {
                    const chatId = item.dataset.chatId;
                    selectTelegramChat(chatId);
                });
            });
        }

        function selectTelegramChat(chatId) {
            currentChatId = chatId;
            currentTelegramChatId = chatId;  // Update for send function
            const chat = messagesByChat[chatId];
            if (!chat) return;

            telegramCurrentChat.textContent = chat.chatName;
            telegramCount.textContent = `${chat.messages.length} messages`;

            // Render messages for this chat
            renderTelegramMessages(chat.messages);

            // Show input area
            const telegramInputContainer = document.getElementById('telegramInputContainer');
            if (telegramInputContainer) {
                telegramInputContainer.style.display = 'block';
            }

            // Update active state
            document.querySelectorAll('.telegram-chat-item').forEach(item => {
                item.classList.toggle('active', item.dataset.chatId === chatId);
            });

            // Focus input and update send button state
            const messageInput = document.getElementById('telegramMessageInput');
            if (messageInput) {
                messageInput.focus();
                // Update send button state
                if (telegramSendButton) {
                    telegramSendButton.disabled = !messageInput.value.trim() || !currentTelegramChatId;
                    console.log(`[DEBUG] Chat selected: ${chatId}, currentTelegramChatId: ${currentTelegramChatId}, send button disabled: ${telegramSendButton.disabled}`);
                }
            }
        }

        function renderTelegramMessages(messages) {
            if (!messages || messages.length === 0) {
                telegramMessagesContainer.innerHTML = '<div class="telegram-empty-state"><p>No messages in this chat</p></div>';
                return;
            }

            let lastDate = null;
            const messagesHTML = messages.map((msg, index) => {
                const msgDate = new Date(msg.timestamp || Date.now());
                const currentDate = msgDate.toDateString();
                const showDateDivider = lastDate !== currentDate;
                lastDate = currentDate;

                const timeStr = formatTelegramTime(msg.timestamp);
                const formattedBody = formatTelegramMessage(msg.body || '');
                const isSent = msg.is_sent || false;

                let html = '';
                
                // Date divider
                if (showDateDivider) {
                    const dateStr = msgDate.toLocaleDateString('en-US', { 
                        weekday: 'long', 
                        year: 'numeric', 
                        month: 'long', 
                        day: 'numeric' 
                    });
                    html += `<div class="telegram-date-divider"><span>${dateStr}</span></div>`;
                }

                // Message bubble
                html += `
                    <div class="telegram-message-wrapper ${isSent ? 'sent' : 'received'}">
                        <div class="telegram-message-bubble">
                            <div class="telegram-message-text">${formattedBody || '<em>No content</em>'}</div>
                            <div class="telegram-message-time">${timeStr}</div>
                        </div>
                    </div>
                `;

                return html;
            }).join('');

            telegramMessagesContainer.innerHTML = messagesHTML;
            telegramMessagesContainer.scrollTop = telegramMessagesContainer.scrollHeight;
        }

        function updateTelegramCount() {
            if (!telegramCount) return;
            const total = Object.values(messagesByChat).reduce((sum, ch) => sum + ch.messages.length, 0);
            telegramCount.textContent = `${total} total messages`;
        }

        async function loadTelegramMessages() {
            telegramShowButton.disabled = true;
            telegramShowButton.textContent = 'Loading...';
            allTelegramMessages = [];
            messagesByChat = {};
            currentChatId = null;
            totalTelegramCount = 0;

            try {
                console.log('[*] Requesting Telegram messages from backend...');
                const response = await fetch('http://localhost:8000/api/telegram/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        limit: 50  // Reduced from 200 to 50 for faster loading
                    })
                });

                console.log('[*] Response status:', response.status);
                
                // Handle non-OK responses (like 500 errors)
                if (!response.ok) {
                    let errorData;
                    try {
                        errorData = await response.json();
                    } catch (e) {
                        // If response is not JSON, create error object
                        const errorText = await response.text();
                        errorData = { detail: errorText || `HTTP ${response.status}: ${response.statusText}` };
                    }
                    const errorMsg = errorData.detail || errorData.error || errorData.message || JSON.stringify(errorData);
                    console.error('[!] Backend error (HTTP ' + response.status + '):', errorMsg);
                    throw new Error(errorMsg);
                }
                
                const data = await response.json();
                console.log('[*] Response data:', data);

                if (data.success) {
                    allTelegramMessages = data.messages || [];
                    totalTelegramCount = typeof data.total_count === 'number' ? data.total_count : allTelegramMessages.length;
                    
                    // Group messages by chat
                    messagesByChat = groupMessagesByChat(allTelegramMessages);
                    
                    // Render chats sidebar
                    renderTelegramChats();
                    
                    // Auto-select first chat if available
                    const chats = Object.keys(messagesByChat);
                    if (chats.length > 0) {
                        selectTelegramChat(chats[0]);
                    } else {
                        telegramMessagesContainer.innerHTML = '<div class="telegram-empty-state"><p>No messages found</p></div>';
                    }
                    
                    updateTelegramCount();
                    console.log(`[OK] Got ${allTelegramMessages.length} Telegram messages in ${chats.length} chats`);
                } else {
                    const errorMsg = data.error || data.detail || JSON.stringify(data);
                    console.error('[!] Backend error:', errorMsg);
                    
                    // Check if it's an authentication error
                    if (errorMsg.includes('not authorized') || errorMsg.includes('authenticate') || errorMsg.includes('AUTH_KEY_UNREGISTERED') || errorMsg.includes('invalid or expired') || errorMsg.includes('too many times') || errorMsg.includes('rate limit')) {
                        const isInvalidSession = errorMsg.includes('AUTH_KEY_UNREGISTERED') || errorMsg.includes('invalid or expired');
                        const needsVerificationCode = errorMsg.includes('Verification code') || errorMsg.includes('verification code required');
                        const isRateLimited = errorMsg.includes('too many times') || errorMsg.includes('rate limit') || errorMsg.includes('tried logging in too many');
                        
                        // Format error message - replace newlines with <br> for HTML display
                        const formattedErrorMsg = errorMsg.replace(/\n/g, '<br>');
                        
                        telegramMessagesContainer.innerHTML = `
                            <div class="telegram-empty-state">
                                <div class="telegram-empty-icon">üîê</div>
                                <h3>${isRateLimited ? 'Rate Limited - Please Wait' : isInvalidSession ? 'Invalid Session File' : needsVerificationCode ? 'Verification Code Required' : 'Authentication Required'}</h3>
                                <div style="margin-top: 12px; padding: 16px; background: rgba(0,0,0,0.05); border-radius: 8px; max-width: 600px; text-align: left; margin-left: auto; margin-right: auto;">
                                    <p style="font-size: 13px; color: #2b2b2b; line-height: 1.8; white-space: pre-line; margin: 0; font-family: 'Segoe UI', sans-serif;">${formattedErrorMsg}</p>
                                </div>
                                <p style="margin-top: 20px; font-size: 13px; color: #707579; max-width: 500px; line-height: 1.6;">
                                    ${needsVerificationCode ? 
                                        'This app doesn\'t have a verification code input. ' : 
                                        isInvalidSession ? 
                                            'Your Telegram session file is invalid or expired. ' : 
                                            'Your Telegram client is not authenticated. '
                                    }
                                    ${needsVerificationCode ? 
                                        'Please run the authentication script in your terminal:' : 
                                        'Please follow these steps:'
                                    }
                                </p>
                                ${isRateLimited ? `
                                    <div style="margin-top: 20px; text-align: left; max-width: 500px; background: rgba(255, 193, 7, 0.1); padding: 16px; border-radius: 8px; border-left: 4px solid #ffc107;">
                                        <div style="color: #707579; font-size: 13px; line-height: 1.8;">
                                            <p style="margin-bottom: 12px; font-weight: 600; color: #856404;">‚ö†Ô∏è Rate Limit Active</p>
                                            <p>Telegram has temporarily blocked authentication attempts. This usually happens when:</p>
                                            <ul style="margin: 8px 0; padding-left: 20px;">
                                                <li>Too many verification code requests were made</li>
                                                <li>Multiple failed authentication attempts occurred</li>
                                            </ul>
                                            <p style="margin-top: 12px; font-weight: 600;">What to do:</p>
                                            <ol style="margin: 8px 0; padding-left: 20px;">
                                                <li><strong>Wait 24 hours</strong> for the rate limit to reset</li>
                                                <li>Then try authenticating again: <code style="background: rgba(0,0,0,0.1); padding: 2px 6px; border-radius: 4px;">python authenticate_telegram.py</code></li>
                                                <li>Make sure to enter the verification code correctly on the first try</li>
                                            </ol>
                                        </div>
                                    </div>
                                ` : needsVerificationCode ? `
                                    <div style="margin-top: 20px; text-align: left; max-width: 500px; background: rgba(0,0,0,0.05); padding: 16px; border-radius: 8px;">
                                        <div style="color: #707579; font-size: 13px; line-height: 1.8;">
                                            <p style="margin-bottom: 12px; font-weight: 600; color: #2b2b2b;">Run this command in your terminal:</p>
                                            <code style="display: block; background: rgba(0,0,0,0.1); padding: 12px; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 13px; color: #2b2b2b; margin-bottom: 12px;">
                                                python authenticate_telegram.py
                                            </code>
                                            <p style="margin-top: 12px;">This will open a window where you can enter your verification code from the Telegram app.</p>
                                        </div>
                                    </div>
                                ` : `
                                    <div style="margin-top: 20px; text-align: left; max-width: 500px; background: rgba(0,0,0,0.05); padding: 16px; border-radius: 8px;">
                                        <ol style="color: #707579; font-size: 13px; line-height: 1.8; margin-left: 20px;">
                                            <li>Stop your backend server (Ctrl+C)</li>
                                            <li>Run: <code style="background: rgba(0,0,0,0.1); padding: 2px 6px; border-radius: 4px;">python authenticate_telegram.py</code></li>
                                            <li>Follow the prompts to enter your phone number and verification code</li>
                                            <li>Restart your backend server</li>
                                            <li>Click "Refresh" again</li>
                                        </ol>
                                    </div>
                                    <button id="deleteTelegramSessionBtn" class="telegram-delete-session-btn" style="margin-top: 20px; padding: 10px 20px; background: #e17076; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
                                        Delete Session File (requires server restart)
                                    </button>
                                `}
                            </div>
                        `;
                        
                        // Add click handler for delete session button
                        const deleteBtn = document.getElementById('deleteTelegramSessionBtn');
                        if (deleteBtn) {
                            deleteBtn.addEventListener('click', async () => {
                                if (confirm('This will delete your Telegram session file. You will need to restart the server and authenticate again. Continue?')) {
                                    try {
                                        const response = await fetch('http://localhost:8000/api/telegram/delete-session', {
                                            method: 'POST'
                                        });
                                        const data = await response.json();
                                        if (response.ok && data.success) {
                                            alert(data.message || 'Session file deleted. Please restart your backend server and click Refresh to authenticate.');
                                        } else {
                                            alert('Failed to delete session file: ' + (data.detail || data.message || 'Unknown error'));
                                        }
                                    } catch (error) {
                                        alert('Error deleting session file: ' + error.message);
                                    }
                                }
                            });
                        }
                    } else {
                        telegramMessagesContainer.innerHTML = `<div class="telegram-empty-state"><div class="telegram-empty-icon">‚ö†Ô∏è</div><h3>Error</h3><p>${errorMsg}</p></div>`;
                    }
                    telegramChatsList.innerHTML = '<div class="telegram-sidebar-empty">Error loading chats</div>';
                    if (telegramCount) telegramCount.textContent = 'Error';
        }
            } catch (error) {
                console.error('[!] Exception:', error);
                const errorMsg = error.message || 'Unknown error';
                
                // Check if it's an authentication error
                if (errorMsg.includes('not authorized') || errorMsg.includes('authenticate') || errorMsg.includes('AUTH_KEY_UNREGISTERED') || errorMsg.includes('invalid or expired')) {
                    const isInvalidSession = errorMsg.includes('AUTH_KEY_UNREGISTERED') || errorMsg.includes('invalid or expired');
                    const needsVerificationCode = errorMsg.includes('Verification code') || errorMsg.includes('verification code required');
                    
                    telegramMessagesContainer.innerHTML = `
                        <div class="telegram-empty-state">
                            <div class="telegram-empty-icon">üîê</div>
                            <h3>${isInvalidSession ? 'Invalid Session File' : needsVerificationCode ? 'Verification Code Required' : 'Authentication Required'}</h3>
                            <p>Exception: ${errorMsg}</p>
                                <p style="margin-top: 16px; font-size: 13px; color: #707579; max-width: 500px; line-height: 1.6;">
                                    ${isRateLimited ? 
                                        'Telegram has temporarily blocked authentication attempts due to too many login attempts. ' : 
                                        needsVerificationCode ? 
                                            'This app doesn\'t have a verification code input. ' : 
                                            isInvalidSession ? 
                                                'Your Telegram session file is invalid or expired. ' : 
                                                'Your Telegram client is not authenticated. '
                                    }
                                    ${isRateLimited ? 
                                        'Please wait 24 hours before trying to authenticate again. ' : 
                                        needsVerificationCode ? 
                                            'Please run the authentication script in your terminal:' : 
                                            'Please follow these steps:'
                                    }
                                </p>
                            ${needsVerificationCode ? `
                                <div style="margin-top: 20px; text-align: left; max-width: 500px; background: rgba(0,0,0,0.05); padding: 16px; border-radius: 8px;">
                                    <div style="color: #707579; font-size: 13px; line-height: 1.8;">
                                        <p style="margin-bottom: 12px; font-weight: 600; color: #2b2b2b;">Run this command in your terminal:</p>
                                        <code style="display: block; background: rgba(0,0,0,0.1); padding: 12px; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 13px; color: #2b2b2b; margin-bottom: 12px;">
                                            python authenticate_telegram.py
                                        </code>
                                        <p style="margin-top: 12px;">This will open a window where you can enter your verification code from the Telegram app.</p>
                                    </div>
                                </div>
                            ` : `
                                <div style="margin-top: 20px; text-align: left; max-width: 500px; background: rgba(0,0,0,0.05); padding: 16px; border-radius: 8px;">
                                    <ol style="color: #707579; font-size: 13px; line-height: 1.8; margin-left: 20px;">
                                        <li>Stop your backend server (Ctrl+C)</li>
                                        <li>Run: <code style="background: rgba(0,0,0,0.1); padding: 2px 6px; border-radius: 4px;">python authenticate_telegram.py</code></li>
                                        <li>Follow the prompts to enter your phone number and verification code</li>
                                        <li>Restart your backend server</li>
                                        <li>Click "Refresh" again</li>
                                    </ol>
                                </div>
                                <button id="deleteTelegramSessionBtn2" class="telegram-delete-session-btn" style="margin-top: 20px; padding: 10px 20px; background: #e17076; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500;">
                                    Delete Session File (requires server restart)
                                </button>
                            `}
                        </div>
                    `;
                    
                    // Add click handler for delete session button
                    const deleteBtn = document.getElementById('deleteTelegramSessionBtn2');
                    if (deleteBtn) {
                        deleteBtn.addEventListener('click', async () => {
                            if (confirm('This will delete your Telegram session file. You will need to restart the server and authenticate again. Continue?')) {
                                try {
                                    const response = await fetch('http://localhost:8000/api/telegram/delete-session', {
                                        method: 'POST'
                                    });
                                    const data = await response.json();
                                    if (response.ok && data.success) {
                                        alert('Session file deleted. Please restart your backend server and click Refresh to authenticate.');
                                    } else {
                                        alert('Failed to delete session file: ' + (data.detail || data.message || 'Unknown error'));
                                    }
                                } catch (error) {
                                    alert('Error deleting session file: ' + error.message);
                                }
                            }
                        });
                    }
                } else {
                    telegramMessagesContainer.innerHTML = `<div class="telegram-empty-state"><div class="telegram-empty-icon">‚ö†Ô∏è</div><h3>Error</h3><p>Exception: ${errorMsg}</p></div>`;
                }
                telegramChatsList.innerHTML = '<div class="telegram-sidebar-empty">Error loading chats</div>';
                if (telegramCount) telegramCount.textContent = 'Error';
            }

            telegramShowButton.disabled = false;
            telegramShowButton.textContent = 'Refresh';
        }

        telegramShowButton.addEventListener('click', loadTelegramMessages);


        // Slack functionality
        const slackViewButton = document.getElementById('slackViewButton');
        const slackMessagesContainer = document.getElementById('slackMessagesContainer');
        const slackChannelsList = document.getElementById('slackChannelsList');
        const slackCurrentChannel = document.getElementById('slackCurrentChannel');
        const slackCount = document.getElementById('slackCount');
        let allSlackMessages = [];
        let messagesByChannel = {};
        let currentChannelId = null;
        let totalSlackCount = 0;

        function getInitials(name) {
            if (!name) return '?';
            const parts = name.trim().split(' ');
            if (parts.length >= 2) {
                return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
            }
            return name.substring(0, 2).toUpperCase();
        }

        function getAvatarColor(name) {
            if (!name) return '#4a154b';
            let hash = 0;
            for (let i = 0; i < name.length; i++) {
                hash = name.charCodeAt(i) + ((hash << 5) - hash);
            }
            const colors = [
                '#4a154b', '#350d36', '#1264a3', '#0f5132', '#856404',
                '#721c24', '#155724', '#004085', '#383f45', '#1d1c1d'
            ];
            return colors[Math.abs(hash) % colors.length];
        }

        function formatSlackTimestamp(timestamp) {
            if (!timestamp) return '';
            try {
                const date = new Date(timestamp);
                const now = new Date();
                const diffMs = now - date;
                const diffMins = Math.floor(diffMs / 60000);
                const diffHours = Math.floor(diffMs / 3600000);
                const diffDays = Math.floor(diffMs / 86400000);

                if (diffMins < 1) return 'now';
                if (diffMins < 60) return `${diffMins}m ago`;
                if (diffHours < 24) return `${diffHours}h ago`;
                if (diffDays < 7) return `${diffDays}d ago`;
                
                // Format as date
                const month = date.toLocaleString('default', { month: 'short' });
                const day = date.getDate();
                const year = date.getFullYear();
                const isThisYear = year === now.getFullYear();
                return isThisYear ? `${month} ${day}` : `${month} ${day}, ${year}`;
            } catch (e) {
                return timestamp;
            }
        }

        function formatSlackTime(timestamp) {
            if (!timestamp) return '';
            try {
                const date = new Date(timestamp);
                return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
            } catch (e) {
                return timestamp;
            }
        }

        function formatSlackMessage(text) {
            if (!text) return '';
            // Convert Slack markdown-like formatting
            let formatted = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\n/g, '<br>')
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.+?)\*/g, '<em>$1</em>')
                .replace(/`(.+?)`/g, '<code>$1</code>');
            return formatted;
        }

        function groupMessagesByChannel(messages) {
            const grouped = {};
            messages.forEach(msg => {
                const channelId = msg.channel_id || 'unknown';
                if (!grouped[channelId]) {
                    grouped[channelId] = {
                        channelId: channelId,
                        channelName: msg.channel_name || 'Unknown',
                        messages: []
                    };
                }
                grouped[channelId].messages.push(msg);
            });
            
            // Sort messages within each channel by timestamp
            Object.keys(grouped).forEach(channelId => {
                grouped[channelId].messages.sort((a, b) => {
                    const timeA = new Date(a.timestamp || 0).getTime();
                    const timeB = new Date(b.timestamp || 0).getTime();
                    return timeA - timeB; // Oldest first
                });
            });
            
            return grouped;
        }

        function renderSlackChannels() {
            const channels = Object.values(messagesByChannel);
            channels.sort((a, b) => {
                const lastMsgA = a.messages[a.messages.length - 1];
                const lastMsgB = b.messages[b.messages.length - 1];
                const timeA = new Date(lastMsgA?.timestamp || 0).getTime();
                const timeB = new Date(lastMsgB?.timestamp || 0).getTime();
                return timeB - timeA; // Most recent first
            });

            if (channels.length === 0) {
                slackChannelsList.innerHTML = '<div class="slack-sidebar-empty">No channels found</div>';
                return;
            }

            const channelsHTML = channels.map(channel => {
                const lastMsg = channel.messages[channel.messages.length - 1];
                const preview = lastMsg?.body ? (lastMsg.body.length > 30 ? lastMsg.body.substring(0, 30) + '...' : lastMsg.body) : 'No messages';
                const time = formatSlackTimestamp(lastMsg?.timestamp);
                const isActive = currentChannelId === channel.channelId;
                
                return `
                    <div class="slack-channel-item ${isActive ? 'active' : ''}" data-channel-id="${channel.channelId}">
                        <div class="slack-channel-name">${channel.channelName}</div>
                        <div class="slack-channel-preview">${preview}</div>
                        <div class="slack-channel-meta">
                            <span class="slack-channel-count">${channel.messages.length} msgs</span>
                            <span class="slack-channel-time">${time}</span>
                </div>
                    </div>
                `;
            }).join('');

            slackChannelsList.innerHTML = channelsHTML;

            // Add click handlers
            document.querySelectorAll('.slack-channel-item').forEach(item => {
                item.addEventListener('click', () => {
                    const channelId = item.dataset.channelId;
                    selectChannel(channelId);
                });
            });
        }

        function selectChannel(channelId) {
            currentChannelId = channelId;
            const channel = messagesByChannel[channelId];
            if (!channel) return;

            slackCurrentChannel.textContent = channel.channelName;
            slackCount.textContent = `${channel.messages.length} messages`;

            // Render messages for this channel
            renderSlackMessages(channel.messages);

            // Show input area
            const inputContainer = document.getElementById('slackInputContainer');
            if (inputContainer) {
                inputContainer.style.display = 'block';
            }

            // Update active state
            document.querySelectorAll('.slack-channel-item').forEach(item => {
                item.classList.toggle('active', item.dataset.channelId === channelId);
            });

            // Focus input
            const messageInput = document.getElementById('slackMessageInput');
            if (messageInput) {
                messageInput.focus();
            }
        }

        function renderSlackMessages(messages) {
            if (!messages || messages.length === 0) {
                slackMessagesContainer.innerHTML = '<div class="slack-empty-state"><p>No messages in this channel</p></div>';
                return;
            }

            let lastUserId = null;
            let lastDate = null;
            const messagesHTML = messages.map((msg, index) => {
                const msgDate = new Date(msg.timestamp || Date.now());
                const currentDate = msgDate.toDateString();
                const showDateDivider = lastDate !== currentDate;
                lastDate = currentDate;

                const showAvatar = lastUserId !== msg.from_id;
                lastUserId = msg.from_id;

                const initials = getInitials(msg.from_name || msg.from_id);
                const avatarColor = getAvatarColor(msg.from_name || msg.from_id);
                const timeStr = formatSlackTime(msg.timestamp);
                const formattedBody = formatSlackMessage(msg.body || '');

                let html = '';
                
                // Date divider
                if (showDateDivider) {
                    const dateStr = msgDate.toLocaleDateString('en-US', { 
                        weekday: 'long', 
                        year: 'numeric', 
                        month: 'long', 
                        day: 'numeric' 
                    });
                    html += `<div class="slack-date-divider"><span>${dateStr}</span></div>`;
                }

                // Message
                html += `
                    <div class="slack-message ${showAvatar ? 'show-avatar' : ''}" data-message-id="${msg.message_id}">
                        ${showAvatar ? `
                            <div class="slack-avatar" style="background-color: ${avatarColor}">
                                ${initials}
                            </div>
                        ` : '<div class="slack-avatar-spacer"></div>'}
                        <div class="slack-message-content">
                            ${showAvatar ? `
                                <div class="slack-message-header">
                                    <span class="slack-username">${msg.from_name || msg.from_id || 'Unknown'}</span>
                                    <span class="slack-timestamp">${timeStr}</span>
                                </div>
                            ` : ''}
                            <div class="slack-message-body">${formattedBody || '<em>No content</em>'}</div>
                        </div>
                    </div>
                `;

                return html;
            }).join('');

            slackMessagesContainer.innerHTML = messagesHTML;
            slackMessagesContainer.scrollTop = slackMessagesContainer.scrollHeight;
        }

        function updateSlackCount() {
            if (!slackCount) return;
            const total = Object.values(messagesByChannel).reduce((sum, ch) => sum + ch.messages.length, 0);
            slackCount.textContent = `${total} total messages`;
        }

        async function loadSlackMessages() {
            slackViewButton.disabled = true;
            slackViewButton.textContent = 'Loading...';
            allSlackMessages = [];
            messagesByChannel = {};
            currentChannelId = null;
            totalSlackCount = 0;

            try {
                console.log('[*] Requesting Slack messages from backend...');
                const response = await fetch('http://localhost:8000/api/slack/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        limit: 50  // Reduced from 200 to 50 for faster loading
                    })
                });

                console.log('[*] Response status:', response.status);
                const data = await response.json();
                console.log('[*] Response data:', data);

                if (response.ok && data.success) {
                    allSlackMessages = data.messages || [];
                    totalSlackCount = typeof data.total_count === 'number' ? data.total_count : allSlackMessages.length;
                    
                    // Group messages by channel
                    messagesByChannel = groupMessagesByChannel(allSlackMessages);
                    
                    // Render channels sidebar
                    renderSlackChannels();
                    
                    // Auto-select first channel if available
                    const channels = Object.keys(messagesByChannel);
                    if (channels.length > 0) {
                        selectChannel(channels[0]);
                    } else {
                        slackMessagesContainer.innerHTML = '<div class="slack-empty-state"><p>No messages found</p></div>';
                    }
                    
                    updateSlackCount();
                    console.log(`[OK] Got ${allSlackMessages.length} Slack messages in ${channels.length} channels`);
                } else {
                    const errorMsg = data.error || data.detail || JSON.stringify(data);
                    console.error('[!] Backend error:', errorMsg);
                    slackMessagesContainer.innerHTML = `<div class="slack-empty-state"><div class="slack-empty-icon">‚ö†Ô∏è</div><h3>Error</h3><p>${errorMsg}</p></div>`;
                    slackChannelsList.innerHTML = '<div class="slack-sidebar-empty">Error loading channels</div>';
                    if (slackCount) slackCount.textContent = 'Error';
                }
            } catch (error) {
                console.error('[!] Exception:', error);
                slackMessagesContainer.innerHTML = `<div class="slack-empty-state"><div class="slack-empty-icon">‚ö†Ô∏è</div><h3>Error</h3><p>Exception: ${error.message}</p></div>`;
                slackChannelsList.innerHTML = '<div class="slack-sidebar-empty">Error loading channels</div>';
                if (slackCount) slackCount.textContent = 'Error';
            }

            slackViewButton.disabled = false;
            slackViewButton.textContent = 'Refresh';
        }

        slackViewButton.addEventListener('click', loadSlackMessages);

        // Word Document Management
        const createWordDocButton = document.getElementById('createWordDocButton');
        const openWordDocButton = document.getElementById('openWordDocButton');
        const wordCreateModal = document.getElementById('wordCreateModal');
        const wordOpenModal = document.getElementById('wordOpenModal');
        const wordCreateModalClose = document.getElementById('wordCreateModalClose');
        const wordOpenModalClose = document.getElementById('wordOpenModalClose');
        const wordCreateCancel = document.getElementById('wordCreateCancel');
        const wordOpenCancel = document.getElementById('wordOpenCancel');
        const wordCreateSubmit = document.getElementById('wordCreateSubmit');
        const wordOpenSubmit = document.getElementById('wordOpenSubmit');
        const wordDocumentArea = document.getElementById('wordDocumentArea');
        const wordFilePathBrowse = document.getElementById('wordFilePathBrowse');
        const wordFilePathInput = document.getElementById('wordFilePathInput');
        const wordOpenFilePathBrowse = document.getElementById('wordOpenFilePathBrowse');
        const wordOpenFilePathInput = document.getElementById('wordOpenFilePathInput');

        // Browse button for opening documents - use native file picker
        if (wordOpenFilePathBrowse && wordOpenFilePathInput) {
            wordOpenFilePathBrowse.addEventListener('click', async () => {
                try {
                    const filePathInput = document.getElementById('wordOpenFilePath');
                    if (!filePathInput) return;
                    
                    // Get initial directory
                    const defaultPath = await getDefaultDocumentsPath();
                    const initialDir = filePathInput.value.trim() ? 
                        filePathInput.value.substring(0, filePathInput.value.lastIndexOf('\\')) : 
                        defaultPath;
                    
                    // Call backend to open native file picker
                    const response = await fetch(`http://localhost:8000/api/word/select-file?initial_path=${encodeURIComponent(initialDir)}`);
                    
                    if (!response.ok) {
                        throw new Error(`Failed to open file picker: ${response.status}`);
                    }
                    
                    const result = await response.json();
                    
                    if (result.success && result.file_path) {
                        filePathInput.value = result.file_path;
                        console.log('File selected:', result.file_path);
                    } else if (!result.cancelled) {
                        // Only show error if not cancelled by user
                        const errorMsg = result.error || 'Failed to select file';
                        console.error('File picker error:', errorMsg);
                        alert(`Error selecting file: ${errorMsg}`);
                    }
                } catch (error) {
                    console.error('Error opening file picker:', error);
                    alert(`Error opening file picker: ${error.message}`);
                }
            });
        }
        
        // Helper function to get default Documents path
        async function getDefaultDocumentsPath() {
            try {
                const response = await fetch('http://localhost:8000/api/word/list-directory');
                const data = await response.json();
                if (data.success && data.path) {
                    return data.path;
                }
            } catch (error) {
                console.error('Error getting default path:', error);
            }
            // Fallback to D: drive instead of C: drive
            return 'D:\\Documents';
        }

        // Browse button for creating documents
        if (wordFilePathBrowse && wordFilePathInput) {
            wordFilePathBrowse.addEventListener('click', async () => {
                const filePathInput = document.getElementById('wordFilePath');
                if (filePathInput) {
                    if (!filePathInput.value.trim()) {
                        // Get default Documents path from server
                        const defaultPath = await getDefaultDocumentsPath();
                        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
                        const suggestedPath = `${defaultPath}\\document_${timestamp}.docx`;
                        filePathInput.value = suggestedPath;
                    }
                    filePathInput.focus();
                    filePathInput.select();
                }
            });
        }

        // Store current document state
        let currentWordDocument = {
            filePath: null,
            title: null,
            content: ''
        };

        // Function to open Word editor
        function openWordEditor(filePath, title, initialContent) {
            currentWordDocument.filePath = filePath;
            currentWordDocument.title = title;
            currentWordDocument.content = initialContent;
            
            // Convert plain text content to HTML
            // Replace newlines with <div> tags for proper paragraph display
            let htmlContent = '';
            if (initialContent) {
                // Escape HTML special characters to prevent injection
                const escapeHtml = (text) => {
                    const div = document.createElement('div');
                    div.textContent = text;
                    return div.innerHTML;
                };
                
                // Split by newlines and wrap each line in a div
                const lines = initialContent.split('\n');
                htmlContent = lines.map(line => {
                    const escapedLine = escapeHtml(line);
                    // Use <br> for empty lines to preserve them
                    return `<div>${escapedLine || '<br>'}</div>`;
                }).join('');
            }
            
            if (wordDocumentArea) {
                const fileName = filePath.split('\\').pop() || filePath.split('/').pop() || 'Document';
                wordDocumentArea.innerHTML = `
                    <div class="word-editor-container">
                        <div class="word-editor-toolbar">
                            <!-- File Operations -->
                            <div class="word-editor-toolbar-group">
                                <button class="word-editor-btn" id="wordEditorNew" title="New Document">üìÑ New</button>
                                <button class="word-editor-btn" id="wordEditorOpen" title="Open Document">üìÇ Open</button>
                                <button class="word-editor-btn word-editor-btn-primary" id="wordEditorSave" title="Save (Ctrl+S)">üíæ Save</button>
                            </div>
                            
                            <!-- Text Formatting -->
                            <div class="word-editor-toolbar-group">
                                <button class="word-editor-btn" id="wordEditorBold" title="Bold (Ctrl+B)"><strong>B</strong></button>
                                <button class="word-editor-btn" id="wordEditorItalic" title="Italic (Ctrl+I)"><em>I</em></button>
                                <button class="word-editor-btn" id="wordEditorUnderline" title="Underline (Ctrl+U)"><u>U</u></button>
                                <button class="word-editor-btn" id="wordEditorStrikethrough" title="Strikethrough"><s>S</s></button>
                                <button class="word-editor-btn" id="wordEditorSubscript" title="Subscript">x‚ÇÇ</button>
                                <button class="word-editor-btn" id="wordEditorSuperscript" title="Superscript">x¬≤</button>
                            </div>
                            
                            <!-- Font Controls -->
                            <div class="word-editor-toolbar-group">
                                <select class="word-editor-select" id="wordEditorFontSize" title="Font Size">
                                    <option value="8">8</option>
                                    <option value="9">9</option>
                                    <option value="10">10</option>
                                    <option value="11">11</option>
                                    <option value="12" selected>12</option>
                                    <option value="14">14</option>
                                    <option value="16">16</option>
                                    <option value="18">18</option>
                                    <option value="20">20</option>
                                    <option value="24">24</option>
                                    <option value="28">28</option>
                                    <option value="36">36</option>
                                    <option value="48">48</option>
                                    <option value="72">72</option>
                                </select>
                                <select class="word-editor-select" id="wordEditorFontFamily" title="Font Family">
                                    <option value="Arial">Arial</option>
                                    <option value="Times New Roman">Times New Roman</option>
                                    <option value="Calibri" selected>Calibri</option>
                                    <option value="Courier New">Courier New</option>
                                    <option value="Verdana">Verdana</option>
                                    <option value="Georgia">Georgia</option>
                                    <option value="Comic Sans MS">Comic Sans MS</option>
                                    <option value="Impact">Impact</option>
                                    <option value="Trebuchet MS">Trebuchet MS</option>
                                    <option value="Tahoma">Tahoma</option>
                                </select>
                                <input type="color" id="wordEditorTextColor" title="Text Color" value="#000000" style="width: 40px; height: 28px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                                <button class="word-editor-btn" id="wordEditorHighlight" title="Highlight">üñçÔ∏è</button>
                            </div>
                            
                            <!-- Paragraph Formatting -->
                            <div class="word-editor-toolbar-group">
                                <button class="word-editor-btn" id="wordEditorAlignLeft" title="Align Left">‚¨Ö</button>
                                <button class="word-editor-btn" id="wordEditorAlignCenter" title="Align Center">‚¨å</button>
                                <button class="word-editor-btn" id="wordEditorAlignRight" title="Align Right">‚û°</button>
                                <button class="word-editor-btn" id="wordEditorAlignJustify" title="Justify">‚¨å‚¨å</button>
                                <button class="word-editor-btn" id="wordEditorBullets" title="Bullets">‚Ä¢ List</button>
                                <button class="word-editor-btn" id="wordEditorNumbering" title="Numbering">1. List</button>
                                <button class="word-editor-btn" id="wordEditorIndentDecrease" title="Decrease Indent">‚´∏</button>
                                <button class="word-editor-btn" id="wordEditorIndentIncrease" title="Increase Indent">‚´∑</button>
                            </div>
                            
                            <!-- Insert Options -->
                            <div class="word-editor-toolbar-group">
                                <button class="word-editor-btn" id="wordEditorInsertImage" title="Insert Image">üñºÔ∏è Image</button>
                                <button class="word-editor-btn" id="wordEditorInsertLink" title="Insert Hyperlink">üîó Link</button>
                                <button class="word-editor-btn" id="wordEditorInsertPageBreak" title="Page Break">üìÑ Page</button>
                            </div>
                            
                            <!-- Headings -->
                            <div class="word-editor-toolbar-group">
                                <select class="word-editor-select" id="wordEditorHeading" title="Heading Style" style="width: 120px;">
                                    <option value="">Normal</option>
                                    <option value="h1">Heading 1</option>
                                    <option value="h2">Heading 2</option>
                                    <option value="h3">Heading 3</option>
                                    <option value="h4">Heading 4</option>
                                    <option value="h5">Heading 5</option>
                                    <option value="h6">Heading 6</option>
                                </select>
                            </div>
                            
                            <!-- Document Tools -->
                            <div class="word-editor-toolbar-group">
                                <button class="word-editor-btn" id="wordEditorFindReplace" title="Find & Replace">üîç Find</button>
                                <button class="word-editor-btn" id="wordEditorWordCount" title="Word Count">üìä Count</button>
                                <button class="word-editor-btn" id="wordEditorPageSetup" title="Page Setup">üìê Setup</button>
                            </div>
                        </div>
                        <div class="word-editor-header">
                            <div class="word-editor-title">
                                <span style="font-weight: 600;">üìÑ ${fileName}</span>
                                <span style="font-size: 12px; color: #666; margin-left: 12px;">${filePath}</span>
                            </div>
                        </div>
                        <div class="word-editor-content-wrapper">
                            <div 
                                class="word-editor-content" 
                                id="wordEditorContent" 
                                contenteditable="true"
                                style="min-height: 500px; padding: 20px; background: white; border: 1px solid #ddd; border-radius: 4px; outline: none; font-family: 'Calibri', 'Arial', sans-serif; font-size: 12pt; line-height: 1.5;"
                            >${htmlContent || '<div><br></div>'}</div>
                        </div>
                    </div>
                `;
                
                // Set up editor event listeners
                setupWordEditor();
            }
        }

        // Function to set up Word editor event listeners
        function setupWordEditor() {
            const editorContent = document.getElementById('wordEditorContent');
            const saveBtn = document.getElementById('wordEditorSave');
            const boldBtn = document.getElementById('wordEditorBold');
            const italicBtn = document.getElementById('wordEditorItalic');
            const underlineBtn = document.getElementById('wordEditorUnderline');
            const alignLeftBtn = document.getElementById('wordEditorAlignLeft');
            const alignCenterBtn = document.getElementById('wordEditorAlignCenter');
            const alignRightBtn = document.getElementById('wordEditorAlignRight');
            const fontSizeSelect = document.getElementById('wordEditorFontSize');
            const fontFamilySelect = document.getElementById('wordEditorFontFamily');

            // Save functionality - show Save As dialog
            // NOTE: No auto-save functionality. Files are only saved when user explicitly:
            // 1. Clicks the Save button, or
            // 2. Presses Ctrl+S while editor is focused
            if (saveBtn && editorContent) {
                saveBtn.addEventListener('click', () => {
                    showSaveAsDialog();
                });
            }

            // Format buttons
            if (boldBtn && editorContent) {
                boldBtn.addEventListener('click', () => {
                    document.execCommand('bold', false, null);
                    editorContent.focus();
                });
            }

            if (italicBtn && editorContent) {
                italicBtn.addEventListener('click', () => {
                    document.execCommand('italic', false, null);
                    editorContent.focus();
                });
            }

            if (underlineBtn && editorContent) {
                underlineBtn.addEventListener('click', () => {
                    document.execCommand('underline', false, null);
                    editorContent.focus();
                });
            }

            // Alignment buttons
            if (alignLeftBtn && editorContent) {
                alignLeftBtn.addEventListener('click', () => {
                    document.execCommand('justifyLeft', false, null);
                    editorContent.focus();
                });
            }

            if (alignCenterBtn && editorContent) {
                alignCenterBtn.addEventListener('click', () => {
                    document.execCommand('justifyCenter', false, null);
                    editorContent.focus();
                });
            }

            if (alignRightBtn && editorContent) {
                alignRightBtn.addEventListener('click', () => {
                    document.execCommand('justifyRight', false, null);
                    editorContent.focus();
                });
            }

            // Font size
            if (fontSizeSelect && editorContent) {
                fontSizeSelect.addEventListener('change', (e) => {
                    document.execCommand('fontSize', false, e.target.value);
                    editorContent.focus();
                });
            }

            // Font family
            if (fontFamilySelect && editorContent) {
                fontFamilySelect.addEventListener('change', (e) => {
                    document.execCommand('fontName', false, e.target.value);
                    editorContent.focus();
                });
            }

            // Additional formatting buttons
            const strikethroughBtn = document.getElementById('wordEditorStrikethrough');
            const subscriptBtn = document.getElementById('wordEditorSubscript');
            const superscriptBtn = document.getElementById('wordEditorSuperscript');
            const textColorInput = document.getElementById('wordEditorTextColor');
            const highlightBtn = document.getElementById('wordEditorHighlight');
            const alignJustifyBtn = document.getElementById('wordEditorAlignJustify');
            const bulletsBtn = document.getElementById('wordEditorBullets');
            const numberingBtn = document.getElementById('wordEditorNumbering');
            const indentDecreaseBtn = document.getElementById('wordEditorIndentDecrease');
            const indentIncreaseBtn = document.getElementById('wordEditorIndentIncrease');
            const headingSelect = document.getElementById('wordEditorHeading');
            const insertImageBtn = document.getElementById('wordEditorInsertImage');
            const insertLinkBtn = document.getElementById('wordEditorInsertLink');
            const insertPageBreakBtn = document.getElementById('wordEditorInsertPageBreak');
            const findReplaceBtn = document.getElementById('wordEditorFindReplace');
            const wordCountBtn = document.getElementById('wordEditorWordCount');
            const pageSetupBtn = document.getElementById('wordEditorPageSetup');
            const newDocBtn = document.getElementById('wordEditorNew');
            const openDocBtn = document.getElementById('wordEditorOpen');

            // Strikethrough
            if (strikethroughBtn && editorContent) {
                strikethroughBtn.addEventListener('click', () => {
                    document.execCommand('strikeThrough', false, null);
                    editorContent.focus();
                });
            }

            // Subscript
            if (subscriptBtn && editorContent) {
                subscriptBtn.addEventListener('click', () => {
                    document.execCommand('subscript', false, null);
                    editorContent.focus();
                });
            }

            // Superscript
            if (superscriptBtn && editorContent) {
                superscriptBtn.addEventListener('click', () => {
                    document.execCommand('superscript', false, null);
                    editorContent.focus();
                });
            }

            // Text color
            if (textColorInput && editorContent) {
                textColorInput.addEventListener('change', (e) => {
                    document.execCommand('foreColor', false, e.target.value);
                    editorContent.focus();
                });
            }

            // Highlight
            if (highlightBtn && editorContent) {
                highlightBtn.addEventListener('click', () => {
                    const color = prompt('Enter highlight color (e.g., yellow, #FFFF00):', 'yellow');
                    if (color) {
                        document.execCommand('backColor', false, color);
                    }
                    editorContent.focus();
                });
            }

            // Justify alignment
            if (alignJustifyBtn && editorContent) {
                alignJustifyBtn.addEventListener('click', () => {
                    document.execCommand('justifyFull', false, null);
                    editorContent.focus();
                });
            }

            // Bullets
            if (bulletsBtn && editorContent) {
                bulletsBtn.addEventListener('click', () => {
                    document.execCommand('insertUnorderedList', false, null);
                    editorContent.focus();
                });
            }

            // Numbering
            if (numberingBtn && editorContent) {
                numberingBtn.addEventListener('click', () => {
                    document.execCommand('insertOrderedList', false, null);
                    editorContent.focus();
                });
            }

            // Indent decrease
            if (indentDecreaseBtn && editorContent) {
                indentDecreaseBtn.addEventListener('click', () => {
                    document.execCommand('outdent', false, null);
                    editorContent.focus();
                });
            }

            // Indent increase
            if (indentIncreaseBtn && editorContent) {
                indentIncreaseBtn.addEventListener('click', () => {
                    document.execCommand('indent', false, null);
                    editorContent.focus();
                });
            }

            // Heading style
            if (headingSelect && editorContent) {
                headingSelect.addEventListener('change', (e) => {
                    const heading = e.target.value;
                    if (heading) {
                        document.execCommand('formatBlock', false, `<${heading}>`);
                    } else {
                        document.execCommand('formatBlock', false, '<p>');
                    }
                    editorContent.focus();
                });
            }

            // Insert image
            if (insertImageBtn && editorContent) {
                insertImageBtn.addEventListener('click', () => {
                    const url = prompt('Enter image URL:', '');
                    if (url) {
                        const img = document.createElement('img');
                        img.src = url;
                        img.style.maxWidth = '100%';
                        img.style.height = 'auto';
                        const selection = window.getSelection();
                        if (selection.rangeCount > 0) {
                            selection.getRangeAt(0).insertNode(img);
                        } else {
                            editorContent.appendChild(img);
                        }
                        editorContent.focus();
                    }
                });
            }

            // Insert hyperlink
            if (insertLinkBtn && editorContent) {
                insertLinkBtn.addEventListener('click', () => {
                    const url = prompt('Enter URL:', 'https://');
                    const text = prompt('Enter link text:', '');
                    if (url && text) {
                        const link = document.createElement('a');
                        link.href = url;
                        link.textContent = text;
                        link.target = '_blank';
                        const selection = window.getSelection();
                        if (selection.rangeCount > 0) {
                            selection.getRangeAt(0).insertNode(link);
                        } else {
                            editorContent.appendChild(link);
                        }
                        editorContent.focus();
                    }
                });
            }

            // Insert page break
            if (insertPageBreakBtn && editorContent) {
                insertPageBreakBtn.addEventListener('click', () => {
                    const pageBreak = document.createElement('div');
                    pageBreak.style.pageBreakAfter = 'always';
                    pageBreak.style.borderTop = '2px dashed #ccc';
                    pageBreak.style.margin = '20px 0';
                    pageBreak.innerHTML = '<br>';
                    const selection = window.getSelection();
                    if (selection.rangeCount > 0) {
                        selection.getRangeAt(0).insertNode(pageBreak);
                    } else {
                        editorContent.appendChild(pageBreak);
                    }
                    editorContent.focus();
                });
            }

            // Find & Replace
            if (findReplaceBtn && editorContent) {
                findReplaceBtn.addEventListener('click', () => {
                    const find = prompt('Find:', '');
                    if (find) {
                        const replace = prompt('Replace with:', '');
                        const content = editorContent.innerHTML;
                        editorContent.innerHTML = content.replace(new RegExp(find, 'gi'), replace || '');
                        editorContent.focus();
                    }
                });
            }

            // Word count
            if (wordCountBtn && editorContent) {
                wordCountBtn.addEventListener('click', () => {
                    const text = editorContent.innerText || editorContent.textContent || '';
                    const words = text.trim().split(/\s+/).filter(w => w.length > 0);
                    const chars = text.length;
                    const charsNoSpaces = text.replace(/\s/g, '').length;
                    alert(`Word Count:\n\nWords: ${words.length}\nCharacters (with spaces): ${chars}\nCharacters (no spaces): ${charsNoSpaces}`);
                });
            }

            // Page setup
            if (pageSetupBtn && editorContent) {
                pageSetupBtn.addEventListener('click', () => {
                    alert('Page Setup:\n\nThis feature will be implemented with backend API integration.\n\nYou can configure:\n- Page size (A4, Letter, etc.)\n- Margins\n- Orientation (Portrait/Landscape)');
                });
            }

            // New document
            if (newDocBtn) {
                newDocBtn.addEventListener('click', async () => {
                    if (confirm('Create a new document? Unsaved changes will be lost.')) {
                        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
                        const defaultPath = await getDefaultDocumentsPath();
                        const filePath = `${defaultPath}\\document_${timestamp}.docx`;
                        openWordEditor(filePath, 'New Document', '');
                    }
                });
            }

            // Open document
            if (openDocBtn) {
                openDocBtn.addEventListener('click', () => {
                    const wordOpenModal = document.getElementById('wordOpenModal');
                    if (wordOpenModal) {
                        wordOpenModal.style.display = 'flex';
                    }
                });
            }

            // Keyboard shortcuts
            if (editorContent) {
                editorContent.addEventListener('keydown', (e) => {
                    // Ctrl+S to save (only when editor has focus and user explicitly presses Ctrl+S)
                    if (e.ctrlKey && e.key === 's' && document.activeElement === editorContent) {
                        e.preventDefault();
                        e.stopPropagation();
                        showSaveAsDialog();
                    }
                    // Ctrl+B for bold
                    if (e.ctrlKey && e.key === 'b') {
                        e.preventDefault();
                        document.execCommand('bold', false, null);
                    }
                    // Ctrl+I for italic
                    if (e.ctrlKey && e.key === 'i') {
                        e.preventDefault();
                        document.execCommand('italic', false, null);
                    }
                    // Ctrl+U for underline
                    if (e.ctrlKey && e.key === 'u') {
                        e.preventDefault();
                        document.execCommand('underline', false, null);
                    }
                });
            }
        }

        // Function to show Save As dialog
        async function showSaveAsDialog() {
            const saveAsModal = document.getElementById('wordSaveAsModal');
            const saveAsFolderPath = document.getElementById('wordSaveAsFolderPath');
            const saveAsFileName = document.getElementById('wordSaveAsFileName');
            
            if (saveAsModal && saveAsFolderPath && saveAsFileName) {
                // Pre-fill with current file path if available
                if (currentWordDocument.filePath) {
                    const fullPath = currentWordDocument.filePath;
                    const lastSeparator = Math.max(fullPath.lastIndexOf('\\'), fullPath.lastIndexOf('/'));
                    if (lastSeparator > 0) {
                        saveAsFolderPath.value = fullPath.substring(0, lastSeparator);
                        saveAsFileName.value = fullPath.substring(lastSeparator + 1);
                    } else {
                        saveAsFolderPath.value = '';
                        saveAsFileName.value = fullPath;
                    }
                } else {
                    // Generate default path
                    try {
                        const defaultPath = await getDefaultDocumentsPath();
                        saveAsFolderPath.value = defaultPath;
                        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
                        saveAsFileName.value = `document_${timestamp}.docx`;
                    } catch (error) {
                        console.error('Error getting default path:', error);
                        // Fallback
                        saveAsFolderPath.value = 'D:\\Documents';
                        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
                        saveAsFileName.value = `document_${timestamp}.docx`;
                    }
                }
                saveAsModal.style.display = 'flex';
                // Small delay to ensure modal is visible before focusing
                setTimeout(() => {
                    saveAsFileName.focus();
                    saveAsFileName.select();
                }, 100);
            }
        }

        // Set up Save As dialog event listeners
        const wordSaveAsModal = document.getElementById('wordSaveAsModal');
        const wordSaveAsModalClose = document.getElementById('wordSaveAsModalClose');
        const wordSaveAsCancel = document.getElementById('wordSaveAsCancel');
        const wordSaveAsSubmit = document.getElementById('wordSaveAsSubmit');
        const wordSaveAsFolderPath = document.getElementById('wordSaveAsFolderPath');
        const wordSaveAsFileName = document.getElementById('wordSaveAsFileName');
        const wordSaveAsFolderPathBrowse = document.getElementById('wordSaveAsFolderPathBrowse');

        // Close Save As modal
        if (wordSaveAsModalClose) {
            wordSaveAsModalClose.addEventListener('click', () => {
                if (wordSaveAsModal) wordSaveAsModal.style.display = 'none';
            });
        }

        if (wordSaveAsCancel) {
            wordSaveAsCancel.addEventListener('click', () => {
                if (wordSaveAsModal) wordSaveAsModal.style.display = 'none';
            });
        }

        // Folder browser state
        let currentFolderBrowserPath = null;
        let selectedFolderPath = null;

        // Browse button for Save As - use native Windows folder picker
        if (wordSaveAsFolderPathBrowse) {
            wordSaveAsFolderPathBrowse.addEventListener('click', async () => {
                await openNativeFolderPicker();
            });
        }

        // Function to open native Windows folder picker via backend
        async function openNativeFolderPicker() {
            const currentPath = wordSaveAsFolderPath?.value.trim() || null;
            
            try {
                const url = currentPath ? 
                    `http://localhost:8000/api/word/select-folder?initial_path=${encodeURIComponent(currentPath)}` :
                    'http://localhost:8000/api/word/select-folder';
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.success && data.folder_path) {
                    // User selected a folder
                    if (wordSaveAsFolderPath) {
                        wordSaveAsFolderPath.value = data.folder_path;
                    }
                } else if (data.cancelled) {
                    // User cancelled - do nothing
                    console.log('Folder selection cancelled');
                } else {
                    // Error occurred
                    alert('Error selecting folder: ' + (data.detail || data.message || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error opening folder picker:', error);
                alert('Error opening folder picker: ' + error.message + '\n\nFalling back to manual entry.');
                // Fallback: focus the input so user can type manually
                if (wordSaveAsFolderPath) {
                    wordSaveAsFolderPath.focus();
                }
            }
        }

        // Function to open folder browser dialog
        async function openFolderBrowserDialog() {
            const folderBrowserDialog = document.getElementById('wordFolderBrowserDialog');
            if (!folderBrowserDialog) return;

            // Get initial path from input or use default
            let initialPath = wordSaveAsFolderPath?.value.trim();
            if (!initialPath) {
                try {
                    initialPath = await getDefaultDocumentsPath();
                } catch (error) {
                    initialPath = 'D:\\Documents';
                }
            }

            currentFolderBrowserPath = initialPath;
            selectedFolderPath = initialPath;
            folderBrowserDialog.style.display = 'flex';
            loadFolderBrowserDirectory(initialPath);
        }

        // Function to load directory in folder browser
        async function loadFolderBrowserDirectory(path = null) {
            const folderBrowserContent = document.getElementById('wordFolderBrowserContent');
            const folderBrowserPathBreadcrumb = document.getElementById('wordFolderBrowserPathBreadcrumb');
            
            if (!folderBrowserContent) return;

            try {
                const url = path ? 
                    `http://localhost:8000/api/word/list-directory?path=${encodeURIComponent(path)}` :
                    'http://localhost:8000/api/word/list-directory';
                
                const response = await fetch(url);
                const data = await response.json();

                if (data.success) {
                    currentFolderBrowserPath = data.path;
                    selectedFolderPath = data.path;
                    updateFolderBrowserPathBreadcrumb(data.path);
                    
                    // Clear and populate content - only show directories
                    folderBrowserContent.innerHTML = '';

                    // Add parent directory row if available
                    if (data.parent_path) {
                        const parentRow = document.createElement('div');
                        parentRow.style.cssText = 'display: flex; align-items: center; gap: 8px; padding: 8px 16px; cursor: pointer; border-bottom: 1px solid #f0f0f0; transition: background 0.15s;';
                        parentRow.innerHTML = `
                            <span style="font-size: 20px;">üìÅ</span>
                            <span style="font-size: 14px; color: #333; font-weight: 500;">.. (Parent Folder)</span>
                        `;
                        parentRow.addEventListener('click', () => {
                            loadFolderBrowserDirectory(data.parent_path);
                        });
                        parentRow.addEventListener('mouseenter', () => {
                            parentRow.style.background = '#e8f4f8';
                        });
                        parentRow.addEventListener('mouseleave', () => {
                            parentRow.style.background = 'transparent';
                        });
                        folderBrowserContent.appendChild(parentRow);
                    }

                    // Add directories only
                    const directories = data.items.filter(item => item.is_directory);
                    directories.forEach(item => {
                        const row = createFolderBrowserRow(item, data.path);
                        folderBrowserContent.appendChild(row);
                    });

                    // Update navigation buttons
                    const navUpBtn = document.getElementById('wordFolderBrowserNavUp');
                    if (navUpBtn) {
                        navUpBtn.disabled = !data.parent_path;
                        navUpBtn.style.opacity = !data.parent_path ? '0.5' : '1';
                    }
                } else {
                    const errorMsg = data.detail || data.message || data.error || 'Unknown error';
                    folderBrowserContent.innerHTML = `
                        <div style="padding: 40px; text-align: center; color: #d32f2f;">
                            <div style="font-size: 48px; margin-bottom: 16px;">‚ö†Ô∏è</div>
                            <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">Error Loading Directory</div>
                            <div style="font-size: 14px; color: #666;">${errorMsg}</div>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('Error loading directory:', error);
                folderBrowserContent.innerHTML = `
                    <div style="padding: 40px; text-align: center; color: #d32f2f;">
                        <div style="font-size: 48px; margin-bottom: 16px;">‚ö†Ô∏è</div>
                        <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">Network Error</div>
                        <div style="font-size: 14px; color: #666;">${error.message || 'Failed to connect to server'}</div>
                    </div>
                `;
            }
        }

        // Create a folder row for the folder browser
        function createFolderBrowserRow(item, currentPath) {
            const row = document.createElement('div');
            row.style.cssText = 'display: flex; align-items: center; gap: 8px; padding: 8px 16px; cursor: pointer; border-bottom: 1px solid #f0f0f0; transition: background 0.15s;';
            
            row.innerHTML = `
                <span style="font-size: 20px;">üìÅ</span>
                <span style="font-size: 14px; color: #333;" title="${item.path}">${item.name}</span>
            `;

            row.addEventListener('click', () => {
                // Navigate into the folder
                loadFolderBrowserDirectory(item.path);
            });

            row.addEventListener('dblclick', () => {
                // Double-click to select and use this folder
                selectedFolderPath = item.path;
                if (wordSaveAsFolderPath) {
                    wordSaveAsFolderPath.value = item.path;
                }
                const folderBrowserDialog = document.getElementById('wordFolderBrowserDialog');
                if (folderBrowserDialog) folderBrowserDialog.style.display = 'none';
            });

            row.addEventListener('mouseenter', () => {
                row.style.background = '#e8f4f8';
            });
            row.addEventListener('mouseleave', () => {
                row.style.background = 'transparent';
            });

            return row;
        }

        // Update path breadcrumb in folder browser
        function updateFolderBrowserPathBreadcrumb(path) {
            const breadcrumb = document.getElementById('wordFolderBrowserPathBreadcrumb');
            if (!breadcrumb) return;
            
            const parts = path.split(/[\\/]/).filter(p => p);
            let breadcrumbHTML = '';
            let currentPath = '';
            
            parts.forEach((part, index) => {
                if (index === 0 && path.startsWith('\\')) {
                    currentPath = '\\' + part;
                } else {
                    currentPath = currentPath ? currentPath + '\\' + part : part;
                }
                
                breadcrumbHTML += `<span style="cursor: pointer; color: #0066cc; text-decoration: underline;" data-path="${currentPath}">${part}</span>`;
                if (index < parts.length - 1) {
                    breadcrumbHTML += '<span style="margin: 0 4px; color: #666;">\\</span>';
                }
            });
            
            breadcrumb.innerHTML = breadcrumbHTML || path;
            
            // Add click handlers to breadcrumb parts
            breadcrumb.querySelectorAll('[data-path]').forEach(span => {
                span.addEventListener('click', () => {
                    loadFolderBrowserDirectory(span.getAttribute('data-path'));
                });
            });
        }

        // Folder browser dialog event listeners
        const wordFolderBrowserDialog = document.getElementById('wordFolderBrowserDialog');
        const wordFolderBrowserDialogClose = document.getElementById('wordFolderBrowserDialogClose');
        const wordFolderBrowserCancel = document.getElementById('wordFolderBrowserCancel');
        const wordFolderBrowserSelect = document.getElementById('wordFolderBrowserSelect');
        const wordFolderBrowserNavUp = document.getElementById('wordFolderBrowserNavUp');
        const wordFolderBrowserRefresh = document.getElementById('wordFolderBrowserRefresh');

        // Close folder browser
        if (wordFolderBrowserDialogClose) {
            wordFolderBrowserDialogClose.addEventListener('click', () => {
                if (wordFolderBrowserDialog) wordFolderBrowserDialog.style.display = 'none';
            });
        }

        if (wordFolderBrowserCancel) {
            wordFolderBrowserCancel.addEventListener('click', () => {
                if (wordFolderBrowserDialog) wordFolderBrowserDialog.style.display = 'none';
            });
        }

        // Select folder button
        if (wordFolderBrowserSelect) {
            wordFolderBrowserSelect.addEventListener('click', () => {
                if (selectedFolderPath && wordSaveAsFolderPath) {
                    wordSaveAsFolderPath.value = selectedFolderPath;
                }
                if (wordFolderBrowserDialog) wordFolderBrowserDialog.style.display = 'none';
            });
        }

        // Navigation buttons
        if (wordFolderBrowserNavUp) {
            wordFolderBrowserNavUp.addEventListener('click', async () => {
                if (currentFolderBrowserPath) {
                    try {
                        const response = await fetch(`http://localhost:8000/api/word/list-directory?path=${encodeURIComponent(currentFolderBrowserPath)}`);
                        const data = await response.json();
                        if (data.success && data.parent_path) {
                            loadFolderBrowserDirectory(data.parent_path);
                        }
                    } catch (error) {
                        console.error('Error navigating up:', error);
                    }
                }
            });
        }

        if (wordFolderBrowserRefresh) {
            wordFolderBrowserRefresh.addEventListener('click', () => {
                if (currentFolderBrowserPath) {
                    loadFolderBrowserDirectory(currentFolderBrowserPath);
                }
            });
        }

        // Save As submit
        if (wordSaveAsSubmit) {
            wordSaveAsSubmit.addEventListener('click', async () => {
                const folderPath = wordSaveAsFolderPath?.value.trim();
                const fileName = wordSaveAsFileName?.value.trim();
                
                if (!folderPath) {
                    alert('Please enter a folder path');
                    wordSaveAsFolderPath?.focus();
                    return;
                }

                if (!fileName) {
                    alert('Please enter a file name');
                    wordSaveAsFileName?.focus();
                    return;
                }

                // Ensure the filename ends with .docx
                let finalFileName = fileName;
                if (!finalFileName.toLowerCase().endsWith('.docx')) {
                    finalFileName = finalFileName + '.docx';
                    if (wordSaveAsFileName) wordSaveAsFileName.value = finalFileName;
                }

                // Combine folder path and filename
                // Normalize path separators - ensure we use the EXACT folder path the user selected
                let normalizedFolder = folderPath.trim();
                
                // Remove any quotes that might have been added
                normalizedFolder = normalizedFolder.replace(/^["']|["']$/g, '');
                
                // Replace forward slashes with backslashes for Windows
                normalizedFolder = normalizedFolder.replace(/\//g, '\\');
                
                // Remove trailing slashes but keep the path intact
                normalizedFolder = normalizedFolder.replace(/\\+$/, '');
                
                // Ensure we have a valid folder path (not empty)
                if (!normalizedFolder) {
                    alert('Please select a valid folder path');
                    wordSaveAsFolderPath?.focus();
                    return;
                }
                
                // Validate that the folder path looks valid (starts with a drive letter on Windows)
                if (normalizedFolder.length < 3 || !/^[A-Za-z]:/.test(normalizedFolder)) {
                    console.warn('Folder path might be invalid:', normalizedFolder);
                }
                
                // Construct the full file path using the selected folder
                // Use proper path separator
                const finalPath = `${normalizedFolder}\\${finalFileName}`;

                // Debug: Log the path being used to verify it's correct
                console.log('=== SAVE AS DIALOG ===');
                console.log('Raw folder path input:', folderPath);
                console.log('Normalized folder path:', normalizedFolder);
                console.log('File name:', finalFileName);
                console.log('Final full path:', finalPath);
                console.log('========================');

                // Save the document using the selected folder path
                await saveWordDocument(finalPath);
                
                // Close the modal
                if (wordSaveAsModal) wordSaveAsModal.style.display = 'none';
            });
        }

        // Function to save Word document (called from Save As dialog)
        // NOTE: This function is ONLY called when user explicitly requests to save.
        // There is NO auto-save functionality - files are saved only on user action.
        async function saveWordDocument(savePath = null) {
            const editorContent = document.getElementById('wordEditorContent');
            if (!editorContent) {
                alert('No document to save');
                return;
            }

            // Use provided path (from Save As dialog) or current document path
            const filePath = savePath || currentWordDocument.filePath;
            if (!filePath) {
                alert('Please specify a file path');
                showSaveAsDialog();
                return;
            }
            
            // Debug: Log the file path being used
            console.log('saveWordDocument called with filePath:', filePath);
            console.log('savePath parameter:', savePath);
            console.log('currentWordDocument.filePath:', currentWordDocument.filePath);

            // Get HTML content to preserve formatting
            const htmlContent = editorContent.innerHTML || '';
            
            // Debug: Log the content being saved
            console.log('=== SAVE DEBUG ===');
            console.log('HTML content length:', htmlContent.length);
            console.log('HTML content preview (first 500 chars):', htmlContent.substring(0, 500));
            console.log('Editor element:', editorContent);
            console.log('Editor innerHTML length:', editorContent.innerHTML ? editorContent.innerHTML.length : 0);
            
            // Check if content is empty
            const textContent = editorContent.innerText || editorContent.textContent || '';
            console.log('Text content length:', textContent.length);
            console.log('Text content preview:', textContent.substring(0, 200));
            
            if (!textContent.trim() && !htmlContent.trim()) {
                alert('Document is empty. Please add some content before saving.');
                const saveBtn = document.getElementById('wordEditorSave');
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.textContent = 'üíæ Save';
                }
                return;
            }
            
            // Ensure we have HTML content - use text content as fallback if needed
            let contentToSave = htmlContent;
            if (!htmlContent || htmlContent.trim() === '' || htmlContent.trim() === '<br>') {
                console.warn('Warning: HTML content is empty or minimal, using text content instead');
                // If HTML is empty but text exists, create a simple paragraph
                contentToSave = `<p>${textContent.replace(/\n/g, '</p><p>')}</p>`;
                console.log('Using fallback HTML:', contentToSave);
            }
            
            const saveBtn = document.getElementById('wordEditorSave');
            
            if (saveBtn) {
                saveBtn.disabled = true;
                saveBtn.textContent = 'üíæ Saving...';
            }

            try {
                // Save HTML content with formatting preserved
                console.log('=== SENDING SAVE REQUEST ===');
                console.log('File path:', filePath);
                console.log('Content to save length:', contentToSave.length);
                console.log('Content to save preview:', contentToSave.substring(0, 300));
                
                const saveResponse = await fetch('http://localhost:8000/api/word/save-html', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        file_path: filePath,
                        html_content: contentToSave
                    })
                });
                
                console.log('Save response status:', saveResponse.status);
                console.log('Save response ok:', saveResponse.ok);

                if (!saveResponse.ok) {
                    let errorMessage = `HTTP ${saveResponse.status}: Failed to save document`;
                    try {
                        const errorData = await saveResponse.json();
                        errorMessage = errorData.detail || errorData.message || errorData.error || errorMessage;
                    } catch (e) {
                        // If response is not JSON, use status text
                        errorMessage = `${saveResponse.status}: ${saveResponse.statusText || 'Unknown error'}`;
                    }
                    throw new Error(errorMessage);
                }
                
                const saveData = await saveResponse.json();
                console.log('Save response:', saveData);
                
                if (saveData.success) {
                    // Use the file path from the response if available, otherwise use what we sent
                    const savedPath = saveData.file_path || filePath;
                    
                    // Update current document path
                    currentWordDocument.filePath = savedPath;
                    
                    // Update the editor header to show new path
                    const editorTitle = document.querySelector('.word-editor-title');
                    if (editorTitle) {
                        const fileName = savedPath.split('\\').pop() || savedPath.split('/').pop() || 'Document';
                        editorTitle.innerHTML = `<span style="font-weight: 600;">üìÑ ${fileName}</span><span style="font-size: 12px; color: #666; margin-left: 12px;">${savedPath}</span>`;
                    }
                    
                    // Show success message with the actual saved path
                    alert(`Document saved successfully!\n\nPath: ${savedPath}`);
                    
                    if (saveBtn) {
                        saveBtn.textContent = 'üíæ Saved!';
                        setTimeout(() => {
                            if (saveBtn) {
                                saveBtn.textContent = 'üíæ Save';
                                saveBtn.disabled = false;
                            }
                        }, 2000);
                    }
                } else {
                    throw new Error(saveData.detail || saveData.message || saveData.error || 'Failed to save document');
                }
            } catch (error) {
                console.error('Error saving document:', error);
                alert('Error saving document: ' + error.message);
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.textContent = 'üíæ Save';
                }
            }
        }

        // Open create modal - now directly creates and opens editor
        if (createWordDocButton) {
            createWordDocButton.addEventListener('click', async () => {
                // Generate a default file path
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
                const defaultPath = await getDefaultDocumentsPath();
                const filePath = `${defaultPath}\\document_${timestamp}.docx`;
                
                // Create document with default values
                createWordDocButton.disabled = true;
                createWordDocButton.textContent = 'Creating...';
                
                try {
                    const response = await fetch('http://localhost:8000/api/word/create', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            file_path: filePath,
                            title: 'Untitled Document',
                            content: ''
                        })
                    });

                    const data = await response.json();
                    if (response.ok && data.success) {
                        // Open the document in the editor immediately
                        openWordEditor(filePath, 'Untitled Document', '');
                    } else {
                        const errorMsg = data.detail || data.message || data.error || 'Failed to create document';
                        alert('Error creating document:\n\n' + errorMsg);
                    }
                } catch (error) {
                    console.error('Error creating document:', error);
                    alert('Error creating document: ' + error.message);
                } finally {
                    createWordDocButton.disabled = false;
                    createWordDocButton.textContent = 'Create Document';
                }
            });
        }

        // Open document modal
        if (openWordDocButton) {
            openWordDocButton.addEventListener('click', () => {
                if (wordOpenModal) wordOpenModal.style.display = 'flex';
            });
        }

        // Close modals
        if (wordCreateModalClose) {
            wordCreateModalClose.addEventListener('click', () => {
                if (wordCreateModal) wordCreateModal.style.display = 'none';
            });
        }

        if (wordOpenModalClose) {
            wordOpenModalClose.addEventListener('click', () => {
                if (wordOpenModal) wordOpenModal.style.display = 'none';
            });
        }

        if (wordCreateCancel) {
            wordCreateCancel.addEventListener('click', () => {
                if (wordCreateModal) wordCreateModal.style.display = 'none';
            });
        }

        if (wordOpenCancel) {
            wordOpenCancel.addEventListener('click', () => {
                if (wordOpenModal) wordOpenModal.style.display = 'none';
            });
        }

        // Create document
        if (wordCreateSubmit) {
            wordCreateSubmit.addEventListener('click', async () => {
                const filePath = document.getElementById('wordFilePath')?.value.trim();
                const title = document.getElementById('wordDocTitle')?.value.trim();
                const content = document.getElementById('wordDocContent')?.value.trim();

                if (!filePath) {
                    alert('Please enter a file path (e.g., C:\\Users\\YourName\\Documents\\mydocument.docx)');
                    return;
                }

                // Ensure the path ends with .docx
                if (!filePath.toLowerCase().endsWith('.docx')) {
                    filePath = filePath + '.docx';
                    document.getElementById('wordFilePath').value = filePath;
                }

                wordCreateSubmit.disabled = true;
                wordCreateSubmit.textContent = 'Creating...';

                try {
                    const response = await fetch('http://localhost:8000/api/word/create', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            file_path: filePath,
                            title: title || undefined,
                            content: content || undefined
                        })
                    });

                    const data = await response.json();
                    if (response.ok && data.success) {
                        if (wordCreateModal) wordCreateModal.style.display = 'none';
                        // Clear form
                        if (document.getElementById('wordFilePath')) document.getElementById('wordFilePath').value = '';
                        if (document.getElementById('wordDocTitle')) document.getElementById('wordDocTitle').value = '';
                        if (document.getElementById('wordDocContent')) document.getElementById('wordDocContent').value = '';
                        
                        // Open the document in the editor
                        openWordEditor(filePath, title || 'Untitled Document', content || '');
                    } else {
                        const errorMsg = data.detail || data.message || data.error || 'Failed to create document';
                        console.error('Create document error:', errorMsg);
                        alert('Error creating document:\n\n' + errorMsg + '\n\nPlease check:\n- The file path is correct and writable\n- The directory exists\n- You have permission to write to that location');
                    }
                } catch (error) {
                    console.error('Error creating document:', error);
                    alert('Error creating document: ' + error.message + '\n\nPlease check your network connection and try again.');
                } finally {
                    wordCreateSubmit.disabled = false;
                    wordCreateSubmit.textContent = 'Create Document';
                }
            });
        }

        // Open document
        if (wordOpenSubmit) {
            wordOpenSubmit.addEventListener('click', async () => {
                const filePath = document.getElementById('wordOpenFilePath')?.value.trim();

                if (!filePath) {
                    alert('Please enter a file path (e.g., C:\\Users\\YourName\\Documents\\mydocument.docx)');
                    return;
                }

                // Ensure the path ends with .docx if no extension
                if (!filePath.includes('.') && !filePath.toLowerCase().endsWith('.docx')) {
                    filePath = filePath + '.docx';
                    document.getElementById('wordOpenFilePath').value = filePath;
                }

                wordOpenSubmit.disabled = true;
                wordOpenSubmit.textContent = 'Opening...';

                try {
                    const response = await fetch('http://localhost:8000/api/word/open', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            file_path: filePath
                        })
                    });

                    const data = await response.json();
                    if (response.ok && data.success) {
                        // Close the modal
                        if (wordOpenModal) wordOpenModal.style.display = 'none';
                        
                        // Get document content and open in editor
                        const content = data.data?.content || '';
                        const fileName = filePath.split('\\').pop() || filePath.split('/').pop() || 'Document';
                        
                        // Open the document in the Word editor
                        openWordEditor(filePath, fileName, content);
                        
                        console.log('Document opened successfully:', filePath);
                    } else {
                        const errorMsg = data.detail || data.message || data.error || 'Failed to open document';
                        console.error('Open document error:', errorMsg);
                        alert('Error opening document:\n\n' + errorMsg + '\n\nPlease check:\n- The file path is correct\n- The file exists\n- The file is a valid .docx document\n- You have permission to read the file');
                    }
                } catch (error) {
                    console.error('Error opening document:', error);
                    alert('Error opening document: ' + error.message + '\n\nPlease check your network connection and try again.');
                } finally {
                    wordOpenSubmit.disabled = false;
                    wordOpenSubmit.textContent = 'Open Document';
                }
            });
        }

        // Slack send message functionality
        const slackMessageInput = document.getElementById('slackMessageInput');
        const slackSendButton = document.getElementById('slackSendButton');

        // Auto-resize textarea
        if (slackMessageInput) {
            slackMessageInput.addEventListener('input', function() {
                this.style.height = 'auto';
                this.style.height = Math.min(this.scrollHeight, 150) + 'px';
                slackSendButton.disabled = !this.value.trim() || !currentChannelId;
            });

            slackMessageInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    if (!slackSendButton.disabled) {
                        sendSlackMessage();
                    }
                }
            });
        }

        async function sendSlackMessage() {
            if (!currentChannelId || !slackMessageInput) return;
            
            const text = slackMessageInput.value.trim();
            if (!text) return;
        
            // Disable input while sending
            slackMessageInput.disabled = true;
            slackSendButton.disabled = true;
            slackSendButton.innerHTML = '<div class="slack-send-spinner"></div>';

            try {
                console.log(`[*] Sending message to channel ${currentChannelId}...`);
                const response = await fetch('http://localhost:8000/api/slack/send', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        channel_id: currentChannelId,
                        text: text
                    })
                });

                console.log('[*] Response status:', response.status);
                const data = await response.json();
                console.log('[*] Response data:', data);

                if (response.ok && data.success) {
                    // Clear input
                    slackMessageInput.value = '';
                    slackMessageInput.style.height = 'auto';
                    
                    // Reload messages to show the new one
                    await loadSlackMessages();
                    
                    // Re-select the current channel
                    if (currentChannelId) {
                        selectChannel(currentChannelId);
                    }
                } else {
                    const errorMsg = data.error || data.detail || JSON.stringify(data);
                    console.error('[!] Backend error:', errorMsg);
                    alert(`Failed to send message: ${errorMsg}`);
                }
            } catch (error) {
                console.error('[!] Exception:', error);
                alert(`Failed to send message: ${error.message}`);
            } finally {
                // Re-enable input
                slackMessageInput.disabled = false;
                slackSendButton.disabled = false;
                slackSendButton.innerHTML = `
                    <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                        <path d="M18 2L9 11M18 2L12 18L9 11M18 2L2 8L9 11" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                `;
                slackMessageInput.focus();
            }
        }

        if (slackSendButton) {
            slackSendButton.addEventListener('click', sendSlackMessage);
        }

        // ===================================================================
        // Excel Spreadsheet functionality
        // ===================================================================
        
        const createExcelButton = document.getElementById('createExcelButton');
        const openExcelButton = document.getElementById('openExcelButton');
        const excelSpreadsheetArea = document.getElementById('excelSpreadsheetArea');
        
        // Track current Excel spreadsheet
        let currentExcelSpreadsheet = {
            filePath: null,
            sheets: [],
            activeSheet: null,
            data: {} // { sheetName: [[cell values]] }
        };

        // Excel function library
        const excelFunctions = [
            { name: 'SUM', category: 'math', syntax: '=SUM(range)', description: 'Adds all the numbers in a range of cells.', example: '=SUM(A1:A10)' },
            { name: 'AVERAGE', category: 'math', syntax: '=AVERAGE(range)', description: 'Returns the average (arithmetic mean) of the arguments.', example: '=AVERAGE(A1:A10)' },
            { name: 'COUNT', category: 'math', syntax: '=COUNT(range)', description: 'Counts the number of cells that contain numbers.', example: '=COUNT(A1:A10)' },
            { name: 'COUNTA', category: 'math', syntax: '=COUNTA(range)', description: 'Counts the number of cells that are not empty.', example: '=COUNTA(A1:A10)' },
            { name: 'MAX', category: 'math', syntax: '=MAX(range)', description: 'Returns the largest value in a set of values.', example: '=MAX(A1:A10)' },
            { name: 'MIN', category: 'math', syntax: '=MIN(range)', description: 'Returns the smallest value in a set of values.', example: '=MIN(A1:A10)' },
            { name: 'PRODUCT', category: 'math', syntax: '=PRODUCT(range)', description: 'Multiplies all the numbers given as arguments.', example: '=PRODUCT(A1:A5)' },
            { name: 'ROUND', category: 'math', syntax: '=ROUND(number, num_digits)', description: 'Rounds a number to a specified number of digits.', example: '=ROUND(A1, 2)' },
            { name: 'ROUNDUP', category: 'math', syntax: '=ROUNDUP(number, num_digits)', description: 'Rounds a number up, away from zero.', example: '=ROUNDUP(A1, 2)' },
            { name: 'ROUNDDOWN', category: 'math', syntax: '=ROUNDDOWN(number, num_digits)', description: 'Rounds a number down, toward zero.', example: '=ROUNDDOWN(A1, 2)' },
            { name: 'CONCATENATE', category: 'text', syntax: '=CONCATENATE(text1, text2, ...)', description: 'Joins several text strings into one text string.', example: '=CONCATENATE(A1, " ", B1)' },
            { name: 'CONCAT', category: 'text', syntax: '=CONCAT(text1, text2, ...)', description: 'Combines text from multiple ranges and/or strings.', example: '=CONCAT(A1, B1)' },
            { name: 'LEN', category: 'text', syntax: '=LEN(text)', description: 'Returns the number of characters in a text string.', example: '=LEN(A1)' },
            { name: 'UPPER', category: 'text', syntax: '=UPPER(text)', description: 'Converts text to uppercase.', example: '=UPPER(A1)' },
            { name: 'LOWER', category: 'text', syntax: '=LOWER(text)', description: 'Converts text to lowercase.', example: '=LOWER(A1)' },
            { name: 'TRIM', category: 'text', syntax: '=TRIM(text)', description: 'Removes all spaces from text except single spaces between words.', example: '=TRIM(A1)' },
            { name: 'LEFT', category: 'text', syntax: '=LEFT(text, num_chars)', description: 'Returns the first character or characters in a text string.', example: '=LEFT(A1, 5)' },
            { name: 'RIGHT', category: 'text', syntax: '=RIGHT(text, num_chars)', description: 'Returns the last character or characters in a text string.', example: '=RIGHT(A1, 5)' },
            { name: 'MID', category: 'text', syntax: '=MID(text, start_num, num_chars)', description: 'Returns a specific number of characters from a text string.', example: '=MID(A1, 2, 5)' },
            { name: 'IF', category: 'logical', syntax: '=IF(logical_test, value_if_true, value_if_false)', description: 'Returns one value if a condition is true and another value if it\'s false.', example: '=IF(A1>10, "High", "Low")' },
            { name: 'AND', category: 'logical', syntax: '=AND(logical1, logical2, ...)', description: 'Returns TRUE if all arguments are TRUE.', example: '=AND(A1>0, B1<100)' },
            { name: 'OR', category: 'logical', syntax: '=OR(logical1, logical2, ...)', description: 'Returns TRUE if any argument is TRUE.', example: '=OR(A1>0, B1>0)' },
            { name: 'NOT', category: 'logical', syntax: '=NOT(logical)', description: 'Reverses the logic of its argument.', example: '=NOT(A1>0)' },
            { name: 'TODAY', category: 'date', syntax: '=TODAY()', description: 'Returns the current date.', example: '=TODAY()' },
            { name: 'NOW', category: 'date', syntax: '=NOW()', description: 'Returns the current date and time.', example: '=NOW()' }
        ];

        let selectedFunction = null;

        function openExcelEditor(filePath, sheets, activeSheet, sheetData) {
            console.log('üìä openExcelEditor called with:');
            console.log('  - filePath:', filePath);
            console.log('  - sheets:', sheets);
            console.log('  - activeSheet:', activeSheet);
            console.log('  - sheetData keys:', sheetData ? Object.keys(sheetData) : 'N/A');
            console.log('  - sheetData structure:', sheetData);
            
            currentExcelSpreadsheet.filePath = filePath;
            currentExcelSpreadsheet.sheets = sheets || ['Sheet1'];
            currentExcelSpreadsheet.activeSheet = activeSheet || 'Sheet1';
            currentExcelSpreadsheet.data = sheetData || { 'Sheet1': Array(30).fill().map(() => Array(15).fill('')) };
            
            console.log('üìä currentExcelSpreadsheet.data keys:', Object.keys(currentExcelSpreadsheet.data));
            
            if (excelSpreadsheetArea) {
                const fileName = filePath.split('\\').pop() || filePath.split('/').pop() || 'Spreadsheet';
                excelSpreadsheetArea.innerHTML = `
                    <div class="excel-editor-container">
                        <div class="excel-editor-toolbar">
                            <!-- File Operations -->
                            <div class="excel-editor-toolbar-group">
                                <button class="excel-editor-btn" id="excelEditorNew" title="New Spreadsheet">üìä New</button>
                                <button class="excel-editor-btn" id="excelEditorOpen" title="Open Spreadsheet">üìÇ Open</button>
                                <button class="excel-editor-btn excel-editor-btn-primary" id="excelEditorSave" title="Save (Ctrl+S)">üíæ Save</button>
                            </div>
                            
                            <!-- Formatting -->
                            <div class="excel-editor-toolbar-group">
                                <button class="excel-editor-btn" id="excelEditorBold" title="Bold"><strong>B</strong></button>
                                <button class="excel-editor-btn" id="excelEditorItalic" title="Italic"><em>I</em></button>
                                <button class="excel-editor-btn" id="excelEditorUnderline" title="Underline"><u>U</u></button>
                            </div>
                            
                            <!-- Alignment -->
                            <div class="excel-editor-toolbar-group">
                                <button class="excel-editor-btn" id="excelEditorAlignLeft" title="Align Left">‚óÄ</button>
                                <button class="excel-editor-btn" id="excelEditorAlignCenter" title="Align Center">‚ñ£</button>
                                <button class="excel-editor-btn" id="excelEditorAlignRight" title="Align Right">‚ñ∂</button>
                            </div>
                            
                            <!-- Font Controls -->
                            <div class="excel-editor-toolbar-group">
                                <select class="excel-editor-select" id="excelEditorFontSize" title="Font Size">
                                    <option value="8">8</option>
                                    <option value="9">9</option>
                                    <option value="10">10</option>
                                    <option value="11" selected>11</option>
                                    <option value="12">12</option>
                                    <option value="14">14</option>
                                    <option value="16">16</option>
                                    <option value="18">18</option>
                                    <option value="20">20</option>
                                </select>
                                <input type="color" id="excelEditorBgColor" title="Background Color" value="#ffffff" style="width: 40px; height: 28px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                            </div>
                            
                            <!-- Sheet Operations -->
                            <div class="excel-editor-toolbar-group">
                                <button class="excel-editor-btn" id="excelEditorAddSheet" title="Add Sheet">‚ûï Sheet</button>
                            </div>
                        </div>
                        
                        <div class="excel-info-bar">
                            <span style="font-weight: 600;">üìä ${fileName}</span>
                            <span style="color: rgba(255, 255, 255, 0.7); margin-left: 16px;" id="excelCellInfo">Ready</span>
                        </div>
                        
                        <div class="excel-formula-bar">
                            <div class="excel-formula-bar-cell-ref" id="excelFormulaBarCellRef"></div>
                            <div class="excel-formula-bar-input-container">
                                <button class="excel-formula-bar-fx" id="excelFormulaBarFxButton" title="Insert Function">fx</button>
                                <input type="text" class="excel-formula-bar-input" id="excelFormulaBarInput" placeholder="Enter value or formula (e.g., =SUM(A1:A10))">
                            </div>
                        </div>
                        
                        <!-- Function Helper Modal -->
                        <div class="excel-function-modal" id="excelFunctionModal" style="display: none;">
                            <div class="excel-function-modal-content">
                                <div class="excel-function-modal-header">
                                    <h3>Insert Function</h3>
                                    <button class="excel-modal-close" id="excelFunctionModalClose">&times;</button>
                                </div>
                                <div class="excel-function-modal-body">
                                    <div class="excel-function-search">
                                        <input type="text" id="excelFunctionSearch" placeholder="Search functions..." />
                                    </div>
                                    <div class="excel-function-categories">
                                        <button class="excel-function-category-btn active" data-category="all">All</button>
                                        <button class="excel-function-category-btn" data-category="math">Math</button>
                                        <button class="excel-function-category-btn" data-category="text">Text</button>
                                        <button class="excel-function-category-btn" data-category="logical">Logical</button>
                                        <button class="excel-function-category-btn" data-category="date">Date/Time</button>
                                    </div>
                                    <div class="excel-function-list" id="excelFunctionList">
                                        <!-- Functions will be populated here -->
                                    </div>
                                    <div class="excel-function-description" id="excelFunctionDescription">
                                        <h4>Function Description</h4>
                                        <p>Select a function to see its description and syntax.</p>
                                    </div>
                                </div>
                                <div class="excel-function-modal-footer">
                                    <button class="btn btn-secondary" id="excelFunctionCancel">Cancel</button>
                                    <button class="btn" id="excelFunctionInsert">Insert Function</button>
                                </div>
                            </div>
                        </div>
                        
                        <div class="excel-grid-container" id="excelGridContainer">
                            ${renderExcelGrid(currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet])}
                        </div>
                        
                        <div class="excel-sheet-tabs" id="excelSheetTabs">
                            ${renderSheetTabs(currentExcelSpreadsheet.sheets, currentExcelSpreadsheet.activeSheet)}
                        </div>
                    </div>
                `;
                
                // Attach event listeners to toolbar buttons
                attachExcelToolbarListeners();
                
                // Attach event listeners to grid cells
                attachExcelCellListeners();
                
                // Attach event listeners to sheet tabs
                attachExcelSheetTabListeners();
                
                // Recalculate all formulas to ensure dependencies are resolved
                setTimeout(() => recalculateAllFormulas(), 10);
                
                // Handle keyboard shortcuts
                document.addEventListener('keydown', handleExcelKeyboard);
            }
        }

        function renderExcelGrid(data) {
            const rows = data.length;
            const cols = data[0]?.length || 15;
            const colLetters = [];
            
            // Generate column letters (A, B, C, ... Z, AA, AB, ...)
            for (let i = 0; i < cols; i++) {
                colLetters.push(getColumnLetter(i));
            }
            
            let html = '<div class="excel-grid">';
            
            // Column headers
            html += '<div class="excel-row excel-header-row">';
            html += '<div class="excel-cell excel-corner-cell"></div>'; // Corner cell
            for (let col = 0; col < cols; col++) {
                html += `<div class="excel-cell excel-column-header">${colLetters[col]}</div>`;
            }
            html += '</div>';
            
            // Data rows
            for (let row = 0; row < rows; row++) {
                html += '<div class="excel-row">';
                html += `<div class="excel-cell excel-row-header">${row + 1}</div>`; // Row number
                for (let col = 0; col < cols; col++) {
                    const value = data[row][col] || '';
                    let displayValue = value;
                    let formulaAttr = '';
                    
                    // If it's a formula, evaluate it for display
                    if (typeof value === 'string' && value.startsWith('=')) {
                        try {
                            displayValue = evaluateFormula(value, row, col);
                            formulaAttr = ` data-formula="${escapeHtml(value)}"`;
                        } catch (error) {
                            displayValue = '#ERROR!';
                            formulaAttr = ` data-formula="${escapeHtml(value)}"`;
                        }
                    }
                    
                    html += `<div class="excel-cell excel-data-cell" data-row="${row}" data-col="${col}" contenteditable="true"${formulaAttr}>${escapeHtml(String(displayValue))}</div>`;
                }
                html += '</div>';
            }
            
            html += '</div>';
            return html;
        }

        function renderSheetTabs(sheets, activeSheet) {
            return sheets.map(sheet => {
                const activeClass = sheet === activeSheet ? 'active' : '';
                return `<div class="excel-sheet-tab ${activeClass}" data-sheet="${sheet}">${sheet}</div>`;
            }).join('');
        }

        function getColumnLetter(index) {
            let letter = '';
            while (index >= 0) {
                letter = String.fromCharCode(65 + (index % 26)) + letter;
                index = Math.floor(index / 26) - 1;
            }
            return letter;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function attachExcelToolbarListeners() {
            // Save button
            const saveBtn = document.getElementById('excelEditorSave');
            if (saveBtn) {
                saveBtn.addEventListener('click', saveExcelSpreadsheet);
            }
            
            // New button
            const newBtn = document.getElementById('excelEditorNew');
            if (newBtn) {
                newBtn.addEventListener('click', () => {
                    if (createExcelButton) createExcelButton.click();
                });
            }
            
            // Open button
            const openBtn = document.getElementById('excelEditorOpen');
            if (openBtn) {
                openBtn.addEventListener('click', () => {
                    if (openExcelButton) openExcelButton.click();
                });
            }
            
            // Add Sheet button
            const addSheetBtn = document.getElementById('excelEditorAddSheet');
            if (addSheetBtn) {
                addSheetBtn.addEventListener('click', async () => {
                    const sheetName = prompt('Enter new sheet name:', `Sheet${currentExcelSpreadsheet.sheets.length + 1}`);
                    if (sheetName && !currentExcelSpreadsheet.sheets.includes(sheetName)) {
                        currentExcelSpreadsheet.sheets.push(sheetName);
                        currentExcelSpreadsheet.data[sheetName] = Array(30).fill().map(() => Array(15).fill(''));
                        updateSheetTabs();
                    }
                });
            }
            
            // fx button - open function modal
            const fxBtn = document.getElementById('excelFormulaBarFxButton');
            if (fxBtn) {
                fxBtn.addEventListener('click', () => {
                    showFunctionModal();
                });
            }
            
            // Formatting buttons
            const boldBtn = document.getElementById('excelEditorBold');
            if (boldBtn) {
                boldBtn.addEventListener('click', () => applyCellFormatting('fontWeight', 'bold'));
            }
            
            const italicBtn = document.getElementById('excelEditorItalic');
            if (italicBtn) {
                italicBtn.addEventListener('click', () => applyCellFormatting('fontStyle', 'italic'));
            }
            
            const underlineBtn = document.getElementById('excelEditorUnderline');
            if (underlineBtn) {
                underlineBtn.addEventListener('click', () => applyCellFormatting('textDecoration', 'underline'));
            }
            
            // Alignment buttons
            const alignLeftBtn = document.getElementById('excelEditorAlignLeft');
            if (alignLeftBtn) {
                alignLeftBtn.addEventListener('click', () => applyCellFormatting('textAlign', 'left'));
            }
            
            const alignCenterBtn = document.getElementById('excelEditorAlignCenter');
            if (alignCenterBtn) {
                alignCenterBtn.addEventListener('click', () => applyCellFormatting('textAlign', 'center'));
            }
            
            const alignRightBtn = document.getElementById('excelEditorAlignRight');
            if (alignRightBtn) {
                alignRightBtn.addEventListener('click', () => applyCellFormatting('textAlign', 'right'));
            }
            
            // Font controls
            const fontSizeSelect = document.getElementById('excelEditorFontSize');
            if (fontSizeSelect) {
                fontSizeSelect.addEventListener('change', function() {
                    applyCellFormatting('fontSize', this.value + 'pt');
                });
            }
            
            const fontFamilySelect = document.getElementById('excelEditorFontFamily');
            if (fontFamilySelect) {
                fontFamilySelect.addEventListener('change', function() {
                    applyCellFormatting('fontFamily', this.value);
                });
            }
        }
        
        // Apply formatting to selected cells
        function applyCellFormatting(property, value) {
            const selectedCells = document.querySelectorAll('.excel-data-cell.excel-cell-selected');
            if (selectedCells.length === 0) return;
            
            saveExcelState('Format Cells');
            
            selectedCells.forEach(cell => {
                // Toggle formatting if it's already applied (for bold, italic, underline)
                if (property === 'fontWeight' && cell.style.fontWeight === value) {
                    cell.style.fontWeight = 'normal';
                } else if (property === 'fontStyle' && cell.style.fontStyle === value) {
                    cell.style.fontStyle = 'normal';
                } else if (property === 'textDecoration' && cell.style.textDecoration === value) {
                    cell.style.textDecoration = 'none';
                } else {
                    cell.style[property] = value;
                }
            });
            
            console.log('Applied formatting:', property, '=', value, 'to', selectedCells.length, 'cells');
        }
        
        // Number formatting functions
        function formatCurrency() {
            const selectedCells = document.querySelectorAll('.excel-data-cell.excel-cell-selected');
            if (selectedCells.length === 0) return;
            
            saveExcelState('Format as Currency');
            
            selectedCells.forEach(cell => {
                const row = parseInt(cell.getAttribute('data-row'));
                const col = parseInt(cell.getAttribute('data-col'));
                const value = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet][row][col];
                
                // Skip if it's a formula
                if (typeof value === 'string' && value.startsWith('=')) return;
                
                const num = parseFloat(value);
                if (!isNaN(num)) {
                    const formatted = '$' + num.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                    cell.textContent = formatted;
                    cell.setAttribute('data-format', 'currency');
                    cell.setAttribute('data-raw-value', value);
                }
            });
            
            console.log('Formatted as currency');
        }
        
        function formatPercentage() {
            const selectedCells = document.querySelectorAll('.excel-data-cell.excel-cell-selected');
            if (selectedCells.length === 0) return;
            
            saveExcelState('Format as Percentage');
            
            selectedCells.forEach(cell => {
                const row = parseInt(cell.getAttribute('data-row'));
                const col = parseInt(cell.getAttribute('data-col'));
                const value = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet][row][col];
                
                // Skip if it's a formula
                if (typeof value === 'string' && value.startsWith('=')) return;
                
                const num = parseFloat(value);
                if (!isNaN(num)) {
                    const formatted = (num * 100).toFixed(2) + '%';
                    cell.textContent = formatted;
                    cell.setAttribute('data-format', 'percentage');
                    cell.setAttribute('data-raw-value', value);
                }
            });
            
            console.log('Formatted as percentage');
        }
        
        function formatDecimals(decimals = 2) {
            const selectedCells = document.querySelectorAll('.excel-data-cell.excel-cell-selected');
            if (selectedCells.length === 0) return;
            
            saveExcelState('Format Decimals');
            
            selectedCells.forEach(cell => {
                const row = parseInt(cell.getAttribute('data-row'));
                const col = parseInt(cell.getAttribute('data-col'));
                const value = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet][row][col];
                
                // Skip if it's a formula
                if (typeof value === 'string' && value.startsWith('=')) return;
                
                const num = parseFloat(value);
                if (!isNaN(num)) {
                    cell.textContent = num.toFixed(decimals);
                    cell.setAttribute('data-format', 'decimal');
                    cell.setAttribute('data-raw-value', value);
                }
            });
            
            console.log('Formatted with', decimals, 'decimals');
        }
        
        function formatNumber() {
            const selectedCells = document.querySelectorAll('.excel-data-cell.excel-cell-selected');
            if (selectedCells.length === 0) return;
            
            saveExcelState('Format as Number');
            
            selectedCells.forEach(cell => {
                const row = parseInt(cell.getAttribute('data-row'));
                const col = parseInt(cell.getAttribute('data-col'));
                const value = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet][row][col];
                
                // Skip if it's a formula
                if (typeof value === 'string' && value.startsWith('=')) return;
                
                const num = parseFloat(value);
                if (!isNaN(num)) {
                    const formatted = num.toLocaleString();
                    cell.textContent = formatted;
                    cell.setAttribute('data-format', 'number');
                    cell.setAttribute('data-raw-value', value);
                }
            });
            
            console.log('Formatted as number');
        }
        
        // Add keyboard shortcut for number formatting
        function showFormatMenu() {
            const menu = prompt('Format Options:\n1. Currency ($)\n2. Percentage (%)\n3. Number (1,000)\n4. Decimal (2 places)\n5. Decimal (4 places)\n6. Add All Borders\n7. Add Outer Border\n8. Remove Borders\n\nEnter option (1-8):');
            
            switch(menu) {
                case '1':
                    formatCurrency();
                    break;
                case '2':
                    formatPercentage();
                    break;
                case '3':
                    formatNumber();
                    break;
                case '4':
                    formatDecimals(2);
                    break;
                case '5':
                    formatDecimals(4);
                    break;
                case '6':
                    addCellBorders('all');
                    break;
                case '7':
                    addCellBorders('outer');
                    break;
                case '8':
                    removeCellBorders();
                    break;
            }
        }
        
        // Cell borders functionality
        function addCellBorders(type = 'all') {
            const selectedCells = document.querySelectorAll('.excel-data-cell.excel-cell-selected');
            if (selectedCells.length === 0) return;
            
            saveExcelState('Add Cell Borders');
            
            if (type === 'all') {
                selectedCells.forEach(cell => {
                    cell.style.border = '2px solid #6366f1';
                });
            } else if (type === 'outer') {
                // Get the range of selected cells
                let minRow = Infinity, maxRow = -Infinity;
                let minCol = Infinity, maxCol = -Infinity;
                
                selectedCells.forEach(cell => {
                    const row = parseInt(cell.getAttribute('data-row'));
                    const col = parseInt(cell.getAttribute('data-col'));
                    minRow = Math.min(minRow, row);
                    maxRow = Math.max(maxRow, row);
                    minCol = Math.min(minCol, col);
                    maxCol = Math.max(maxCol, col);
                });
                
                // Apply outer borders
                selectedCells.forEach(cell => {
                    const row = parseInt(cell.getAttribute('data-row'));
                    const col = parseInt(cell.getAttribute('data-col'));
                    
                    if (row === minRow) cell.style.borderTop = '2px solid #6366f1';
                    if (row === maxRow) cell.style.borderBottom = '2px solid #6366f1';
                    if (col === minCol) cell.style.borderLeft = '2px solid #6366f1';
                    if (col === maxCol) cell.style.borderRight = '2px solid #6366f1';
                });
            }
            
            console.log('Added borders:', type);
        }
        
        function removeCellBorders() {
            const selectedCells = document.querySelectorAll('.excel-data-cell.excel-cell-selected');
            if (selectedCells.length === 0) return;
            
            saveExcelState('Remove Cell Borders');
            
            selectedCells.forEach(cell => {
                cell.style.border = '';
                cell.style.borderTop = '';
                cell.style.borderBottom = '';
                cell.style.borderLeft = '';
                cell.style.borderRight = '';
            });
            
            console.log('Removed borders');
        }

        function showFunctionModal() {
            const modal = document.getElementById('excelFunctionModal');
            if (modal) {
                modal.style.display = 'flex';
                populateFunctionList('all');
                
                // Setup modal event listeners
                setupFunctionModalListeners();
            }
        }

        function setupFunctionModalListeners() {
            // Close button
            const closeBtn = document.getElementById('excelFunctionModalClose');
            if (closeBtn) {
                closeBtn.onclick = () => {
                    document.getElementById('excelFunctionModal').style.display = 'none';
                };
            }
            
            // Cancel button
            const cancelBtn = document.getElementById('excelFunctionCancel');
            if (cancelBtn) {
                cancelBtn.onclick = () => {
                    document.getElementById('excelFunctionModal').style.display = 'none';
                };
            }
            
            // Insert button
            const insertBtn = document.getElementById('excelFunctionInsert');
            if (insertBtn) {
                insertBtn.onclick = () => {
                    if (selectedFunction) {
                        const formulaInput = document.getElementById('excelFormulaBarInput');
                        if (formulaInput) {
                            formulaInput.value = selectedFunction.syntax;
                            formulaInput.focus();
                        }
                        document.getElementById('excelFunctionModal').style.display = 'none';
                    }
                };
            }
            
            // Category buttons
            const categoryBtns = document.querySelectorAll('.excel-function-category-btn');
            categoryBtns.forEach(btn => {
                btn.onclick = function() {
                    categoryBtns.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    const category = this.getAttribute('data-category');
                    populateFunctionList(category);
                };
            });
            
            // Search input
            const searchInput = document.getElementById('excelFunctionSearch');
            if (searchInput) {
                searchInput.oninput = function() {
                    const searchTerm = this.value.toLowerCase();
                    const filtered = excelFunctions.filter(f => 
                        f.name.toLowerCase().includes(searchTerm) || 
                        f.description.toLowerCase().includes(searchTerm)
                    );
                    renderFunctionList(filtered);
                };
            }
        }

        function populateFunctionList(category) {
            const filtered = category === 'all' 
                ? excelFunctions 
                : excelFunctions.filter(f => f.category === category);
            renderFunctionList(filtered);
        }

        function renderFunctionList(functions) {
            const listContainer = document.getElementById('excelFunctionList');
            if (!listContainer) return;
            
            listContainer.innerHTML = functions.map(func => `
                <div class="excel-function-item" data-function="${func.name}">
                    <div class="excel-function-name">${func.name}</div>
                    <div class="excel-function-syntax">${func.syntax}</div>
                </div>
            `).join('');
            
            // Add click handlers
            const items = listContainer.querySelectorAll('.excel-function-item');
            items.forEach(item => {
                item.onclick = function() {
                    items.forEach(i => i.classList.remove('selected'));
                    this.classList.add('selected');
                    const funcName = this.getAttribute('data-function');
                    selectedFunction = excelFunctions.find(f => f.name === funcName);
                    showFunctionDescription(selectedFunction);
                };
            });
        }

        function showFunctionDescription(func) {
            const descContainer = document.getElementById('excelFunctionDescription');
            if (!descContainer || !func) return;
            
            descContainer.innerHTML = `
                <h4>${func.name}</h4>
                <p><strong>Syntax:</strong> ${func.syntax}</p>
                <p><strong>Description:</strong> ${func.description}</p>
                <p><strong>Example:</strong> <code>${func.example}</code></p>
            `;
        }

        function attachExcelCellListeners() {
            const cells = document.querySelectorAll('.excel-data-cell');
            const formulaBarInput = document.getElementById('excelFormulaBarInput');
            const formulaBarCellRef = document.getElementById('excelFormulaBarCellRef');
            
            cells.forEach(cell => {
                // Right-click context menu
                cell.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    const row = parseInt(this.getAttribute('data-row'));
                    const col = parseInt(this.getAttribute('data-col'));
                    showExcelContextMenu(e.clientX, e.clientY, row, col);
                });
                
                // Mouse click handler for multi-selection
                cell.addEventListener('mousedown', function(e) {
                    const row = parseInt(this.getAttribute('data-row'));
                    const col = parseInt(this.getAttribute('data-col'));
                    
                    if (e.shiftKey && excelSelection.start) {
                        // Shift-click: select range
                        e.preventDefault();
                        
                        const startRow = excelSelection.start.row;
                        const startCol = excelSelection.start.col;
                        const endRow = row;
                        const endCol = col;
                        
                        // Clear previous selection
                        document.querySelectorAll('.excel-cell-selected').forEach(c => {
                            c.classList.remove('excel-cell-selected');
                        });
                        
                        // Select all cells in range
                        const minRow = Math.min(startRow, endRow);
                        const maxRow = Math.max(startRow, endRow);
                        const minCol = Math.min(startCol, endCol);
                        const maxCol = Math.max(startCol, endCol);
                        
                        for (let r = minRow; r <= maxRow; r++) {
                            for (let c = minCol; c <= maxCol; c++) {
                                const rangeCell = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                                if (rangeCell) {
                                    rangeCell.classList.add('excel-cell-selected');
                                }
                            }
                        }
                        
                        excelSelection.end = { row, col };
                    } else if (e.ctrlKey || e.metaKey) {
                        // Ctrl-click: toggle selection
                        e.preventDefault();
                        this.classList.toggle('excel-cell-selected');
                        
                        if (!excelSelection.start) {
                            excelSelection.start = { row, col };
                        }
                    } else {
                        // Normal click: clear and select single cell
                        if (!this.classList.contains('excel-cell-selected')) {
                            document.querySelectorAll('.excel-cell-selected').forEach(c => {
                                c.classList.remove('excel-cell-selected');
                            });
                        }
                        
                        excelSelection.start = { row, col };
                        excelSelection.end = null;
                    }
                });
                
                cell.addEventListener('focus', function() {
                    const row = parseInt(this.getAttribute('data-row'));
                    const col = parseInt(this.getAttribute('data-col'));
                    const cellRef = `${getColumnLetter(col)}${row + 1}`;
                    
                    const cellInfo = document.getElementById('excelCellInfo');
                    if (cellInfo) {
                        cellInfo.textContent = `Cell: ${cellRef}`;
                    }
                    
                    // Update formula bar
                    if (formulaBarCellRef) {
                        formulaBarCellRef.textContent = cellRef;
                    }
                    if (formulaBarInput) {
                        const rawValue = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet][row][col];
                        formulaBarInput.value = rawValue || '';
                    }
                    
                    this.classList.add('excel-cell-selected');
                    
                    // Check if we need to expand the grid
                    const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
                    const currentRows = sheetData.length;
                    const currentCols = sheetData[0]?.length || 0;
                    
                    let needsExpansion = false;
                    
                    // If in last column (or beyond), add more columns
                    if (col >= currentCols - 1) {
                        const columnsToAdd = 5; // Add 5 columns at a time
                        for (let i = 0; i < sheetData.length; i++) {
                            for (let j = 0; j < columnsToAdd; j++) {
                                sheetData[i].push('');
                            }
                        }
                        needsExpansion = true;
                    }
                    
                    // If in last row (or beyond), add more rows
                    if (row >= currentRows - 1) {
                        const rowsToAdd = 10; // Add 10 rows at a time
                        const newCols = sheetData[0]?.length || currentCols;
                        for (let i = 0; i < rowsToAdd; i++) {
                            sheetData.push(Array(newCols).fill(''));
                        }
                        needsExpansion = true;
                    }
                    
                    // Re-render grid if expanded
                    if (needsExpansion) {
                        const gridContainer = document.getElementById('excelGridContainer');
                        if (gridContainer) {
                            gridContainer.innerHTML = renderExcelGrid(sheetData);
                            attachExcelCellListeners();
                            // Re-focus the cell that was clicked
                            const newCell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                            if (newCell) {
                                setTimeout(() => newCell.focus(), 10);
                            }
                        }
                    }
                });
                
                cell.addEventListener('blur', function() {
                    const row = parseInt(this.getAttribute('data-row'));
                    const col = parseInt(this.getAttribute('data-col'));
                    let value = this.textContent.trim();
                    
                    // Update data
                    if (!currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet]) {
                        currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet] = Array(30).fill().map(() => Array(15).fill(''));
                    }
                    
                    // If it's a formula, evaluate it
                    if (value.startsWith('=')) {
                        try {
                            const result = evaluateFormula(value, row, col);
                            this.textContent = result;
                            this.setAttribute('data-formula', value);
                            currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet][row][col] = value; // Store formula
                        } catch (error) {
                            this.textContent = '#ERROR!';
                            currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet][row][col] = value;
                        }
                    } else {
                        currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet][row][col] = value;
                        this.removeAttribute('data-formula');
                    }
                    
                    // Recalculate all cells that depend on this cell
                    recalculateDependentCells(row, col);
                    
                    this.classList.remove('excel-cell-selected');
                });
                
                cell.addEventListener('keydown', function(e) {
                    const row = parseInt(this.getAttribute('data-row'));
                    const col = parseInt(this.getAttribute('data-col'));
                    let nextCell = null;
                    
                    // Handle Enter key
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.blur();
                        
                        // Check if we need to expand rows
                        const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
                        if (row >= sheetData.length - 1) {
                            const rowsToAdd = 10;
                            const newCols = sheetData[0]?.length || 15;
                            for (let i = 0; i < rowsToAdd; i++) {
                                sheetData.push(Array(newCols).fill(''));
                            }
                            const gridContainer = document.getElementById('excelGridContainer');
                            if (gridContainer) {
                                gridContainer.innerHTML = renderExcelGrid(sheetData);
                                attachExcelCellListeners();
                            }
                        }
                        
                        // Move to next row (down)
                        nextCell = document.querySelector(`[data-row="${row + 1}"][data-col="${col}"]`);
                        if (nextCell) nextCell.focus();
                        return;
                    }
                    
                    // Handle Tab key
                    if (e.key === 'Tab') {
                        e.preventDefault();
                        this.blur();
                        
                        // Check if we need to expand columns
                        const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
                        const currentCols = sheetData[0]?.length || 0;
                        if (col >= currentCols - 1) {
                            const columnsToAdd = 5;
                            for (let i = 0; i < sheetData.length; i++) {
                                for (let j = 0; j < columnsToAdd; j++) {
                                    sheetData[i].push('');
                                }
                            }
                            const gridContainer = document.getElementById('excelGridContainer');
                            if (gridContainer) {
                                gridContainer.innerHTML = renderExcelGrid(sheetData);
                                attachExcelCellListeners();
                            }
                        }
                        
                        // Move to next column (right)
                        nextCell = document.querySelector(`[data-row="${row}"][data-col="${col + 1}"]`);
                        if (nextCell) nextCell.focus();
                        return;
                    }
                    
                    // Handle Arrow keys
                    if (e.key === 'ArrowUp') {
                        // Don't move up if already in row 1 (row index 0)
                        if (row === 0) {
                            return;
                        }
                        e.preventDefault();
                        this.blur();
                        nextCell = document.querySelector(`[data-row="${row - 1}"][data-col="${col}"]`);
                        if (nextCell) nextCell.focus();
                        return;
                    }
                    
                    if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        this.blur();
                        
                        // Check if we need to expand rows
                        const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
                        if (row >= sheetData.length - 1) {
                            const rowsToAdd = 10;
                            const newCols = sheetData[0]?.length || 15;
                            for (let i = 0; i < rowsToAdd; i++) {
                                sheetData.push(Array(newCols).fill(''));
                            }
                            const gridContainer = document.getElementById('excelGridContainer');
                            if (gridContainer) {
                                gridContainer.innerHTML = renderExcelGrid(sheetData);
                                attachExcelCellListeners();
                            }
                        }
                        
                        nextCell = document.querySelector(`[data-row="${row + 1}"][data-col="${col}"]`);
                        if (nextCell) nextCell.focus();
                        return;
                    }
                    
                    if (e.key === 'ArrowLeft') {
                        // Don't move left if already in column A (col index 0)
                        if (col === 0) {
                            return;
                        }
                        e.preventDefault();
                        this.blur();
                        nextCell = document.querySelector(`[data-row="${row}"][data-col="${col - 1}"]`);
                        if (nextCell) nextCell.focus();
                        return;
                    }
                    
                    if (e.key === 'ArrowRight') {
                        e.preventDefault();
                        this.blur();
                        
                        // Check if we need to expand columns
                        const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
                        const currentCols = sheetData[0]?.length || 0;
                        if (col >= currentCols - 1) {
                            const columnsToAdd = 5;
                            for (let i = 0; i < sheetData.length; i++) {
                                for (let j = 0; j < columnsToAdd; j++) {
                                    sheetData[i].push('');
                                }
                            }
                            const gridContainer = document.getElementById('excelGridContainer');
                            if (gridContainer) {
                                gridContainer.innerHTML = renderExcelGrid(sheetData);
                                attachExcelCellListeners();
                            }
                        }
                        
                        nextCell = document.querySelector(`[data-row="${row}"][data-col="${col + 1}"]`);
                        if (nextCell) nextCell.focus();
                        return;
                    }
                });
            });
            
            // Formula bar input handler
            if (formulaBarInput) {
                formulaBarInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        const activeCell = document.querySelector('.excel-data-cell.excel-cell-selected');
                        if (activeCell) {
                            activeCell.textContent = this.value;
                            activeCell.blur(); // This will trigger evaluation
                            activeCell.focus();
                        }
                    }
                });
            }
        }

        function attachExcelSheetTabListeners() {
            const tabs = document.querySelectorAll('.excel-sheet-tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    const sheetName = this.getAttribute('data-sheet');
                    switchExcelSheet(sheetName);
                });
                
                // Double-click to rename sheet
                tab.addEventListener('dblclick', function(e) {
                    e.stopPropagation();
                    const oldName = this.getAttribute('data-sheet');
                    renameExcelSheet(oldName, this);
                });
                
                // Right-click context menu
                tab.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    const sheetName = this.getAttribute('data-sheet');
                    showSheetContextMenu(e, sheetName);
                });
            });
        }

        function switchExcelSheet(sheetName) {
            console.log(`üîÑ Switching to sheet: ${sheetName}`);
            console.log('Available sheets in data:', Object.keys(currentExcelSpreadsheet.data));
            console.log('Has sheet data?', !!currentExcelSpreadsheet.data[sheetName]);
            
            currentExcelSpreadsheet.activeSheet = sheetName;
            
            if (!currentExcelSpreadsheet.data[sheetName]) {
                console.log(`‚ö†Ô∏è No data for ${sheetName}, creating empty sheet`);
                currentExcelSpreadsheet.data[sheetName] = Array(30).fill().map(() => Array(15).fill(''));
            } else {
                console.log(`‚úÖ Found ${currentExcelSpreadsheet.data[sheetName].length} rows for ${sheetName}`);
            }
            
            const gridContainer = document.getElementById('excelGridContainer');
            if (gridContainer) {
                gridContainer.innerHTML = renderExcelGrid(currentExcelSpreadsheet.data[sheetName]);
                attachExcelCellListeners();
                
                // Recalculate all formulas to ensure dependencies are resolved
                setTimeout(() => recalculateAllFormulas(), 10);
            }
            
            updateSheetTabs();
        }

        function updateSheetTabs() {
            const tabsContainer = document.getElementById('excelSheetTabs');
            if (tabsContainer) {
                tabsContainer.innerHTML = renderSheetTabs(currentExcelSpreadsheet.sheets, currentExcelSpreadsheet.activeSheet);
                attachExcelSheetTabListeners();
            }
        }

        function renameExcelSheet(oldName, tabElement) {
            const newName = prompt('Enter new sheet name:', oldName);
            
            if (!newName || newName === oldName) {
                return; // User cancelled or didn't change the name
            }
            
            // Validate new name
            if (newName.trim() === '') {
                alert('Sheet name cannot be empty');
                return;
            }
            
            if (currentExcelSpreadsheet.sheets.includes(newName)) {
                alert('A sheet with this name already exists');
                return;
            }
            
            // Update sheet name in array
            const index = currentExcelSpreadsheet.sheets.indexOf(oldName);
            if (index !== -1) {
                currentExcelSpreadsheet.sheets[index] = newName;
            }
            
            // Update data object
            if (currentExcelSpreadsheet.data[oldName]) {
                currentExcelSpreadsheet.data[newName] = currentExcelSpreadsheet.data[oldName];
                delete currentExcelSpreadsheet.data[oldName];
            }
            
            // Update active sheet if it was the renamed one
            if (currentExcelSpreadsheet.activeSheet === oldName) {
                currentExcelSpreadsheet.activeSheet = newName;
            }
            
            // Update UI
            updateSheetTabs();
        }

        function showSheetContextMenu(event, sheetName) {
            // Remove any existing context menu
            const existingMenu = document.getElementById('excelSheetContextMenu');
            if (existingMenu) {
                existingMenu.remove();
            }
            
            // Create context menu
            const menu = document.createElement('div');
            menu.id = 'excelSheetContextMenu';
            menu.style.position = 'fixed';
            menu.style.left = event.clientX + 'px';
            menu.style.top = event.clientY + 'px';
            menu.style.background = 'rgba(30, 41, 59, 0.95)';
            menu.style.border = '1px solid rgba(99, 102, 241, 0.5)';
            menu.style.borderRadius = '8px';
            menu.style.padding = '8px 0';
            menu.style.zIndex = '10000';
            menu.style.minWidth = '150px';
            menu.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.3)';
            
            const menuItems = [
                {
                    label: '‚úèÔ∏è Rename',
                    action: () => {
                        const tab = document.querySelector(`.excel-sheet-tab[data-sheet="${sheetName}"]`);
                        if (tab) renameExcelSheet(sheetName, tab);
                    }
                },
                {
                    label: 'üóëÔ∏è Delete',
                    action: () => deleteExcelSheet(sheetName)
                }
            ];
            
            menuItems.forEach(item => {
                const menuItem = document.createElement('div');
                menuItem.textContent = item.label;
                menuItem.style.padding = '8px 16px';
                menuItem.style.cursor = 'pointer';
                menuItem.style.color = 'white';
                menuItem.style.fontSize = '13px';
                menuItem.style.transition = 'background 0.2s';
                
                menuItem.addEventListener('mouseenter', () => {
                    menuItem.style.background = 'rgba(99, 102, 241, 0.3)';
                });
                
                menuItem.addEventListener('mouseleave', () => {
                    menuItem.style.background = 'transparent';
                });
                
                menuItem.addEventListener('click', () => {
                    item.action();
                    menu.remove();
                });
                
                menu.appendChild(menuItem);
            });
            
            document.body.appendChild(menu);
            
            // Close menu when clicking elsewhere
            const closeMenu = (e) => {
                if (!menu.contains(e.target)) {
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                }
            };
            
            setTimeout(() => {
                document.addEventListener('click', closeMenu);
            }, 100);
        }

        function deleteExcelSheet(sheetName) {
            if (currentExcelSpreadsheet.sheets.length <= 1) {
                alert('Cannot delete the last sheet');
                return;
            }
            
            if (!confirm(`Are you sure you want to delete sheet "${sheetName}"?`)) {
                return;
            }
            
            // Remove from sheets array
            const index = currentExcelSpreadsheet.sheets.indexOf(sheetName);
            if (index !== -1) {
                currentExcelSpreadsheet.sheets.splice(index, 1);
            }
            
            // Remove data
            if (currentExcelSpreadsheet.data[sheetName]) {
                delete currentExcelSpreadsheet.data[sheetName];
            }
            
            // If deleted sheet was active, switch to first sheet
            if (currentExcelSpreadsheet.activeSheet === sheetName) {
                switchExcelSheet(currentExcelSpreadsheet.sheets[0]);
            } else {
                updateSheetTabs();
            }
        }

        async function saveExcelSpreadsheet() {
            if (!currentExcelSpreadsheet.filePath) {
                alert('No spreadsheet to save');
                return;
            }
            
            const saveBtn = document.getElementById('excelEditorSave');
            if (saveBtn) {
                saveBtn.disabled = true;
                saveBtn.textContent = 'üíæ Saving...';
            }
            
            try {
                // Capture current cell data before saving
                captureCurrentCellData();
                
                console.log('=== EXCEL SAVE DEBUG ===');
                console.log('File path:', currentExcelSpreadsheet.filePath);
                console.log('Sheets:', currentExcelSpreadsheet.sheets);
                console.log('Active sheet:', currentExcelSpreadsheet.activeSheet);
                console.log('Data keys:', Object.keys(currentExcelSpreadsheet.data));
                
                // Log sample data from each sheet
                for (const [sheetName, sheetData] of Object.entries(currentExcelSpreadsheet.data)) {
                    const nonEmptyRows = sheetData.filter(row => row.some(cell => cell !== ''));
                    const totalCells = sheetData.reduce((sum, row) => sum + row.filter(cell => cell !== '').length, 0);
                    console.log(`Sheet "${sheetName}": ${nonEmptyRows.length} non-empty rows, ${totalCells} cells with data`);
                }
                
                const response = await fetch('http://localhost:8000/api/excel/save', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        file_path: currentExcelSpreadsheet.filePath,
                        data: currentExcelSpreadsheet.data
                    })
                });

                const data = await response.json();
                console.log('Save response:', data);
                
                if (response.ok && data.success) {
                    if (saveBtn) {
                        saveBtn.textContent = 'üíæ Saved!';
                        setTimeout(() => {
                            if (saveBtn) {
                                saveBtn.textContent = 'üíæ Save';
                                saveBtn.disabled = false;
                            }
                        }, 2000);
                    }
                    alert(`Spreadsheet saved successfully!\n\nFile: ${data.file_path}\nSheets: ${data.sheets ? data.sheets.join(', ') : 'N/A'}`);
                } else {
                    throw new Error(data.detail || data.message || data.error || 'Failed to save spreadsheet');
                }
            } catch (error) {
                console.error('Error saving spreadsheet:', error);
                alert('Error saving spreadsheet: ' + error.message);
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.textContent = 'üíæ Save';
                }
            }
        }

        function captureCurrentCellData() {
            // Capture data from all visible cells in the current sheet
            const cells = document.querySelectorAll('.excel-data-cell');
            cells.forEach(cell => {
                const row = parseInt(cell.getAttribute('data-row'));
                const col = parseInt(cell.getAttribute('data-col'));
                const formula = cell.getAttribute('data-formula');
                const value = formula || cell.textContent.trim();
                
                // Ensure the sheet data array exists
                if (!currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet]) {
                    currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet] = Array(30).fill().map(() => Array(15).fill(''));
                }
                
                // Update the value (store formula if exists, otherwise value)
                if (currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet][row]) {
                    currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet][row][col] = value;
                }
            });
        }

        // Extract cell references from a formula
        function extractCellReferences(formula) {
            const references = new Set();
            if (!formula || !formula.startsWith('=')) return references;
            
            // Remove the leading =
            const formulaText = formula.substring(1).toUpperCase();
            
            // Match individual cell references (e.g., A1, B2, AA10)
            const cellRegex = /([A-Z]+)(\d+)(?![:\d])/g;
            let match;
            while ((match = cellRegex.exec(formulaText)) !== null) {
                references.add(`${match[1]}${match[2]}`);
            }
            
            // Match range references (e.g., A1:B10)
            const rangeRegex = /([A-Z]+\d+):([A-Z]+\d+)/g;
            while ((match = rangeRegex.exec(formulaText)) !== null) {
                const startCell = match[1];
                const endCell = match[2];
                
                // Parse start and end cells
                const startMatch = startCell.match(/([A-Z]+)(\d+)/);
                const endMatch = endCell.match(/([A-Z]+)(\d+)/);
                
                if (startMatch && endMatch) {
                    const startCol = columnLetterToIndex(startMatch[1]);
                    const startRow = parseInt(startMatch[2]) - 1;
                    const endCol = columnLetterToIndex(endMatch[1]);
                    const endRow = parseInt(endMatch[2]) - 1;
                    
                    // Add all cells in the range
                    for (let r = startRow; r <= endRow; r++) {
                        for (let c = startCol; c <= endCol; c++) {
                            const colLetter = indexToColumnLetter(c);
                            references.add(`${colLetter}${r + 1}`);
                        }
                    }
                }
            }
            
            return references;
        }
        
        // Convert column index to letter (e.g., 0 -> A, 25 -> Z, 26 -> AA)
        function indexToColumnLetter(index) {
            let letter = '';
            while (index >= 0) {
                letter = String.fromCharCode(65 + (index % 26)) + letter;
                index = Math.floor(index / 26) - 1;
            }
            return letter;
        }
        
        // Find all cells that depend on the given cell
        function findDependentCells(targetRow, targetCol) {
            const dependents = [];
            const targetCellRef = `${indexToColumnLetter(targetCol)}${targetRow + 1}`;
            const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
            
            if (!sheetData) return dependents;
            
            // Check all cells in the sheet
            for (let row = 0; row < sheetData.length; row++) {
                for (let col = 0; col < sheetData[row].length; col++) {
                    const cellValue = sheetData[row][col];
                    
                    // Skip if not a formula
                    if (!cellValue || !cellValue.startsWith('=')) continue;
                    
                    // Check if this formula references the target cell
                    const references = extractCellReferences(cellValue);
                    if (references.has(targetCellRef)) {
                        dependents.push({ row, col, formula: cellValue });
                    }
                }
            }
            
            return dependents;
        }
        
        // Recalculate all cells that depend on the changed cell
        function recalculateDependentCells(changedRow, changedCol, visited = new Set()) {
            // Create a unique key for this cell to prevent circular dependencies
            const cellKey = `${changedRow},${changedCol}`;
            if (visited.has(cellKey)) {
                console.warn('Circular reference detected at', cellKey);
                return;
            }
            visited.add(cellKey);
            
            // Find all cells that depend on this cell
            const dependents = findDependentCells(changedRow, changedCol);
            
            // Recalculate each dependent cell
            for (const dependent of dependents) {
                const cell = document.querySelector(`[data-row="${dependent.row}"][data-col="${dependent.col}"]`);
                if (cell && cell.hasAttribute('data-formula')) {
                    const formula = cell.getAttribute('data-formula');
                    
                    try {
                        const result = evaluateFormula(formula, dependent.row, dependent.col);
                        cell.textContent = result;
                        
                        // Recursively recalculate cells that depend on this one
                        recalculateDependentCells(dependent.row, dependent.col, visited);
                    } catch (error) {
                        console.error('Error recalculating cell', dependent.row, dependent.col, error);
                        cell.textContent = '#ERROR!';
                    }
                }
            }
        }
        
        // Recalculate all formulas in the current sheet
        // This is useful after loading a spreadsheet or switching sheets
        function recalculateAllFormulas() {
            const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
            if (!sheetData) return;
            
            // Build a list of all cells with formulas
            const formulaCells = [];
            for (let row = 0; row < sheetData.length; row++) {
                for (let col = 0; col < sheetData[row].length; col++) {
                    const value = sheetData[row][col];
                    if (value && typeof value === 'string' && value.startsWith('=')) {
                        formulaCells.push({ row, col, formula: value });
                    }
                }
            }
            
            // Calculate dependency depth for each formula (how many other formulas it depends on)
            // This helps us evaluate them in the right order
            const maxIterations = 10; // Prevent infinite loops
            let iteration = 0;
            let hasChanges = true;
            
            while (hasChanges && iteration < maxIterations) {
                hasChanges = false;
                iteration++;
                
                for (const formulaCell of formulaCells) {
                    const cell = document.querySelector(`[data-row="${formulaCell.row}"][data-col="${formulaCell.col}"]`);
                    if (cell) {
                        try {
                            const oldValue = cell.textContent;
                            const newValue = evaluateFormula(formulaCell.formula, formulaCell.row, formulaCell.col);
                            
                            if (oldValue !== String(newValue)) {
                                cell.textContent = newValue;
                                hasChanges = true;
                            }
                        } catch (error) {
                            cell.textContent = '#ERROR!';
                        }
                    }
                }
            }
            
            if (iteration >= maxIterations) {
                console.warn('Recalculation stopped after', maxIterations, 'iterations. Possible circular reference.');
            }
        }

        function evaluateFormula(formula, currentRow, currentCol) {
            try {
                // Remove leading =
                let originalFormula = formula;
                formula = formula.substring(1).trim();
                
                // Store original case for text functions
                const upperFormula = formula.toUpperCase();
                
                console.log('Evaluating formula:', originalFormula);
                
                // TODAY, NOW - handle first (no parameters)
                if (upperFormula === 'TODAY()') {
                    return new Date().toLocaleDateString();
                }
                if (upperFormula === 'NOW()') {
                    return new Date().toLocaleString();
                }
                
                // Handle range functions BEFORE replacing cell references
                if (upperFormula.match(/\b(SUM|AVERAGE|COUNT|COUNTA|MAX|MIN|PRODUCT)\(/)) {
                    const result = evaluateRangeFunction(upperFormula);
                    console.log('Range function result:', result);
                    return result;
                }
                
                // Handle text functions with cell references
                if (upperFormula.match(/\b(LEN|UPPER|LOWER|TRIM)\(/)) {
                    // Replace cell references first for text functions
                    let textFormula = upperFormula.replace(/([A-Z]+)(\d+)/g, (match, col, row) => {
                        const colIndex = columnLetterToIndex(col);
                        const rowIndex = parseInt(row) - 1;
                        const value = getCellValue(rowIndex, colIndex);
                        return `"${value}"`;
                    });
                    return evaluateTextFunction(textFormula);
                }
                
                // LEFT, RIGHT, MID with cell references
                if (upperFormula.match(/\b(LEFT|RIGHT|MID)\(/)) {
                    let textFormula = upperFormula.replace(/([A-Z]+)(\d+)(?![:\d])/g, (match, col, row) => {
                        const colIndex = columnLetterToIndex(col);
                        const rowIndex = parseInt(row) - 1;
                        const value = getCellValue(rowIndex, colIndex);
                        return `"${value}"`;
                    });
                    return evaluateTextFunction(textFormula);
                }
                
                // CONCATENATE, CONCAT
                if (upperFormula.includes('CONCATENATE(') || upperFormula.includes('CONCAT(')) {
                    let concatFormula = upperFormula.replace(/([A-Z]+)(\d+)/g, (match, col, row) => {
                        const colIndex = columnLetterToIndex(col);
                        const rowIndex = parseInt(row) - 1;
                        const value = getCellValue(rowIndex, colIndex);
                        return `"${value}"`;
                    });
                    return evaluateConcatenate(concatFormula);
                }
                
                // ROUND, ROUNDUP, ROUNDDOWN
                if (upperFormula.match(/\b(ROUND|ROUNDUP|ROUNDDOWN)\(/)) {
                    let roundFormula = upperFormula.replace(/([A-Z]+)(\d+)/g, (match, col, row) => {
                        const colIndex = columnLetterToIndex(col);
                        const rowIndex = parseInt(row) - 1;
                        const value = getCellValue(rowIndex, colIndex);
                        return value || '0';
                    });
                    return evaluateRoundFunction(roundFormula);
                }
                
                // Handle IF function
                if (upperFormula.includes('IF(')) {
                    let ifFormula = upperFormula.replace(/([A-Z]+)(\d+)/g, (match, col, row) => {
                        const colIndex = columnLetterToIndex(col);
                        const rowIndex = parseInt(row) - 1;
                        const value = getCellValue(rowIndex, colIndex);
                        return isNaN(value) ? `"${value}"` : (value || '0');
                    });
                    return evaluateIfFunction(ifFormula);
                }
                
                // Handle AND, OR, NOT
                if (upperFormula.match(/\b(AND|OR|NOT)\(/)) {
                    let logicalFormula = upperFormula.replace(/([A-Z]+)(\d+)/g, (match, col, row) => {
                        const colIndex = columnLetterToIndex(col);
                        const rowIndex = parseInt(row) - 1;
                        const value = getCellValue(rowIndex, colIndex);
                        return value || '0';
                    });
                    return evaluateLogicalFunction(logicalFormula);
                }
                
                // Handle simple cell references and mathematical expressions
                formula = upperFormula.replace(/([A-Z]+)(\d+)/g, (match, col, row) => {
                    const colIndex = columnLetterToIndex(col);
                    const rowIndex = parseInt(row) - 1;
                    const value = getCellValue(rowIndex, colIndex);
                    return value || '0';
                });
                
                // Evaluate mathematical expression
                // Replace Excel operators with JavaScript operators
                formula = formula.replace(/\^/g, '**'); // Power
                
                // Evaluate the expression
                const result = Function('"use strict"; return (' + formula + ')')();
                console.log('Math result:', result);
                return isNaN(result) ? '#VALUE!' : (Math.round(result * 100000000) / 100000000);
            } catch (error) {
                console.error('Formula evaluation error:', error, 'Formula:', formula);
                return '#ERROR!';
            }
        }

        function evaluateRangeFunction(formula) {
            // Extract function name and range
            const match = formula.match(/(SUM|AVERAGE|COUNT|COUNTA|MAX|MIN|PRODUCT)\(([A-Z]+\d+):([A-Z]+\d+)\)/);
            if (!match) return '#REF!';
            
            const [, func, startCell, endCell] = match;
            const values = getRangeValues(startCell, endCell);
            const allValues = getRangeValues(startCell, endCell, true); // Include text for COUNTA
            
            if (func === 'COUNTA') {
                return allValues.length;
            }
            
            if (values.length === 0) return func === 'COUNT' ? 0 : '#DIV/0!';
            
            switch (func) {
                case 'SUM':
                    return values.reduce((sum, val) => sum + val, 0);
                case 'AVERAGE':
                    return values.reduce((sum, val) => sum + val, 0) / values.length;
                case 'COUNT':
                    return values.length;
                case 'MAX':
                    return Math.max(...values);
                case 'MIN':
                    return Math.min(...values);
                case 'PRODUCT':
                    return values.reduce((product, val) => product * val, 1);
                default:
                    return '#NAME?';
            }
        }

        function evaluateConcatenate(formula) {
            const match = formula.match(/(?:CONCATENATE|CONCAT)\((.+)\)/i);
            if (!match) return '#VALUE!';
            
            const args = match[1].split(',').map(arg => arg.trim().replace(/^"|"$/g, ''));
            return args.join('');
        }

        function evaluateTextFunction(formula) {
            const upperFormula = formula.toUpperCase();
            
            // LEN(text)
            let match = upperFormula.match(/LEN\((.+)\)/);
            if (match) {
                const text = match[1].replace(/^"|"$/g, '');
                return text.length;
            }
            
            // UPPER(text)
            match = upperFormula.match(/UPPER\((.+)\)/);
            if (match) {
                const text = match[1].replace(/^"|"$/g, '');
                return text.toUpperCase();
            }
            
            // LOWER(text)
            match = upperFormula.match(/LOWER\((.+)\)/);
            if (match) {
                const text = match[1].replace(/^"|"$/g, '');
                return text.toLowerCase();
            }
            
            // TRIM(text)
            match = upperFormula.match(/TRIM\((.+)\)/);
            if (match) {
                const text = match[1].replace(/^"|"$/g, '');
                return text.trim();
            }
            
            // LEFT(text, num_chars)
            match = upperFormula.match(/LEFT\((.+),(\d+)\)/);
            if (match) {
                const text = match[1].replace(/^"|"$/g, '');
                const num = parseInt(match[2]);
                return text.substring(0, num);
            }
            
            // RIGHT(text, num_chars)
            match = upperFormula.match(/RIGHT\((.+),(\d+)\)/);
            if (match) {
                const text = match[1].replace(/^"|"$/g, '');
                const num = parseInt(match[2]);
                return text.substring(text.length - num);
            }
            
            // MID(text, start, num_chars)
            match = upperFormula.match(/MID\((.+),(\d+),(\d+)\)/);
            if (match) {
                const text = match[1].replace(/^"|"$/g, '');
                const start = parseInt(match[2]) - 1; // Excel is 1-indexed
                const num = parseInt(match[3]);
                return text.substring(start, start + num);
            }
            
            return '#VALUE!';
        }

        function evaluateRoundFunction(formula) {
            const upperFormula = formula.toUpperCase();
            
            // ROUND(number, num_digits)
            let match = upperFormula.match(/ROUND\((.+),(\d+)\)/);
            if (match) {
                const num = parseFloat(match[1]);
                const digits = parseInt(match[2]);
                return Math.round(num * Math.pow(10, digits)) / Math.pow(10, digits);
            }
            
            // ROUNDUP(number, num_digits)
            match = upperFormula.match(/ROUNDUP\((.+),(\d+)\)/);
            if (match) {
                const num = parseFloat(match[1]);
                const digits = parseInt(match[2]);
                return Math.ceil(num * Math.pow(10, digits)) / Math.pow(10, digits);
            }
            
            // ROUNDDOWN(number, num_digits)
            match = upperFormula.match(/ROUNDDOWN\((.+),(\d+)\)/);
            if (match) {
                const num = parseFloat(match[1]);
                const digits = parseInt(match[2]);
                return Math.floor(num * Math.pow(10, digits)) / Math.pow(10, digits);
            }
            
            return '#VALUE!';
        }

        function evaluateLogicalFunction(formula) {
            // AND(logical1, logical2, ...)
            let match = formula.match(/AND\((.+)\)/);
            if (match) {
                const args = match[1].split(',').map(arg => {
                    try {
                        return Function('"use strict"; return (' + arg.trim() + ')')();
                    } catch {
                        return false;
                    }
                });
                return args.every(val => val) ? 'TRUE' : 'FALSE';
            }
            
            // OR(logical1, logical2, ...)
            match = formula.match(/OR\((.+)\)/);
            if (match) {
                const args = match[1].split(',').map(arg => {
                    try {
                        return Function('"use strict"; return (' + arg.trim() + ')')();
                    } catch {
                        return false;
                    }
                });
                return args.some(val => val) ? 'TRUE' : 'FALSE';
            }
            
            // NOT(logical)
            match = formula.match(/NOT\((.+)\)/);
            if (match) {
                try {
                    const result = Function('"use strict"; return (' + match[1].trim() + ')')();
                    return !result ? 'TRUE' : 'FALSE';
                } catch {
                    return '#VALUE!';
                }
            }
            
            return '#VALUE!';
        }

        function evaluateIfFunction(formula) {
            // Simple IF(condition, true_value, false_value)
            const match = formula.match(/IF\((.+),(.+),(.+)\)/);
            if (!match) return '#VALUE!';
            
            const [, condition, trueVal, falseVal] = match;
            
            try {
                const conditionResult = Function('"use strict"; return (' + condition + ')')();
                return conditionResult ? trueVal.trim() : falseVal.trim();
            } catch (error) {
                return '#ERROR!';
            }
        }

        function getRangeValues(startCell, endCell, includeText = false) {
            const startMatch = startCell.match(/([A-Z]+)(\d+)/);
            const endMatch = endCell.match(/([A-Z]+)(\d+)/);
            
            if (!startMatch || !endMatch) return [];
            
            const startCol = columnLetterToIndex(startMatch[1]);
            const startRow = parseInt(startMatch[2]) - 1;
            const endCol = columnLetterToIndex(endMatch[1]);
            const endRow = parseInt(endMatch[2]) - 1;
            
            const values = [];
            for (let row = startRow; row <= endRow; row++) {
                for (let col = startCol; col <= endCol; col++) {
                    const value = getCellValue(row, col);
                    if (value !== '') {
                        if (includeText) {
                            values.push(value);
                        } else if (!isNaN(value)) {
                            values.push(parseFloat(value));
                        }
                    }
                }
            }
            
            return values;
        }

        function getCellValue(row, col) {
            const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
            if (!sheetData || !sheetData[row] || !sheetData[row][col]) return '';
            
            const value = sheetData[row][col];
            
            // If it's a formula, get the displayed value from the cell
            if (typeof value === 'string' && value.startsWith('=')) {
                const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                return cell ? cell.textContent.trim() : '';
            }
            
            return value;
        }

        function columnLetterToIndex(letter) {
            let index = 0;
            for (let i = 0; i < letter.length; i++) {
                index = index * 26 + (letter.charCodeAt(i) - 64);
            }
            return index - 1;
        }

        // Clipboard for Excel operations
        let excelClipboard = {
            data: [],
            isCut: false,
            sourceRange: null
        };
        
        // Undo/Redo stacks
        let excelUndoStack = [];
        let excelRedoStack = [];
        const MAX_UNDO_STACK = 50;
        
        // Multi-selection state
        let excelSelection = {
            start: null,
            end: null,
            cells: new Set()
        };
        
        // Save state for undo/redo
        function saveExcelState(description) {
            const state = {
                description: description,
                sheet: currentExcelSpreadsheet.activeSheet,
                data: JSON.parse(JSON.stringify(currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet]))
            };
            
            excelUndoStack.push(state);
            if (excelUndoStack.length > MAX_UNDO_STACK) {
                excelUndoStack.shift();
            }
            
            // Clear redo stack when a new action is performed
            excelRedoStack = [];
        }
        
        // Undo last action
        function undoExcel() {
            if (excelUndoStack.length === 0) {
                console.log('Nothing to undo');
                return;
            }
            
            const currentState = {
                description: 'Current state',
                sheet: currentExcelSpreadsheet.activeSheet,
                data: JSON.parse(JSON.stringify(currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet]))
            };
            excelRedoStack.push(currentState);
            
            const previousState = excelUndoStack.pop();
            currentExcelSpreadsheet.data[previousState.sheet] = previousState.data;
            
            const gridContainer = document.getElementById('excelGridContainer');
            if (gridContainer) {
                gridContainer.innerHTML = renderExcelGrid(previousState.data);
                attachExcelCellListeners();
                setTimeout(() => recalculateAllFormulas(), 10);
            }
            
            console.log('Undo:', previousState.description);
        }
        
        // Redo last undone action
        function redoExcel() {
            if (excelRedoStack.length === 0) {
                console.log('Nothing to redo');
                return;
            }
            
            const currentState = {
                description: 'Current state',
                sheet: currentExcelSpreadsheet.activeSheet,
                data: JSON.parse(JSON.stringify(currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet]))
            };
            excelUndoStack.push(currentState);
            
            const nextState = excelRedoStack.pop();
            currentExcelSpreadsheet.data[nextState.sheet] = nextState.data;
            
            const gridContainer = document.getElementById('excelGridContainer');
            if (gridContainer) {
                gridContainer.innerHTML = renderExcelGrid(nextState.data);
                attachExcelCellListeners();
                setTimeout(() => recalculateAllFormulas(), 10);
            }
            
            console.log('Redo:', nextState.description);
        }
        
        // Copy selected cells
        function copyExcelCells() {
            const selectedCells = document.querySelectorAll('.excel-data-cell.excel-cell-selected');
            if (selectedCells.length === 0) return;
            
            excelClipboard.data = [];
            excelClipboard.isCut = false;
            
            // Get the range of selected cells
            let minRow = Infinity, maxRow = -Infinity;
            let minCol = Infinity, maxCol = -Infinity;
            
            selectedCells.forEach(cell => {
                const row = parseInt(cell.getAttribute('data-row'));
                const col = parseInt(cell.getAttribute('data-col'));
                minRow = Math.min(minRow, row);
                maxRow = Math.max(maxRow, row);
                minCol = Math.min(minCol, col);
                maxCol = Math.max(maxCol, col);
            });
            
            // Store the data in a 2D array
            for (let r = minRow; r <= maxRow; r++) {
                const rowData = [];
                for (let c = minCol; c <= maxCol; c++) {
                    const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                    const formula = cell ? cell.getAttribute('data-formula') : null;
                    const value = formula || (cell ? cell.textContent.trim() : '');
                    rowData.push(value);
                }
                excelClipboard.data.push(rowData);
            }
            
            excelClipboard.sourceRange = { minRow, maxRow, minCol, maxCol };
            
            // Visual feedback
            document.querySelectorAll('.excel-cell-copied').forEach(cell => {
                cell.classList.remove('excel-cell-copied');
            });
            selectedCells.forEach(cell => {
                cell.classList.add('excel-cell-copied');
            });
            
            console.log('Copied', selectedCells.length, 'cells');
        }
        
        // Cut selected cells
        function cutExcelCells() {
            copyExcelCells();
            excelClipboard.isCut = true;
            
            // Visual feedback for cut
            document.querySelectorAll('.excel-cell-cut').forEach(cell => {
                cell.classList.remove('excel-cell-cut');
            });
            document.querySelectorAll('.excel-cell-copied').forEach(cell => {
                cell.classList.remove('excel-cell-copied');
                cell.classList.add('excel-cell-cut');
            });
            
            console.log('Cut', document.querySelectorAll('.excel-cell-cut').length, 'cells');
        }
        
        // Paste cells
        function pasteExcelCells() {
            if (excelClipboard.data.length === 0) return;
            
            const activeCell = document.querySelector('.excel-data-cell.excel-cell-selected');
            if (!activeCell) return;
            
            saveExcelState('Paste');
            
            const startRow = parseInt(activeCell.getAttribute('data-row'));
            const startCol = parseInt(activeCell.getAttribute('data-col'));
            const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
            
            // Paste the data
            for (let r = 0; r < excelClipboard.data.length; r++) {
                for (let c = 0; c < excelClipboard.data[r].length; c++) {
                    const targetRow = startRow + r;
                    const targetCol = startCol + c;
                    
                    // Expand sheet if necessary
                    while (targetRow >= sheetData.length) {
                        sheetData.push(Array(sheetData[0]?.length || 15).fill(''));
                    }
                    while (targetCol >= sheetData[0].length) {
                        sheetData.forEach(row => row.push(''));
                    }
                    
                    const value = excelClipboard.data[r][c];
                    sheetData[targetRow][targetCol] = value;
                    
                    // Update the cell in the DOM
                    const cell = document.querySelector(`[data-row="${targetRow}"][data-col="${targetCol}"]`);
                    if (cell) {
                        if (value.startsWith('=')) {
                            try {
                                const result = evaluateFormula(value, targetRow, targetCol);
                                cell.textContent = result;
                                cell.setAttribute('data-formula', value);
                            } catch (error) {
                                cell.textContent = '#ERROR!';
                                cell.setAttribute('data-formula', value);
                            }
                        } else {
                            cell.textContent = value;
                            cell.removeAttribute('data-formula');
                        }
                    }
                }
            }
            
            // If it was cut, clear the source cells
            if (excelClipboard.isCut) {
                const { minRow, maxRow, minCol, maxCol } = excelClipboard.sourceRange;
                for (let r = minRow; r <= maxRow; r++) {
                    for (let c = minCol; c <= maxCol; c++) {
                        sheetData[r][c] = '';
                        const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                        if (cell) {
                            cell.textContent = '';
                            cell.removeAttribute('data-formula');
                        }
                    }
                }
                excelClipboard.isCut = false;
            }
            
            // Clear visual feedback
            document.querySelectorAll('.excel-cell-copied, .excel-cell-cut').forEach(cell => {
                cell.classList.remove('excel-cell-copied', 'excel-cell-cut');
            });
            
            // Recalculate formulas
            setTimeout(() => recalculateAllFormulas(), 10);
            
            // Re-render the grid if it expanded
            const gridContainer = document.getElementById('excelGridContainer');
            if (gridContainer) {
                gridContainer.innerHTML = renderExcelGrid(sheetData);
                attachExcelCellListeners();
            }
            
            console.log('Pasted', excelClipboard.data.length * excelClipboard.data[0].length, 'cells');
        }
        
        // Delete cell content
        function deleteExcelCellContent() {
            const selectedCells = document.querySelectorAll('.excel-data-cell.excel-cell-selected');
            if (selectedCells.length === 0) return;
            
            saveExcelState('Delete');
            
            selectedCells.forEach(cell => {
                const row = parseInt(cell.getAttribute('data-row'));
                const col = parseInt(cell.getAttribute('data-col'));
                
                currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet][row][col] = '';
                cell.textContent = '';
                cell.removeAttribute('data-formula');
                
                // Recalculate dependent cells
                recalculateDependentCells(row, col);
            });
            
            console.log('Deleted content of', selectedCells.length, 'cells');
        }
        
        // Fill down (Ctrl+D)
        function fillDown() {
            const selectedCells = Array.from(document.querySelectorAll('.excel-data-cell.excel-cell-selected'));
            if (selectedCells.length < 2) return;
            
            saveExcelState('Fill Down');
            
            // Get the range
            let minRow = Infinity, maxRow = -Infinity;
            let minCol = Infinity, maxCol = -Infinity;
            
            selectedCells.forEach(cell => {
                const row = parseInt(cell.getAttribute('data-row'));
                const col = parseInt(cell.getAttribute('data-col'));
                minRow = Math.min(minRow, row);
                maxRow = Math.max(maxRow, row);
                minCol = Math.min(minCol, col);
                maxCol = Math.max(maxCol, col);
            });
            
            const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
            
            // Fill down each column
            for (let c = minCol; c <= maxCol; c++) {
                const sourceValue = sheetData[minRow][c];
                
                for (let r = minRow + 1; r <= maxRow; r++) {
                    sheetData[r][c] = sourceValue;
                    
                    const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                    if (cell) {
                        if (sourceValue.startsWith('=')) {
                            try {
                                const result = evaluateFormula(sourceValue, r, c);
                                cell.textContent = result;
                                cell.setAttribute('data-formula', sourceValue);
                            } catch (error) {
                                cell.textContent = '#ERROR!';
                            }
                        } else {
                            cell.textContent = sourceValue;
                            cell.removeAttribute('data-formula');
                        }
                    }
                }
            }
            
            setTimeout(() => recalculateAllFormulas(), 10);
            console.log('Filled down');
        }
        
        // Fill right (Ctrl+R)
        function fillRight() {
            const selectedCells = Array.from(document.querySelectorAll('.excel-data-cell.excel-cell-selected'));
            if (selectedCells.length < 2) return;
            
            saveExcelState('Fill Right');
            
            // Get the range
            let minRow = Infinity, maxRow = -Infinity;
            let minCol = Infinity, maxCol = -Infinity;
            
            selectedCells.forEach(cell => {
                const row = parseInt(cell.getAttribute('data-row'));
                const col = parseInt(cell.getAttribute('data-col'));
                minRow = Math.min(minRow, row);
                maxRow = Math.max(maxRow, row);
                minCol = Math.min(minCol, col);
                maxCol = Math.max(maxCol, col);
            });
            
            const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
            
            // Fill right each row
            for (let r = minRow; r <= maxRow; r++) {
                const sourceValue = sheetData[r][minCol];
                
                for (let c = minCol + 1; c <= maxCol; c++) {
                    sheetData[r][c] = sourceValue;
                    
                    const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                    if (cell) {
                        if (sourceValue.startsWith('=')) {
                            try {
                                const result = evaluateFormula(sourceValue, r, c);
                                cell.textContent = result;
                                cell.setAttribute('data-formula', sourceValue);
                            } catch (error) {
                                cell.textContent = '#ERROR!';
                            }
                        } else {
                            cell.textContent = sourceValue;
                            cell.removeAttribute('data-formula');
                        }
                    }
                }
            }
            
            setTimeout(() => recalculateAllFormulas(), 10);
            console.log('Filled right');
        }
        
        // Select all cells
        function selectAllCells() {
            const cells = document.querySelectorAll('.excel-data-cell');
            cells.forEach(cell => {
                cell.classList.add('excel-cell-selected');
            });
            console.log('Selected all cells');
        }
        
        // Find dialog
        function openFindDialog() {
            const searchTerm = prompt('Find:');
            if (!searchTerm) return;
            
            const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
            let found = false;
            
            for (let r = 0; r < sheetData.length; r++) {
                for (let c = 0; c < sheetData[r].length; c++) {
                    const value = String(sheetData[r][c]).toLowerCase();
                    if (value.includes(searchTerm.toLowerCase())) {
                        const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                        if (cell) {
                            // Clear previous selections
                            document.querySelectorAll('.excel-cell-selected').forEach(c => {
                                c.classList.remove('excel-cell-selected');
                            });
                            
                            cell.classList.add('excel-cell-selected');
                            cell.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            cell.focus();
                            found = true;
                            return;
                        }
                    }
                }
            }
            
            if (!found) {
                alert(`"${searchTerm}" not found`);
            }
        }
        
        // Show context menu
        function showExcelContextMenu(x, y, row, col) {
            // Remove existing context menu if any
            const existingMenu = document.getElementById('excelContextMenu');
            if (existingMenu) {
                existingMenu.remove();
            }
            
            const menu = document.createElement('div');
            menu.id = 'excelContextMenu';
            menu.style.position = 'fixed';
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.style.background = 'rgba(30, 41, 59, 0.98)';
            menu.style.border = '1px solid rgba(99, 102, 241, 0.3)';
            menu.style.borderRadius = '8px';
            menu.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.3)';
            menu.style.zIndex = '10000';
            menu.style.minWidth = '200px';
            menu.style.padding = '4px';
            
            const menuItems = [
                { label: 'Insert Row Above', action: () => insertRowAbove(row) },
                { label: 'Insert Row Below', action: () => insertRowBelow(row) },
                { label: 'Delete Row', action: () => deleteRow(row) },
                { label: '---', action: null },
                { label: 'Insert Column Left', action: () => insertColumnLeft(col) },
                { label: 'Insert Column Right', action: () => insertColumnRight(col) },
                { label: 'Delete Column', action: () => deleteColumn(col) },
                { label: '---', action: null },
                { label: 'Sort Ascending', action: () => sortColumn(col, 'asc') },
                { label: 'Sort Descending', action: () => sortColumn(col, 'desc') }
            ];
            
            menuItems.forEach(item => {
                if (item.label === '---') {
                    const separator = document.createElement('div');
                    separator.style.height = '1px';
                    separator.style.background = 'rgba(255, 255, 255, 0.1)';
                    separator.style.margin = '4px 0';
                    menu.appendChild(separator);
                } else {
                    const menuItem = document.createElement('div');
                    menuItem.textContent = item.label;
                    menuItem.style.padding = '8px 12px';
                    menuItem.style.cursor = 'pointer';
                    menuItem.style.color = '#e2e8f0';
                    menuItem.style.fontSize = '13px';
                    menuItem.style.borderRadius = '4px';
                    menuItem.style.transition = 'all 0.2s';
                    
                    menuItem.addEventListener('mouseenter', function() {
                        this.style.background = 'rgba(99, 102, 241, 0.3)';
                    });
                    
                    menuItem.addEventListener('mouseleave', function() {
                        this.style.background = 'transparent';
                    });
                    
                    menuItem.addEventListener('click', function() {
                        item.action();
                        menu.remove();
                    });
                    
                    menu.appendChild(menuItem);
                }
            });
            
            document.body.appendChild(menu);
            
            // Close menu when clicking outside
            setTimeout(() => {
                document.addEventListener('click', function closeMenu() {
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                }, 100);
            });
        }
        
        // Insert row above
        function insertRowAbove(row) {
            saveExcelState('Insert Row Above');
            const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
            const newRow = Array(sheetData[0].length).fill('');
            sheetData.splice(row, 0, newRow);
            refreshExcelGrid();
            console.log('Inserted row above row', row + 1);
        }
        
        // Insert row below
        function insertRowBelow(row) {
            saveExcelState('Insert Row Below');
            const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
            const newRow = Array(sheetData[0].length).fill('');
            sheetData.splice(row + 1, 0, newRow);
            refreshExcelGrid();
            console.log('Inserted row below row', row + 1);
        }
        
        // Delete row
        function deleteRow(row) {
            if (!confirm(`Delete row ${row + 1}?`)) return;
            
            saveExcelState('Delete Row');
            const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
            sheetData.splice(row, 1);
            refreshExcelGrid();
            console.log('Deleted row', row + 1);
        }
        
        // Insert column left
        function insertColumnLeft(col) {
            saveExcelState('Insert Column Left');
            const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
            sheetData.forEach(row => row.splice(col, 0, ''));
            refreshExcelGrid();
            console.log('Inserted column left of', getColumnLetter(col));
        }
        
        // Insert column right
        function insertColumnRight(col) {
            saveExcelState('Insert Column Right');
            const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
            sheetData.forEach(row => row.splice(col + 1, 0, ''));
            refreshExcelGrid();
            console.log('Inserted column right of', getColumnLetter(col));
        }
        
        // Delete column
        function deleteColumn(col) {
            if (!confirm(`Delete column ${getColumnLetter(col)}?`)) return;
            
            saveExcelState('Delete Column');
            const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
            sheetData.forEach(row => row.splice(col, 1));
            refreshExcelGrid();
            console.log('Deleted column', getColumnLetter(col));
        }
        
        // Sort column
        function sortColumn(col, direction = 'asc') {
            saveExcelState('Sort Column');
            const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
            
            // Get all rows with data (skip header if needed)
            const dataRows = sheetData.map((row, index) => ({ row, index }));
            
            // Sort the rows based on column value
            dataRows.sort((a, b) => {
                const aVal = a.row[col] || '';
                const bVal = b.row[col] || '';
                
                // Try to parse as numbers
                const aNum = parseFloat(aVal);
                const bNum = parseFloat(bVal);
                
                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return direction === 'asc' ? aNum - bNum : bNum - aNum;
                }
                
                // Sort as strings
                const comparison = String(aVal).localeCompare(String(bVal));
                return direction === 'asc' ? comparison : -comparison;
            });
            
            // Update sheet data with sorted rows
            currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet] = dataRows.map(item => item.row);
            
            refreshExcelGrid();
            console.log('Sorted column', getColumnLetter(col), direction);
        }
        
        // Refresh the Excel grid
        function refreshExcelGrid() {
            const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
            const gridContainer = document.getElementById('excelGridContainer');
            if (gridContainer) {
                gridContainer.innerHTML = renderExcelGrid(sheetData);
                attachExcelCellListeners();
                setTimeout(() => recalculateAllFormulas(), 10);
            }
        }
        
        function handleExcelKeyboard(e) {
            const gridContainer = document.getElementById('excelGridContainer');
            const activeCell = document.querySelector('.excel-data-cell.excel-cell-selected');
            
            if (!gridContainer) return;
            
            // Save shortcut (Ctrl+S)
            if (e.ctrlKey && e.key === 's') {
                if (document.activeElement.classList.contains('excel-data-cell')) {
                    e.preventDefault();
                    saveExcelSpreadsheet();
                }
            }
            
            // Copy (Ctrl+C)
            if (e.ctrlKey && e.key === 'c' && activeCell) {
                e.preventDefault();
                copyExcelCells();
            }
            
            // Cut (Ctrl+X)
            if (e.ctrlKey && e.key === 'x' && activeCell) {
                e.preventDefault();
                cutExcelCells();
            }
            
            // Paste (Ctrl+V)
            if (e.ctrlKey && e.key === 'v' && activeCell) {
                e.preventDefault();
                pasteExcelCells();
            }
            
            // Undo (Ctrl+Z)
            if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undoExcel();
            }
            
            // Redo (Ctrl+Y or Ctrl+Shift+Z)
            if ((e.ctrlKey && e.key === 'y') || (e.ctrlKey && e.shiftKey && e.key === 'z')) {
                e.preventDefault();
                redoExcel();
            }
            
            // Delete cell content (Delete key)
            if (e.key === 'Delete' && activeCell && !activeCell.isContentEditable) {
                e.preventDefault();
                deleteExcelCellContent();
            }
            
            // Fill down (Ctrl+D)
            if (e.ctrlKey && e.key === 'd' && activeCell) {
                e.preventDefault();
                fillDown();
            }
            
            // Fill right (Ctrl+R)
            if (e.ctrlKey && e.key === 'r' && activeCell) {
                e.preventDefault();
                fillRight();
            }
            
            // Find (Ctrl+F)
            if (e.ctrlKey && e.key === 'f') {
                e.preventDefault();
                openFindDialog();
            }
            
            // Select All (Ctrl+A)
            if (e.ctrlKey && e.key === 'a' && document.activeElement.classList.contains('excel-data-cell')) {
                e.preventDefault();
                selectAllCells();
            }
            
            // Format Menu (Ctrl+Shift+F)
            if (e.ctrlKey && e.shiftKey && e.key === 'F') {
                e.preventDefault();
                showFormatMenu();
            }
            
            // Bold (Ctrl+B)
            if (e.ctrlKey && e.key === 'b' && activeCell) {
                e.preventDefault();
                applyCellFormatting('fontWeight', 'bold');
            }
            
            // Italic (Ctrl+I)
            if (e.ctrlKey && e.key === 'i' && activeCell) {
                e.preventDefault();
                applyCellFormatting('fontStyle', 'italic');
            }
            
            // Underline (Ctrl+U)
            if (e.ctrlKey && e.key === 'u' && activeCell) {
                e.preventDefault();
                applyCellFormatting('textDecoration', 'underline');
            }
        }

        // Create spreadsheet button handler
        if (createExcelButton) {
            createExcelButton.addEventListener('click', async () => {
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
                const defaultPath = await getDefaultDocumentsPath();
                const filePath = `${defaultPath}\\spreadsheet_${timestamp}.xlsx`;
                
                createExcelButton.disabled = true;
                createExcelButton.textContent = 'Creating...';
                
                try {
                    const response = await fetch('http://localhost:8000/api/excel/create', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            file_path: filePath,
                            sheet_name: 'Sheet1'
                        })
                    });

                    const data = await response.json();
                    if (response.ok && data.success) {
                        // Open the spreadsheet in the editor immediately
                        openExcelEditor(filePath, data.sheets || ['Sheet1'], data.active_sheet || 'Sheet1', null);
                    } else {
                        const errorMsg = data.detail || data.message || data.error || 'Failed to create spreadsheet';
                        alert('Error creating spreadsheet:\\n\\n' + errorMsg);
                    }
                } catch (error) {
                    console.error('Error creating spreadsheet:', error);
                    alert('Error creating spreadsheet: ' + error.message);
                } finally {
                    createExcelButton.disabled = false;
                    createExcelButton.textContent = 'Create Spreadsheet';
                }
            });
        }
        
        // Excel Open Modal - Get all elements first
        const excelOpenModal = document.getElementById('excelOpenModal');
        const excelOpenModalClose = document.getElementById('excelOpenModalClose');
        const excelOpenCancel = document.getElementById('excelOpenCancel');
        const excelOpenSubmit = document.getElementById('excelOpenSubmit');
        const excelOpenFilePath = document.getElementById('excelOpenFilePath');
        const excelOpenFilePathBrowse = document.getElementById('excelOpenFilePathBrowse');
        const excelOpenFileInput = document.getElementById('excelOpenFilePathInput');
        
        // Open spreadsheet button handler
        if (openExcelButton) {
            openExcelButton.addEventListener('click', () => {
                if (excelOpenModal) {
                    excelOpenModal.style.display = 'flex';
                    console.log('Modal opened');
                }
            });
        }
        
        // Close modal when clicking outside
        if (excelOpenModal) {
            excelOpenModal.addEventListener('click', (e) => {
                if (e.target === excelOpenModal) {
                    excelOpenModal.style.display = 'none';
                    console.log('Modal closed (clicked outside)');
                }
            });
        }
        
        // Close modal handlers
        if (excelOpenModalClose) {
            excelOpenModalClose.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (excelOpenModal) {
                    excelOpenModal.style.display = 'none';
                    console.log('Modal closed (X button)');
                }
            });
        } else {
            console.warn('X close button not found!');
        }
        
        if (excelOpenCancel) {
            excelOpenCancel.addEventListener('click', (e) => {
                e.preventDefault();
                if (excelOpenModal) {
                    excelOpenModal.style.display = 'none';
                    console.log('Modal closed (Cancel button)');
                }
            });
        } else {
            console.warn('Cancel button not found!');
        }
        
        // Add Escape key support
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && excelOpenModal && excelOpenModal.style.display === 'flex') {
                excelOpenModal.style.display = 'none';
                console.log('Modal closed (Escape key)');
            }
        });
        
        // Browse button for open modal
        console.log('Setting up browse button...');
        console.log('Browse button element:', excelOpenFilePathBrowse);
        console.log('File input element:', excelOpenFileInput);
        
        if (excelOpenFilePathBrowse && excelOpenFileInput) {
            console.log('Both elements found, adding event listener');
            
            excelOpenFilePathBrowse.addEventListener('click', async (e) => {
                console.log('Browse button clicked!');
                e.preventDefault();
                e.stopPropagation();
                
                // First, try using backend API to get full path via native dialog
                try {
                    console.log('Trying backend file picker API...');
                    
                    const defaultPath = await getDefaultDocumentsPath();
                    const response = await fetch(`http://localhost:8000/api/excel/select-file?initial_path=${encodeURIComponent(defaultPath)}`);
                    
                    if (response.ok) {
                        const result = await response.json();
                        console.log('Backend response:', result);
                        
                        if (result.success && result.file_path) {
                            // Got the full path from backend!
                            if (excelOpenFilePath) {
                                excelOpenFilePath.value = result.file_path;
                                console.log('‚úÖ Full path from backend:', result.file_path);
                            }
                            return; // Success, don't use HTML file input
                        } else if (result.cancelled) {
                            console.log('User cancelled file selection');
                            return;
                        }
                    }
                } catch (error) {
                    console.warn('Backend file picker not available:', error.message);
                }
                
                // Fallback: Use HTML file input
                console.log('Falling back to HTML file input...');
                excelOpenFileInput.click();
            });
        } else {
            console.error('Elements not found!', {
                browseButton: !!excelOpenFilePathBrowse,
                fileInput: !!excelOpenFileInput
            });
        }
        
        if (excelOpenFileInput) {
            console.log('Adding change listener to file input');
            
            // Handle file selection from Windows file picker
            excelOpenFileInput.addEventListener('change', async (e) => {
                console.log('File input change event fired');
                console.log('Files:', e.target.files);
                
                const file = e.target.files[0];
                if (file) {
                    console.log('File selected:', file);
                    console.log('File name:', file.name);
                    console.log('File size:', file.size);
                    console.log('File type:', file.type);
                    console.log('File path:', file.path);
                    console.log('File webkitRelativePath:', file.webkitRelativePath);
                    
                    // Try multiple ways to get the full path
                    let fullPath = null;
                    
                    // Method 1: Direct path property (works in Electron, pywebview, etc.)
                    if (file.path) {
                        fullPath = file.path;
                        console.log('‚úÖ Got path from file.path:', fullPath);
                    }
                    // Method 2: webkitRelativePath
                    else if (file.webkitRelativePath) {
                        fullPath = file.webkitRelativePath;
                        console.log('‚úÖ Got path from webkitRelativePath:', fullPath);
                    }
                    // Method 3: Check if File System Access API is available
                    else if (window.showOpenFilePicker) {
                        console.log('File System Access API available but not used yet');
                    }
                    
                    if (excelOpenFilePath) {
                        if (fullPath) {
                            // Full path is available
                            excelOpenFilePath.value = fullPath;
                            console.log('‚úÖ File path set to input:', fullPath);
                        } else {
                            // Path not available - just show filename
                            console.warn('‚ö†Ô∏è Full path not available');
                            excelOpenFilePath.value = file.name;
                            console.log('‚ÑπÔ∏è Set filename only:', file.name);
                            
                            // Update placeholder to guide user
                            excelOpenFilePath.setAttribute('data-filename-only', 'true');
                            excelOpenFilePath.select(); // Highlight so user can easily replace
                        }
                    }
                }
            });
        }
        
        // Open spreadsheet submit handler
        if (excelOpenSubmit) {
            excelOpenSubmit.addEventListener('click', async () => {
                const filePath = excelOpenFilePath ? excelOpenFilePath.value.trim() : '';
                
                if (!filePath) {
                    alert('Please enter the full file path to your Excel spreadsheet.\n\nExample: D:\\Documents\\data.xlsx');
                    if (excelOpenFilePath) excelOpenFilePath.focus();
                    return;
                }
                
                // Validate that it looks like a file path
                if (!filePath.includes('\\') && !filePath.includes('/')) {
                    alert('Please enter the FULL file path including the folder location.\n\nExample: D:\\Documents\\' + filePath);
                    return;
                }
                
                excelOpenSubmit.disabled = true;
                excelOpenSubmit.textContent = 'Opening...';
                
                try {
                    console.log('==========================================');
                    console.log('üìÇ Opening spreadsheet...');
                    console.log('File path:', filePath);
                    console.log('Request URL:', 'http://localhost:8000/api/excel/open');
                    
                    const response = await fetch('http://localhost:8000/api/excel/open', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            file_path: filePath
                        })
                    });
                    
                    console.log('Response status:', response.status, response.statusText);
                    
                    const data = await response.json();
                    console.log('Server response data:', JSON.stringify(data, null, 2));
                    
                    if (response.ok && data.success) {
                        console.log('‚úÖ Success! Opening editor...');
                        console.log('Sheets:', data.sheets);
                        console.log('Active sheet:', data.active_sheet);
                        console.log('Has data:', !!data.data);
                        // Close the modal
                        if (excelOpenModal) excelOpenModal.style.display = 'none';
                        
                        // Clear the input
                        if (excelOpenFilePath) excelOpenFilePath.value = '';
                        
                        // Transform the data from backend format to frontend format
                        let transformedData = {};
                        
                        console.log('üì¶ Processing backend data...');
                        console.log('Has all_sheets_data?', !!data.all_sheets_data);
                        console.log('all_sheets_data keys:', data.all_sheets_data ? Object.keys(data.all_sheets_data) : 'N/A');
                        
                        // Check if we have all sheets data (new format)
                        if (data.all_sheets_data && typeof data.all_sheets_data === 'object') {
                            console.log('‚úÖ Loading all sheets from all_sheets_data');
                            
                            // Transform each sheet's data
                            for (const [sheetName, sheetData] of Object.entries(data.all_sheets_data)) {
                                console.log(`Processing sheet: ${sheetName}, rows: ${sheetData.length}`);
                                
                                if (Array.isArray(sheetData)) {
                                    transformedData[sheetName] = sheetData.map(row => {
                                        return row.map(cell => {
                                            // Extract just the value or formula
                                            if (cell && typeof cell === 'object') {
                                                return cell.formula || cell.value || '';
                                            }
                                            return cell || '';
                                        });
                                    });
                                    console.log(`‚úÖ Transformed ${sheetName}: ${transformedData[sheetName].length} rows`);
                                }
                            }
                            
                            console.log('‚úÖ All sheets loaded:', Object.keys(transformedData));
                        }
                        // Fallback to old format (single sheet data)
                        else if (data.data && Array.isArray(data.data)) {
                            console.log('Loading single sheet from data field (backward compatibility)');
                            
                            const sheetData = data.data.map(row => {
                                return row.map(cell => {
                                    // Extract just the value or formula
                                    if (cell && typeof cell === 'object') {
                                        return cell.formula || cell.value || '';
                                    }
                                    return cell || '';
                                });
                            });
                            
                            const activeSheet = data.active_sheet || data.sheets?.[0] || 'Sheet1';
                            transformedData[activeSheet] = sheetData;
                            
                            // Initialize other sheets as empty if they exist
                            if (data.sheets && data.sheets.length > 1) {
                                data.sheets.forEach(sheetName => {
                                    if (sheetName !== activeSheet && !transformedData[sheetName]) {
                                        transformedData[sheetName] = Array(30).fill().map(() => Array(15).fill(''));
                                    }
                                });
                            }
                        }
                        
                        console.log('Transformed data structure:', transformedData);
                        
                        // Open the spreadsheet in the editor
                        openExcelEditor(
                            data.file_path || filePath,
                            data.sheets || ['Sheet1'],
                            data.active_sheet || data.sheets?.[0] || 'Sheet1',
                            transformedData
                        );
                        
                        console.log('‚úÖ Spreadsheet opened successfully!');
                        console.log('==========================================');
                    } else {
                        console.error('‚ùå Failed to open spreadsheet');
                        console.error('Response:', data);
                        const errorMsg = data.detail || data.message || data.error || 'Unknown error';
                        alert('‚ùå Error opening spreadsheet:\n\n' + errorMsg + '\n\nüìã Details:\n‚Ä¢ File: ' + filePath + '\n\n‚úì Make sure:\n1. The file exists at that location\n2. The path is correct\n3. The file is a valid .xlsx or .xls file\n4. The file is not open in another program');
                        console.log('==========================================');
                    }
                } catch (error) {
                    console.error('‚ùå Exception while opening spreadsheet');
                    console.error('Error:', error);
                    console.error('Stack:', error.stack);
                    alert('‚ùå Error opening spreadsheet:\n\n' + error.message + '\n\nüîß Please check:\n1. The backend server is running\n2. The file path is correct: ' + filePath + '\n3. You have permission to access the file\n4. Check the console (F12) for details');
                    console.log('==========================================');
                } finally {
                    excelOpenSubmit.disabled = false;
                    excelOpenSubmit.textContent = 'Open Spreadsheet';
                }
            });
        }

        // Check authentication on page load
        window.addEventListener('DOMContentLoaded', () => {
            const userId = localStorage.getItem('user_id');
            const authToken = localStorage.getItem('auth_token');
            
            if (!userId && authToken) {
                // Try to extract user_id from token
                try {
                    // JWT tokens have 3 parts separated by dots
                    const tokenParts = authToken.split('.');
                    if (tokenParts.length === 3) {
                        // Decode the payload (second part)
                        const payload = JSON.parse(atob(tokenParts[1]));
                        if (payload.user_id) {
                            localStorage.setItem('user_id', payload.user_id.toString());
                            console.log('[AUTH] Extracted user_id from token:', payload.user_id);
                        }
                    }
                } catch (e) {
                    console.warn('[AUTH] Could not extract user_id from token:', e);
                }
            }
            
            // Final check - if still no user_id, warn but don't block
            const finalUserId = localStorage.getItem('user_id');
            if (!finalUserId) {
                console.warn('[AUTH] No user_id found. Chat conversations will not be saved to database.');
                console.warn('[AUTH] Please log in again to enable conversation recording.');
            } else {
                console.log('[AUTH] User authenticated. user_id:', finalUserId);
            }
        });
    </script>
</body>
</html>
