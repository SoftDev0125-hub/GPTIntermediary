<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChatGPT Assistant - AI-Powered Automation</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <!-- For Telegram .tgs animated stickers (gzipped Lottie JSON) -->
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lottie-web@5.12.2/build/player/lottie.min.js"></script>
</head>
<body>
    <script>
        for(let i = 0; i < 30; i++) {
            let particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.left = Math.random() * 100 + '%';
            particle.style.animationDelay = Math.random() * 15 + 's';
            particle.style.animationDuration = (Math.random() * 10 + 10) + 's';
            document.body.appendChild(particle);
        }
    </script>

    <div class="container">
        <div class="tab-bar">
            <button class="tab-button active" data-tab="chat">Chat</button>
            <button class="tab-button" data-tab="email">Email</button>
            <button class="tab-button" data-tab="word">Word</button>
            <button class="tab-button" data-tab="excel">Excel</button>
            <button class="tab-button" data-tab="telegram">Telegram</button>
            <button class="tab-button" data-tab="whatsapp">WhatsApp</button>
            <button class="tab-button" data-tab="slack">Slack</button>
        </div>

        <div id="chat" class="tab-content active">
            <div class="header">
                <div class="header-content">
                    <h1>ChatGPT Assistant</h1>
                    <div class="status-badge">Online</div>
                </div>
            </div>

            <div class="chat-container" id="chatContainer">
                <div class="message system">
                    <div class="message-content">
                        <div class="welcome-header">
                            <div class="welcome-icon">‚ú®</div>
                            <h2>Welcome to ChatGPT Assistant!</h2>
                            <p class="welcome-subtitle">Your AI-powered automation system is ready to help</p>
                        </div>
                        <div class="help-features">
                            <div class="feature-item">
                                <span class="feature-icon">üöÄ</span>
                                <div class="feature-content">
                                    <strong>Launch Applications</strong>
                                    <p>Try: "Launch calculator" or "Open notepad"</p>
                                </div>
                            </div>
                            <div class="feature-item">
                                <span class="feature-icon">üìß</span>
                                <div class="feature-content">
                                    <strong>Send Emails</strong>
                                    <p>Try: "Send email to user@example.com"</p>
                                </div>
                            </div>
                            <div class="feature-item">
                                <span class="feature-icon">üí¨</span>
                                <div class="feature-content">
                                    <strong>Ask Questions</strong>
                                    <p>Ask me anything - I'm here to help!</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="typing-indicator" id="typingIndicator">
                <span></span>
                <span></span>
                <span></span>
            </div>

            <div class="input-container">
                <div class="input-wrapper">
                    <input 
                        type="text" 
                        id="messageInput" 
                        placeholder="Type your message or command..."
                        autocomplete="off"
                    />
                    <button id="sendButton" class="btn">Send</button>
                </div>
            </div>
        </div>

        <div id="email" class="tab-content">
            <div class="header">
                <div class="header-content">
                    <h1>Email Management</h1>
                    <div class="status-badge">Ready</div>
                </div>
            </div>

            <div class="email-container">
                <div class="email-header">
                    <h2>Inbox</h2>
                    <div class="email-count" id="emailCount">Unread: --</div>
                    <div class="button-group">
                        <button id="unreadButton" class="btn">Unread Mail</button>
                        <button id="refreshButton" class="btn btn-secondary">Refresh</button>
                    </div>
                </div>


                <div class="email-scroll-area">
                    <div class="pagination-controls pagination-top" id="paginationControlsTop" style="display: none;">
                        <button id="prevButtonTop" class="btn btn-pagination">‚Üê Previous</button>
                        <div class="page-numbers" id="pageNumbers"></div>
                        <button id="nextButtonTop" class="btn btn-pagination">Next ‚Üí</button>
                    </div>
                    <div id="emailList" class="email-list">
                        <div class="empty-state">
                            <div class="empty-state-text">Mail</div>
                            <p>Click "Unread Mail" to load your emails</p>
                        </div>
                    </div>
                    <div class="pagination-controls" id="paginationControls" style="display: none;">
                        <button id="prevButton" class="btn btn-pagination">‚Üê Previous</button>
                        <div class="page-numbers" id="pageNumbersBottom"></div>
                        <button id="nextButton" class="btn btn-pagination">Next ‚Üí</button>
                    </div>
                </div>

                <!-- Email Detail Modal - Beautiful Dialog -->
                <div class="email-detail-modal" id="emailDetailModal" style="display: none;">
                    <div class="email-detail-overlay"></div>
                    <div class="email-detail-container">
                        <div class="email-detail-header">
                            <div class="email-detail-header-content">
                                <h2 id="detailSubject" class="email-detail-subject">Subject</h2>
                                <button class="email-close-btn" id="closeEmailBtn" aria-label="Close">
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <line x1="18" y1="6" x2="6" y2="18"></line>
                                        <line x1="6" y1="6" x2="18" y2="18"></line>
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <div class="email-detail-info">
                            <div class="email-detail-info-row">
                                <div class="email-detail-info-item">
                                    <span class="email-detail-label">From:</span>
                                    <span id="detailFrom" class="email-detail-value">sender@example.com</span>
                                </div>
                                <div class="email-detail-info-item">
                                    <span class="email-detail-label">Date:</span>
                                    <span id="detailDate" class="email-detail-value">Date</span>
                                </div>
                            </div>
                        </div>
                        <div class="email-detail-body-container">
                            <div class="email-detail-body" id="detailBody">
                                <!-- Email body content here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Excel Tab -->
        <div id="excel" class="tab-content">
            <div class="header">
                <div class="header-content">
                    <h1>Microsoft Excel</h1>
                    <div class="status-badge">Ready</div>
                </div>
            </div>

            <div class="excel-container">
                <div class="excel-header">
                    <h2>Excel Spreadsheets</h2>
                    <div class="button-group">
                        <button id="createExcelButton" class="btn">Create Spreadsheet</button>
                        <button id="openExcelButton" class="btn btn-secondary">Open Spreadsheet</button>
                    </div>
                </div>

                <div class="excel-scroll-area">
                    <div id="excelSpreadsheetArea" class="excel-spreadsheet-area">
                        <div class="empty-state">
                            <div class="empty-state-text">üìä</div>
                            <h3>Excel Spreadsheet Manager</h3>
                            <p>Create a new spreadsheet or open an existing one to get started</p>
                            <div style="margin-top: 20px; text-align: left; max-width: 600px; background: rgba(0,0,0,0.05); padding: 16px; border-radius: 8px;">
                                <p style="font-weight: 600; margin-bottom: 12px;">Available Features:</p>
                                <ul style="margin: 8px 0; padding-left: 20px; line-height: 1.8;">
                                    <li>Create and open Excel spreadsheets (.xlsx)</li>
                                    <li>Edit cells with formulas and data</li>
                                    <li>Apply formatting (bold, italic, colors, borders)</li>
                                    <li>Work with multiple sheets</li>
                                    <li>Add formulas (SUM, AVERAGE, COUNT, etc.)</li>
                                    <li>Sort and filter data</li>
                                    <li>Merge and unmerge cells</li>
                                    <li>Adjust column widths and row heights</li>
                                    <li>Save and export spreadsheets</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Excel Create Modal -->
                <div class="excel-modal" id="excelCreateModal" style="display: none;">
                    <div class="excel-modal-content">
                        <div class="excel-modal-header">
                            <h3>Create New Spreadsheet</h3>
                            <button class="excel-modal-close" id="excelCreateModalClose">&times;</button>
                        </div>
                        <div class="excel-modal-body">
                            <div class="form-group">
                                <label for="excelFilePath">File Path:</label>
                                <div style="display: flex; gap: 8px; align-items: center;">
                                    <input type="text" id="excelFilePath" placeholder="D:\Documents\spreadsheet.xlsx" style="flex: 1;" />
                                    <button type="button" id="excelFilePathBrowse" class="btn btn-secondary" style="white-space: nowrap; padding: 8px 16px;">Browse</button>
                                </div>
                                <small>Enter the full path where the spreadsheet should be saved</small>
                            </div>
                            <div class="form-group">
                                <label for="excelSheetName">Sheet Name:</label>
                                <input type="text" id="excelSheetName" placeholder="Sheet1" value="Sheet1" />
                            </div>
                        </div>
                        <div class="excel-modal-footer">
                            <button class="btn btn-secondary" id="excelCreateCancel">Cancel</button>
                            <button class="btn" id="excelCreateSubmit">Create Spreadsheet</button>
                        </div>
                    </div>
                </div>

                <!-- Excel Open Modal -->
                <div class="excel-modal" id="excelOpenModal" style="display: none;">
                    <div class="excel-modal-content">
                        <div class="excel-modal-header">
                            <h3>Open Spreadsheet</h3>
                            <button class="excel-modal-close" id="excelOpenModalClose">&times;</button>
                        </div>
                        <div class="excel-modal-body">
                            <div class="form-group">
                                <label for="excelOpenFilePath">File Path:</label>
                                <div style="display: flex; gap: 8px; align-items: center;">
                                    <input type="text" id="excelOpenFilePath" placeholder="D:\Documents\spreadsheet.xlsx" style="flex: 1;" />
                                    <button type="button" id="excelOpenFilePathBrowse" class="btn btn-secondary" style="white-space: nowrap; padding: 8px 16px;">üìÅ Browse</button>
                                </div>
                                <input type="file" id="excelOpenFilePathInput" accept=".xlsx,.xls" style="display: none;" />
                                <small style="display: block; margin-top: 8px; color: #64748b;">
                                    üí° Click Browse to select a file, or type the full path manually.<br>
                                    Examples: <code style="color: #6366f1;">D:\Documents\data.xlsx</code> or <code style="color: #6366f1;">C:\Users\YourName\Desktop\report.xlsx</code>
                                </small>
                            </div>
                        </div>
                        <div class="excel-modal-footer">
                            <button class="btn btn-secondary" id="excelOpenCancel">Cancel</button>
                            <button class="btn" id="excelOpenSubmit">Open Spreadsheet</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Excel Save As Modal -->
        <div class="excel-modal" id="excelSaveAsModal" style="display: none;">
            <div class="excel-modal-content">
                <div class="excel-modal-header">
                    <h3>Save Spreadsheet As</h3>
                    <button class="excel-modal-close" id="excelSaveAsModalClose">&times;</button>
                </div>
                <div class="excel-modal-body">
                    <div class="form-group">
                        <label for="excelSaveAsFolderPath">Folder Path:</label>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <input type="text" id="excelSaveAsFolderPath" placeholder="D:\Documents" style="flex: 1;" />
                            <button type="button" id="excelSaveAsFolderPathBrowse" class="btn btn-secondary" style="white-space: nowrap; padding: 8px 16px;">Browse Folder</button>
                        </div>
                        <small>Select the folder where you want to save the spreadsheet</small>
                    </div>
                    <div class="form-group" style="margin-top: 16px;">
                        <label for="excelSaveAsFileName">File Name:</label>
                        <input type="text" id="excelSaveAsFileName" placeholder="spreadsheet.xlsx" style="width: 100%;" />
                        <small>Enter the file name (include .xlsx extension or it will be added automatically)</small>
                    </div>
                </div>
                <div class="excel-modal-footer">
                    <button class="btn btn-secondary" id="excelSaveAsCancel">Cancel</button>
                    <button class="btn" id="excelSaveAsSubmit">Save</button>
                </div>
            </div>
        </div>


        <div id="telegram" class="tab-content">
            <div class="telegram-container">
                <!-- Telegram Sidebar -->
                <div class="telegram-sidebar">
                    <div class="telegram-sidebar-header">
                        <h2>Chats</h2>
                        <button id="telegramShowButton" class="telegram-refresh-btn">Refresh</button>
                </div>
                    <div class="telegram-sidebar-content" id="telegramChatsList">
                        <div class="telegram-sidebar-empty">Click "Refresh" to load chats</div>
                    </div>
                </div>

                <!-- Telegram Main Area -->
                <div class="telegram-main">
                    <div class="telegram-header">
                        <div class="telegram-header-content">
                            <h2 id="telegramCurrentChat">Select a chat</h2>
                            <div class="telegram-header-info" id="telegramCount">-- messages</div>
                            <div class="telegram-header-actions">
                                <button id="telegramEditLastBtn" class="telegram-header-btn" disabled>Edit last</button>
                                <button id="telegramClearChatBtn" class="telegram-header-btn telegram-header-btn-danger" disabled>Clear</button>
                            </div>
                        </div>
                    </div>
                    <div class="telegram-messages-container" id="telegramMessagesContainer">
                        <div class="telegram-empty-state">
                            <div class="telegram-empty-icon">‚úàÔ∏è</div>
                            <h3>Welcome to Telegram</h3>
                            <p>Select a chat from the sidebar or click "Refresh" to load your messages</p>
                </div>
                        </div>
                    <div class="telegram-input-container" id="telegramInputContainer" style="display: none;">
                        <div class="telegram-input-wrapper">
                            <button id="telegramAttachButton" class="telegram-attach-button" title="Attach file" disabled>üìé</button>
                            <input type="file" id="telegramFileInput" style="display: none;" />
                            <textarea 
                                id="telegramMessageInput" 
                                class="telegram-message-input" 
                                placeholder="Type a message..."
                                rows="1"
                            ></textarea>
                            <button id="telegramSendButton" class="telegram-send-button" disabled>
                                <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                                    <path d="M18 2L9 11M18 2L12 18L9 11M18 2L2 8L9 11" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </button>
                            </div>
                            </div>
                </div>
            </div>
        </div>

        <div id="word" class="tab-content">
            <div class="header">
                <div class="header-content">
                    <h1>Microsoft Word</h1>
                    <div class="status-badge">Ready</div>
                </div>
            </div>

            <div class="word-container">
                <div class="word-header">
                    <h2>Word Documents</h2>
                    <div class="button-group">
                        <button id="createWordDocButton" class="btn">Create Document</button>
                        <button id="openWordDocButton" class="btn btn-secondary">Open Document</button>
                    </div>
                </div>

                <div class="word-scroll-area">
                    <div id="wordDocumentArea" class="word-document-area">
                        <div class="empty-state">
                            <div class="empty-state-text">üìÑ</div>
                            <h3>Word Document Manager</h3>
                            <p>Create a new document or open an existing one to get started</p>
                            <div style="margin-top: 20px; text-align: left; max-width: 600px; background: rgba(0,0,0,0.05); padding: 16px; border-radius: 8px;">
                                <p style="font-weight: 600; margin-bottom: 12px;">Available Features:</p>
                                <ul style="margin: 8px 0; padding-left: 20px; line-height: 1.8;">
                                    <li>Create and open Word documents</li>
                                    <li>Add formatted text (bold, italic, underline, fonts, colors)</li>
                                    <li>Format paragraphs (alignment, spacing, indentation)</li>
                                    <li>Add headings, lists, and tables</li>
                                    <li>Find and replace text</li>
                                    <li>Configure page setup (margins, orientation, page size)</li>
                                    <li>Save documents</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Word Document Creation Modal -->
                <div class="word-modal" id="wordCreateModal" style="display: none;">
                    <div class="word-modal-content">
                        <div class="word-modal-header">
                            <h3>Create New Document</h3>
                            <button class="word-modal-close" id="wordCreateModalClose">&times;</button>
                        </div>
                        <div class="word-modal-body">
                            <div class="form-group">
                                <label for="wordFilePath">File Path:</label>
                                <div style="display: flex; gap: 8px; align-items: center;">
                                    <input type="text" id="wordFilePath" placeholder="C:\Users\Username\Documents\document.docx" style="flex: 1;" />
                                    <button type="button" id="wordFilePathBrowse" class="btn btn-secondary" style="white-space: nowrap; padding: 8px 16px;">Browse</button>
                                </div>
                                <input type="file" id="wordFilePathInput" accept=".docx" style="display: none;" />
                                <small>Enter the full path where you want to save the document, or click Browse to select a location</small>
                            </div>
                            <div class="form-group">
                                <label for="wordDocTitle">Document Title (optional):</label>
                                <input type="text" id="wordDocTitle" placeholder="My Document" />
                            </div>
                            <div class="form-group">
                                <label for="wordDocContent">Initial Content (optional):</label>
                                <textarea id="wordDocContent" rows="5" placeholder="Enter initial content for your document..."></textarea>
                            </div>
                        </div>
                        <div class="word-modal-footer">
                            <button class="btn btn-secondary" id="wordCreateCancel">Cancel</button>
                            <button class="btn" id="wordCreateSubmit">Create Document</button>
                        </div>
                    </div>
                </div>

                <!-- Word Document Open Modal -->
                <div class="word-modal" id="wordOpenModal" style="display: none;">
                    <div class="word-modal-content">
                        <div class="word-modal-header">
                            <h3>Open Document</h3>
                            <button class="word-modal-close" id="wordOpenModalClose">&times;</button>
                        </div>
                        <div class="word-modal-body">
                            <div class="form-group">
                                <label for="wordOpenFilePath">File Path:</label>
                                <div style="display: flex; gap: 8px; align-items: center;">
                                    <input type="text" id="wordOpenFilePath" placeholder="C:\Users\Username\Documents\document.docx" style="flex: 1;" />
                                    <button type="button" id="wordOpenFilePathBrowse" class="btn btn-secondary" style="white-space: nowrap; padding: 8px 16px;">Browse</button>
                                </div>
                                <input type="file" id="wordOpenFilePathInput" accept=".docx" style="display: none;" />
                                <small>Enter the full path to the Word document you want to open, or click Browse to select a file</small>
                            </div>
                        </div>
                        <div class="word-modal-footer">
                            <button class="btn btn-secondary" id="wordOpenCancel">Cancel</button>
                            <button class="btn" id="wordOpenSubmit">Open Document</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Word Document Save As Modal -->
        <div class="word-modal" id="wordSaveAsModal" style="display: none;">
            <div class="word-modal-content">
                <div class="word-modal-header">
                    <h3>Save As</h3>
                    <button class="word-modal-close" id="wordSaveAsModalClose">&times;</button>
                </div>
                <div class="word-modal-body">
                    <div class="form-group">
                        <label for="wordSaveAsFolderPath">Folder Path:</label>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <input type="text" id="wordSaveAsFolderPath" placeholder="C:\Users\Username\Documents" style="flex: 1;" />
                            <button type="button" id="wordSaveAsFolderPathBrowse" class="btn btn-secondary" style="white-space: nowrap; padding: 8px 16px;">Browse Folder</button>
                        </div>
                        <small>Select the folder where you want to save the document</small>
                    </div>
                    <div class="form-group" style="margin-top: 16px;">
                        <label for="wordSaveAsFileName">File Name:</label>
                        <input type="text" id="wordSaveAsFileName" placeholder="document.docx" style="width: 100%;" />
                        <small>Enter the file name (include .docx extension or it will be added automatically)</small>
                    </div>
                </div>
                <div class="word-modal-footer">
                    <button class="btn btn-secondary" id="wordSaveAsCancel">Cancel</button>
                    <button class="btn" id="wordSaveAsSubmit">Save</button>
                </div>
            </div>
        </div>

        <!-- Folder Browser Dialog for Save As -->
        <div class="word-modal" id="wordFolderBrowserDialog" style="display: none; z-index: 2001;">
            <div class="word-modal-content" style="max-width: 800px; width: 90%; max-height: 85vh; display: flex; flex-direction: column;">
                <div class="word-modal-header" style="flex-shrink: 0;">
                    <h3>Select Folder</h3>
                    <button class="word-modal-close" id="wordFolderBrowserDialogClose">&times;</button>
                </div>
                
                <!-- Navigation Bar -->
                <div style="padding: 8px 16px; background: #f5f5f5; border-bottom: 1px solid #ddd; display: flex; align-items: center; gap: 8px; flex-shrink: 0;">
                    <button type="button" id="wordFolderBrowserNavUp" class="word-nav-btn" title="Up" style="width: 32px; height: 32px; padding: 0; border: 1px solid #ccc; background: white; border-radius: 2px; cursor: pointer;">‚Üë</button>
                    <div id="wordFolderBrowserPathBreadcrumb" style="flex: 1; padding: 4px 8px; background: white; border: 1px solid #ccc; border-radius: 2px; font-size: 12px; color: #333; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                        <!-- Path breadcrumb will be shown here -->
                    </div>
                    <button type="button" id="wordFolderBrowserRefresh" class="word-nav-btn" title="Refresh" style="width: 32px; height: 32px; padding: 0; border: 1px solid #ccc; background: white; border-radius: 2px; cursor: pointer;">‚Üª</button>
                </div>

                <!-- Folder List -->
                <div style="flex: 1; overflow-y: auto; background: white; padding: 4px 0; min-height: 300px;">
                    <div id="wordFolderBrowserContent" style="padding: 8px;">
                        <!-- Folders will be listed here -->
                    </div>
                </div>

                <!-- Bottom Section -->
                <div style="padding: 12px 16px; background: #f5f5f5; border-top: 1px solid #ddd; flex-shrink: 0; display: flex; justify-content: flex-end; gap: 8px;">
                    <button class="btn btn-secondary" id="wordFolderBrowserCancel">Cancel</button>
                    <button class="btn" id="wordFolderBrowserSelect">Select Folder</button>
                </div>
            </div>
        </div>

        <!-- File Browser Dialog (Windows-style) -->
        <div class="word-modal" id="wordFileBrowserDialog" style="display: none; z-index: 2000;">
            <div class="word-modal-content" style="max-width: 900px; width: 90%; max-height: 85vh; display: flex; flex-direction: column;">
                <div class="word-modal-header" style="flex-shrink: 0;">
                    <h3 id="wordBrowserDialogTitle">Open</h3>
                    <button class="word-modal-close" id="wordFileBrowserDialogClose">&times;</button>
                </div>
                
                <!-- Navigation Bar -->
                <div style="padding: 8px 16px; background: #f5f5f5; border-bottom: 1px solid #ddd; display: flex; align-items: center; gap: 8px; flex-shrink: 0;">
                    <button type="button" id="wordBrowserNavBack" class="word-nav-btn" title="Back" style="width: 32px; height: 32px; padding: 0; border: 1px solid #ccc; background: white; border-radius: 2px; cursor: pointer;">‚Üê</button>
                    <button type="button" id="wordBrowserNavForward" class="word-nav-btn" title="Forward" style="width: 32px; height: 32px; padding: 0; border: 1px solid #ccc; background: white; border-radius: 2px; cursor: pointer;">‚Üí</button>
                    <button type="button" id="wordBrowserNavUp" class="word-nav-btn" title="Up" style="width: 32px; height: 32px; padding: 0; border: 1px solid #ccc; background: white; border-radius: 2px; cursor: pointer;">‚Üë</button>
                    <div id="wordBrowserPathBreadcrumb" style="flex: 1; padding: 4px 8px; background: white; border: 1px solid #ccc; border-radius: 2px; font-size: 12px; color: #333; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                        <!-- Path breadcrumb will be shown here -->
                    </div>
                    <button type="button" id="wordBrowserRefresh" class="word-nav-btn" title="Refresh" style="width: 32px; height: 32px; padding: 0; border: 1px solid #ccc; background: white; border-radius: 2px; cursor: pointer;">‚Üª</button>
                </div>

                <!-- Main Content Area -->
                <div style="display: flex; flex: 1; min-height: 0; overflow: hidden;">
                    <!-- Left Sidebar -->
                    <div style="width: 220px; background: #f9f9f9; border-right: 1px solid #ddd; padding: 12px; overflow-y: auto; flex-shrink: 0;">
                        <div style="margin-bottom: 16px;">
                            <div style="font-size: 11px; font-weight: 600; color: #666; margin-bottom: 8px; text-transform: uppercase;">Quick Access</div>
                            <div id="wordBrowserQuickAccess" style="display: flex; flex-direction: column; gap: 2px;">
                                <!-- Quick access items will be added here -->
                            </div>
                        </div>
                        <div>
                            <div style="font-size: 11px; font-weight: 600; color: #666; margin-bottom: 8px; text-transform: uppercase;">Folders</div>
                            <div id="wordBrowserFolderTree" style="display: flex; flex-direction: column; gap: 2px;">
                                <!-- Folder tree will be added here -->
                            </div>
                        </div>
                    </div>

                    <!-- Main File List -->
                    <div style="flex: 1; display: flex; flex-direction: column; overflow: hidden;">
                        <!-- File List Header -->
                        <div style="padding: 8px 16px; background: #f5f5f5; border-bottom: 1px solid #ddd; display: grid; grid-template-columns: 2fr 1.5fr 1fr; gap: 16px; font-size: 12px; font-weight: 600; color: #666; flex-shrink: 0;">
                            <div>Name</div>
                            <div>Date modified</div>
                            <div>Type</div>
                        </div>
                        <!-- File List Content -->
                        <div id="wordBrowserDialogContent" style="flex: 1; overflow-y: auto; background: white; padding: 4px 0;">
                            <!-- Files and folders will be listed here -->
                        </div>
                    </div>
                </div>

                <!-- Bottom Section -->
                <div style="padding: 12px 16px; background: #f5f5f5; border-top: 1px solid #ddd; flex-shrink: 0;">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
                        <label style="font-size: 12px; color: #333; white-space: nowrap;">File name:</label>
                        <input type="text" id="wordBrowserFileName" style="flex: 1; padding: 4px 8px; border: 1px solid #ccc; border-radius: 2px; font-size: 12px;" placeholder="Enter file name or select from list" />
                    </div>
                    <div style="display: flex; align-items: center; gap: 12px; justify-content: flex-end;">
                        <label style="font-size: 12px; color: #333; white-space: nowrap;">Files of type:</label>
                        <select id="wordBrowserFileType" style="padding: 4px 8px; border: 1px solid #ccc; border-radius: 2px; font-size: 12px; background: white;">
                            <option value=".docx">Word Documents (*.docx)</option>
                            <option value="*">All Files (*.*)</option>
                        </select>
                    </div>
                </div>

                <!-- Footer Buttons -->
                <div class="word-modal-footer" style="flex-shrink: 0;">
                    <button class="btn" id="wordFileBrowserDialogOpen" style="min-width: 80px;">Open</button>
                    <button class="btn btn-secondary" id="wordFileBrowserDialogCancel" style="min-width: 80px;">Cancel</button>
                </div>
            </div>
        </div>

        <div id="slack" class="tab-content">
            <div class="slack-container">
                <!-- Slack Sidebar (Address Book) -->
                <div class="slack-sidebar">
                    <div class="slack-sidebar-header">
                        <h2>Channels</h2>
                        <button id="slackShowButton" class="slack-refresh-btn">Refresh</button>
                    </div>
                    <div class="slack-sidebar-content" id="slackChannelsList">
                        <div class="slack-sidebar-empty">Click "Refresh" to load channels</div>
                    </div>
                </div>

                <!-- Slack Main Area -->
                <div class="slack-main">
                    <div class="slack-header">
                        <div class="slack-header-content">
                            <h2 id="slackCurrentChannel">Slack</h2>
                            <div class="slack-header-info" id="slackStatus"></div>
                        </div>
                    </div>
                    <div class="slack-messages-container" id="slackMessagesContainer">
                        <!-- Authenticated State (shown when authenticated but no channel selected) -->
                        <div class="slack-empty-state" id="slackEmptyState">
                            <div class="slack-empty-icon">üí¨</div>
                            <h3>Welcome to Slack</h3>
                            <p>Click "Refresh" in the sidebar to load your channels</p>
                            <p style="color: #8696a0; font-size: 14px; margin-top: 10px;">You are connected to Slack. You can send and receive messages.</p>
                        </div>
                    </div>
                    <div class="slack-input-container" id="slackInputContainer" style="display: none;">
                        <div class="slack-input-wrapper">
                            <textarea 
                                id="slackMessageInput" 
                                class="slack-message-input" 
                                placeholder="Type a message..."
                                rows="1"
                            ></textarea>
                            <button id="slackSendButton" class="slack-send-button" disabled>
                                <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                                    <path d="M18 2L9 11M18 2L12 18L9 11M18 2L2 8L9 11" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="whatsapp" class="tab-content">
            <div class="whatsapp-container">
                <!-- WhatsApp Sidebar (Address Book) -->
                <div class="whatsapp-sidebar">
                    <div class="whatsapp-sidebar-header">
                        <h2>Chats</h2>
                        <button id="whatsappShowButton" class="whatsapp-refresh-btn">Refresh</button>
                    </div>
                    <div class="whatsapp-sidebar-content" id="whatsappChatsList">
                        <div class="whatsapp-sidebar-empty">Click "Refresh" to load chats</div>
                    </div>
                </div>

                <!-- WhatsApp Main Area -->
                <div class="whatsapp-main">
                    <div class="whatsapp-header">
                        <div class="whatsapp-header-content">
                            <h2 id="whatsappCurrentChat">WhatsApp</h2>
                            <div class="whatsapp-header-info" id="whatsappStatus"></div>
                        </div>
                    </div>
                    <div class="whatsapp-messages-container" id="whatsappMessagesContainer">
                        <!-- QR Code Display (shown when not authenticated) -->
                        <div class="whatsapp-qr-container" id="whatsappQrContainer" style="display: none;">
                            <div class="whatsapp-qr-content">
                                <div class="whatsapp-qr-icon">üì±</div>
                                <h3 id="whatsappQrTitle">Scan QR Code to Connect</h3>
                                <p id="whatsappQrDescription">Open WhatsApp on your phone and scan this code</p>
                                <div class="whatsapp-qr-image-wrapper" id="whatsappQrImageWrapper">
                                    <img id="whatsappQrImage" src="" alt="WhatsApp QR Code" class="whatsapp-qr-image" />
                                </div>
                                <p class="whatsapp-qr-status" id="whatsappQrStatus">Loading QR code...</p>
                                <button id="whatsappQrRefreshBtn" class="whatsapp-qr-refresh-btn" style="display: none;">Refresh QR Code</button>
                            </div>
                        </div>
                        
                        <!-- Authenticated State (shown when authenticated but no chat selected) -->
                        <div class="whatsapp-empty-state" id="whatsappEmptyState">
                            <div class="whatsapp-empty-icon">üí¨</div>
                            <h3>Welcome to WhatsApp</h3>
                            <p>Click "Refresh" in the sidebar to load your chats</p>
                            <p style="color: #8696a0; font-size: 14px; margin-top: 10px;">You are connected to WhatsApp. You can send and receive messages.</p>
                        </div>
                    </div>
                    <div class="whatsapp-input-container" id="whatsappInputContainer" style="display: none;">
                        <div class="whatsapp-input-wrapper">
                            <textarea 
                                id="whatsappMessageInput" 
                                class="whatsapp-message-input" 
                                placeholder="Type a message..."
                                rows="1"
                            ></textarea>
                            <button id="whatsappSendButton" class="whatsapp-send-button" disabled>
                                <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                                    <path d="M18 2L9 11M18 2L12 18L9 11M18 2L2 8L9 11" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>                
            </div>
        </div>

    </div>

    <script>
        // Main tab switching function - defined globally so it's accessible everywhere
        function switchTab(tabName) {
            if (!tabName) {
                console.error('switchTab called without tabName');
                return;
            }
            
            console.log('Switching to tab:', tabName);
            
            try {
                // Remove active class from all tabs and buttons
                const allButtons = document.querySelectorAll('.tab-button');
                const allContents = document.querySelectorAll('.tab-content');
                
                allButtons.forEach(b => {
                    b.classList.remove('active');
                });
                
                allContents.forEach(c => {
                    c.classList.remove('active');
                });
                
                // Add active class to selected tab and button
                const button = document.querySelector(`.tab-button[data-tab="${tabName}"]`);
                const content = document.getElementById(tabName);
                
                if (button) {
                    button.classList.add('active');
                    console.log('Button activated:', tabName);
                } else {
                    console.error('Button not found for tab:', tabName);
                    console.log('Available tabs:', Array.from(document.querySelectorAll('.tab-button')).map(b => b.dataset.tab));
                }
                
                if (content) {
                    content.classList.add('active');
                    console.log('Content activated:', tabName);
                } else {
                    console.error('Content not found for tab:', tabName);
                    console.log('Available content divs:', Array.from(document.querySelectorAll('.tab-content')).map(c => c.id));
                }
                
                if (tabName === 'chat') {
                    const messageInput = document.getElementById('messageInput');
                    if (messageInput) {
                        setTimeout(() => messageInput.focus(), 100);
                    }
                }
            } catch (error) {
                console.error('Error in switchTab:', error);
            }
        }
        
        // Initialize tab switching when DOM is ready
        function initTabSwitching() {
            try {
                // Add event listeners to all tab buttons
                const tabButtons = document.querySelectorAll('.tab-button');
                console.log('Found tab buttons:', tabButtons.length);
                
                if (tabButtons.length === 0) {
                    console.warn('No tab buttons found! Retrying in 100ms...');
                    setTimeout(initTabSwitching, 100);
                    return;
                }
                
                tabButtons.forEach(button => {
                    // Remove any existing listeners by cloning and replacing
                    const newButton = button.cloneNode(true);
                    button.parentNode.replaceChild(newButton, button);
                    
                    // Add click listener to the new button
                    newButton.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const tabName = this.dataset.tab;
                        console.log('Tab button clicked:', tabName);
                        
                        if (tabName) {
                            switchTab(tabName);
                        } else {
                            console.error('No tab name found for button');
                        }
                        
                        return false;
                    });
                });
                
                console.log('Tab switching initialized successfully');
            } catch (error) {
                console.error('Error initializing tab switching:', error);
            }
        }
        
        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                setTimeout(initTabSwitching, 50);
            });
        } else {
            // DOM is already loaded
            setTimeout(initTabSwitching, 50);
        }

        const chatContainer = document.getElementById('chatContainer');
        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const typingIndicator = document.getElementById('typingIndicator');

        // Store conversation history for context
        let conversationHistory = [];

        function addMessage(text, type = 'assistant') {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            // Render markdown and format the message
            let formattedText = renderMarkdown(text);
            
            // Enhance emoji and icon display
            formattedText = enhanceIconsAndEmojis(formattedText);
            
            contentDiv.innerHTML = formattedText;
            
            messageDiv.appendChild(contentDiv);
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
            
            // Store in conversation history (limit to prevent memory issues)
            conversationHistory.push({
                role: type === 'user' ? 'user' : 'assistant',
                content: text
            });
            
            // Keep only last 20 messages (10 exchanges)
            if (conversationHistory.length > 20) {
                conversationHistory = conversationHistory.slice(-20);
            }
        }

        function renderMarkdown(text) {
            if (!text) return '';
            
            // Split into lines for processing
            const lines = text.split('\n');
            let html = '';
            let inCodeBlock = false;
            let inList = false;
            let listType = null; // 'ul' or 'ol'
            let listItems = [];
            
            // Helper function to close current list
            function closeList() {
                if (inList && listItems.length > 0) {
                    html += listType === 'ol' ? '<ol>' : '<ul>';
                    html += listItems.map(item => '<li>' + processInlineMarkdown(item) + '</li>').join('');
                    html += listType === 'ol' ? '</ol>' : '</ul>';
                    listItems = [];
                }
                inList = false;
                listType = null;
            }
            
            // Helper function to start a new list
            function startList(type) {
                if (inList && listType !== type) {
                    closeList();
                }
                if (!inList) {
                    inList = true;
                    listType = type;
                }
            }
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmed = line.trim();
                
                // Code blocks
                if (trimmed.startsWith('```')) {
                    if (inCodeBlock) {
                        // Close code block
                        html += '<pre><code>' + escapeHtml(listItems.join('\n')) + '</code></pre>';
                        listItems = [];
                        inCodeBlock = false;
                    } else {
                        // Close any open list first
                        closeList();
                        inCodeBlock = true;
                        listItems = [];
                    }
                    continue;
                }
                
                if (inCodeBlock) {
                    listItems.push(line);
                    continue;
                }
                
                // Headers
                if (trimmed.startsWith('### ')) {
                    closeList();
                    html += '<h3>' + processInlineMarkdown(trimmed.substring(4)) + '</h3>';
                    continue;
                }
                if (trimmed.startsWith('## ')) {
                    closeList();
                    html += '<h2>' + processInlineMarkdown(trimmed.substring(3)) + '</h2>';
                    continue;
                }
                if (trimmed.startsWith('# ')) {
                    closeList();
                    html += '<h1>' + processInlineMarkdown(trimmed.substring(2)) + '</h1>';
                    continue;
                }
                
                // Numbered lists (1. item)
                const numberedMatch = trimmed.match(/^(\d+)\.\s+(.+)$/);
                if (numberedMatch) {
                    startList('ol');
                    listItems.push(numberedMatch[2]);
                    continue;
                }
                
                // Bullet lists (- item or * item)
                const bulletMatch = trimmed.match(/^[-*]\s+(.+)$/);
                if (bulletMatch) {
                    startList('ul');
                    listItems.push(bulletMatch[1]);
                    continue;
                }
                
                // Empty line - don't close list, just add a break
                // Lists will only close when encountering non-list content
                if (trimmed === '') {
                    html += '<br>';
                    continue;
                }
                
                // Regular paragraph - close list if open
                if (inList) {
                    closeList();
                }
                
                html += '<p>' + processInlineMarkdown(line) + '</p>';
            }
            
            // Close any remaining list
            closeList();
            
            // Close any remaining code block
            if (inCodeBlock) {
                html += '<pre><code>' + escapeHtml(listItems.join('\n')) + '</code></pre>';
            }
            
            return html;
        }
        
        function processInlineMarkdown(text) {
            if (!text) return '';
            
            // Escape HTML first
            let html = escapeHtml(text);
            
            // Inline code (`code`) - do this before bold/italic
            html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
            
            // Bold (**text** or __text__)
            html = html.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/__([^_]+)__/g, '<strong>$1</strong>');
            
            // Italic (*text* or _text_) - but not if it's part of bold
            html = html.replace(/(?<!\*)\*([^*]+)\*(?!\*)/g, '<em>$1</em>');
            html = html.replace(/(?<!_)_([^_]+)_(?!_)/g, '<em>$1</em>');
            
            // Links [text](url)
            html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>');
            
            return html;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function enhanceIconsAndEmojis(text) {
            // Wrap standalone emojis in a span for better styling
            text = text.replace(/([\u{1F300}-\u{1F9FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}])/gu, '<span class="emoji-icon">$1</span>');
            
            // Convert common text patterns to visual icons
            text = text.replace(/\b(‚úì|‚úîÔ∏è|‚úÖ)/g, '<span class="icon-success">$1</span>');
            text = text.replace(/\b(‚úó|‚ùå|‚õî)/g, '<span class="icon-error">$1</span>');
            text = text.replace(/\b(‚ÑπÔ∏è|‚Ñπ|üí°)/g, '<span class="icon-info">$1</span>');
            text = text.replace(/\b(‚ö†Ô∏è|‚ö†|‚ö°)/g, '<span class="icon-warning">$1</span>');
            
            // Enhance bullet points with icons
            text = text.replace(/‚Ä¢/g, '<span class="bullet-icon">‚Ä¢</span>');
            text = text.replace(/‚Üí/g, '<span class="arrow-icon">‚Üí</span>');
            
            return text;
        }

        async function sendMessage() {
            const message = messageInput.value.trim();
            if (!message) return;

            addMessage(message, 'user');
            messageInput.value = '';
            sendButton.disabled = true;

            typingIndicator.classList.add('active');

            // Get user_id from localStorage (set during login)
            const userId = localStorage.getItem('user_id');
            
            // Validate user_id
            let userIdInt = null;
            if (userId) {
                const parsed = parseInt(userId, 10);
                if (!isNaN(parsed) && parsed > 0) {
                    userIdInt = parsed;
                } else {
                    console.warn('[CHAT] Invalid user_id in localStorage:', userId);
                }
            } else {
                // Try to get user_id from token if not in localStorage
                const authToken = localStorage.getItem('auth_token');
                if (authToken) {
                    try {
                        const tokenParts = authToken.split('.');
                        if (tokenParts.length === 3) {
                            const payload = JSON.parse(atob(tokenParts[1]));
                            if (payload.user_id) {
                                userIdInt = parseInt(payload.user_id, 10);
                                localStorage.setItem('user_id', userIdInt.toString());
                                console.log('[CHAT] Extracted user_id from token:', userIdInt);
                            }
                        }
                    } catch (e) {
                        console.warn('[CHAT] Could not extract user_id from token');
                    }
                }
                
                if (!userIdInt) {
                    console.warn('[CHAT] No user_id found. Chat will work but conversations will not be saved to database.');
                }
            }

            // Add timeout to prevent hanging requests (15 seconds for faster feedback)
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 15000);
            
            console.log('[CHAT] Sending message:', message);
            console.log('[CHAT] User ID:', userIdInt);
            
            try {
                const response = await fetch('http://localhost:5000/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        message: message,
                        user_id: userIdInt,  // Send validated user_id
                        history: conversationHistory  // Send conversation history for context
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                // Check if response is ok before trying to parse JSON
                if (!response.ok) {
                    typingIndicator.classList.remove('active');
                    let errorData;
                    try {
                        errorData = await response.json();
                    } catch (e) {
                        errorData = { error: `HTTP ${response.status}: ${response.statusText}` };
                    }
                    addMessage(`ERROR: ${errorData.error || errorData.detail || 'Unknown error'}`, 'error');
                    sendButton.disabled = false;
                    messageInput.focus();
                    return;
                }

                const data = await response.json();
                typingIndicator.classList.remove('active');
                
                console.log('[CHAT] Response data:', data);

                if (data.response) {
                    addMessage(data.response, 'assistant');
                } else {
                    const errorMsg = data.error || data.detail || 'No response received';
                    console.error('[CHAT] Error in response:', errorMsg);
                    addMessage(`ERROR: ${errorMsg}`, 'error');
                }
            } catch (error) {
                clearTimeout(timeoutId);
                typingIndicator.classList.remove('active');
                
                if (error.name === 'AbortError') {
                    console.error('[CHAT] Request timeout after 15 seconds');
                    addMessage('TIMEOUT: The request took too long (15 seconds). Please try again with a shorter question.', 'error');
                } else {
                    console.error('[CHAT] Connection error:', error);
                    addMessage(`CONNECTION ERROR: ${error.message}. Make sure the chat server is running on port 5000.`, 'error');
                }
            } finally {
                sendButton.disabled = false;
                messageInput.focus();
            }
        }

        sendButton.addEventListener('click', sendMessage);
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });

        const unreadButton = document.getElementById('unreadButton');
        const refreshButton = document.getElementById('refreshButton');
        const emailList = document.getElementById('emailList');
        const emailCount = document.getElementById('emailCount');

        let allEmails = [];
        let totalUnread = 0;
        let currentPage = 1;
        const emailsPerPage = 10;

        function getTotalPages() {
            return Math.ceil(allEmails.length / emailsPerPage);
        }

        function goToPage(pageNum) {
            const totalPages = getTotalPages();
            if (pageNum < 1 || pageNum > totalPages) return;
            currentPage = pageNum;
            renderEmails();
        }

        function updateEmailCount() {
            if (!emailCount) return;
            const shown = allEmails.length;
            const total = totalUnread || 0;
            emailCount.textContent = `Showing ${shown} / ${total} unread`;
        }

        // Get credentials from environment (exposed by backend)
        async function getUserCredentials() {
            try {
                const response = await fetch('http://localhost:5000/get_user_credentials');
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Error fetching credentials:', error);
                return null;
            }
        }

        function renderEmails() {
            const totalPages = getTotalPages();
            const startIdx = (currentPage - 1) * emailsPerPage;
            const endIdx = startIdx + emailsPerPage;
            const paginatedEmails = allEmails.slice(startIdx, endIdx);

            const emailItems = paginatedEmails.map((email, index) => `
                <div class="email-item" data-email-index="${startIdx + index}">
                    <div class="email-from">From: ${email.from_email || 'Unknown'}</div>
                    <div class="email-subject">${email.subject || '(No Subject)'}</div>
                    <div class="email-date">${email.date || new Date().toLocaleDateString()}</div>
                </div>
            `).join('');

            emailList.innerHTML = emailItems;
            updateEmailCount();

            // Add click handlers to email items
            document.querySelectorAll('.email-item').forEach(item => {
                item.addEventListener('click', () => {
                    const emailIndex = parseInt(item.dataset.emailIndex);
                    showEmailDetail(allEmails[emailIndex]);
                });
            });

            // Update pagination controls (both top and bottom)
            updatePaginationControls(totalPages);
        }

        function showEmailDetail(email) {
            const modal = document.getElementById('emailDetailModal');
            const detailSubject = document.getElementById('detailSubject');
            const detailFrom = document.getElementById('detailFrom');
            const detailDate = document.getElementById('detailDate');
            const detailBody = document.getElementById('detailBody');

            // Populate modal with email data
            detailSubject.textContent = email.subject || '(No Subject)';
            detailFrom.textContent = email.from_email || email.from || 'Unknown';
            detailDate.textContent = email.date || new Date().toLocaleDateString();
            
            // Format body content with better readability
            const bodyContent = email.body || 'No content available';
            
            // Clear previous content
            detailBody.innerHTML = '';
            detailBody.className = 'email-detail-body';
            
            // Check if body contains HTML
            if (bodyContent.includes('<') && bodyContent.includes('>')) {
                // Render as HTML (with sanitization) - like Gmail
                detailBody.innerHTML = sanitizeHtml(bodyContent);
                detailBody.className = 'email-detail-body email-detail-body-html';
            } else {
                // Render as plain text with better formatting
                const formattedText = bodyContent
                    .replace(/\n\n+/g, '\n\n') // Normalize multiple line breaks
                    .replace(/\n/g, '<br>'); // Convert line breaks to HTML
                detailBody.innerHTML = `<div class="email-text-content">${formattedText}</div>`;
                detailBody.className = 'email-detail-body email-detail-body-text';
            }

            // Show modal with animation
            modal.style.display = 'flex';
            setTimeout(() => {
                modal.classList.add('email-modal-visible');
            }, 10);
            
            // Prevent body scroll when modal is open
            document.body.style.overflow = 'hidden';
            
            // Mark email as read in Gmail
            markEmailAsRead(email);
        }

        function closeEmailDetail() {
            const modal = document.getElementById('emailDetailModal');
            modal.classList.remove('email-modal-visible');
            setTimeout(() => {
                modal.style.display = 'none';
                document.body.style.overflow = '';
            }, 300);
        }

        async function markEmailAsRead(email) {
            try {
                // Get credentials
                const creds = await getUserCredentials();
                if (!creds || !creds.access_token) {
                    console.warn('Cannot mark email as read: credentials missing');
                    return;
                }
                
                // Call API to mark email as read
                const response = await fetch('http://localhost:8000/api/email/mark-read', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        user_credentials: creds,
                        message_id: email.message_id
                    })
                });
                
                if (response.ok) {
                    console.log(`[OK] Email marked as read: ${email.message_id}`);
                } else {
                    const error = await response.json();
                    console.error('Error marking email as read:', error.detail);
                }
            } catch (error) {
                console.error('Exception marking email as read:', error);
            }
        }

        function sanitizeHtml(html) {
            // Create a temporary container to parse HTML
            const temp = document.createElement('div');
            temp.innerHTML = html;
            
            // Remove potentially dangerous scripts and style elements
            const scripts = temp.querySelectorAll('script, style');
            scripts.forEach(el => el.remove());
            
            // Remove event handlers from all elements
            const allElements = temp.querySelectorAll('*');
            allElements.forEach(el => {
                // Remove all on* attributes (onclick, onload, etc.)
                Array.from(el.attributes).forEach(attr => {
                    if (attr.name.startsWith('on')) {
                        el.removeAttribute(attr.name);
                    }
                });
                
                // Make links safe to open in browser
                if (el.tagName === 'A') {
                    el.target = '_blank';
                    el.rel = 'noopener noreferrer';
                }
            });
            
            return temp.innerHTML;
        }

        function updatePaginationControls(totalPages) {
            const paginationControlsTop = document.getElementById('paginationControlsTop');
            const paginationControls = document.getElementById('paginationControls');
            const prevButton = document.getElementById('prevButton');
            const nextButton = document.getElementById('nextButton');
            const prevButtonTop = document.getElementById('prevButtonTop');
            const nextButtonTop = document.getElementById('nextButtonTop');

            if (totalPages > 1) {
                // Show both pagination controls
                paginationControlsTop.style.display = 'flex';
                paginationControls.style.display = 'flex';
                
                // Update button states for both top and bottom
                prevButton.disabled = currentPage === 1;
                nextButton.disabled = currentPage === totalPages;
                prevButtonTop.disabled = currentPage === 1;
                nextButtonTop.disabled = currentPage === totalPages;
                
                // Generate page numbers for both top and bottom (same structure)
                generatePageNumbers(totalPages, 'pageNumbers');
                generatePageNumbers(totalPages, 'pageNumbersBottom');
            } else {
                paginationControlsTop.style.display = 'none';
                paginationControls.style.display = 'none';
            }
        }

        function generatePageNumbers(totalPages, containerId = 'pageNumbers') {
            const pageNumbers = document.getElementById(containerId);
            if (!pageNumbers) return;
            
            let numbersHTML = '';
            
            // Show up to 7 page numbers with ellipsis for large page counts
            const maxVisible = 7;
            
            if (totalPages <= maxVisible) {
                // Show all pages
                for (let i = 1; i <= totalPages; i++) {
                    numbersHTML += `<button class="page-number ${i === currentPage ? 'active' : ''}" data-page="${i}">${i}</button>`;
                }
            } else {
                // Show first page
                numbersHTML += `<button class="page-number ${currentPage === 1 ? 'active' : ''}" data-page="1">1</button>`;
                
                if (currentPage > 3) {
                    numbersHTML += `<span class="page-ellipsis">...</span>`;
                }
                
                // Show pages around current page
                const start = Math.max(2, currentPage - 1);
                const end = Math.min(totalPages - 1, currentPage + 1);
                
                for (let i = start; i <= end; i++) {
                    numbersHTML += `<button class="page-number ${i === currentPage ? 'active' : ''}" data-page="${i}">${i}</button>`;
                }
                
                if (currentPage < totalPages - 2) {
                    numbersHTML += `<span class="page-ellipsis">...</span>`;
                }
                
                // Show last page
                numbersHTML += `<button class="page-number ${currentPage === totalPages ? 'active' : ''}" data-page="${totalPages}">${totalPages}</button>`;
            }
            
            pageNumbers.innerHTML = numbersHTML;
            
            // Add click handlers to page number buttons
            pageNumbers.querySelectorAll('.page-number').forEach(btn => {
                btn.addEventListener('click', () => {
                    const page = parseInt(btn.dataset.page);
                    goToPage(page);
                });
            });
        }

        async function loadUnreadEmails() {
            unreadButton.disabled = true;
            unreadButton.textContent = 'Loading...';
            allEmails = [];
            totalUnread = 0;
            currentPage = 1;

            try {
                // Get real credentials
                console.log('[*] Fetching credentials...');
                const creds = await getUserCredentials();
                console.log('[*] Got credentials:', {
                    access_token: creds?.access_token ? creds.access_token.substring(0, 20) + '...' : 'NONE',
                    refresh_token: creds?.refresh_token ? creds.refresh_token.substring(0, 20) + '...' : 'NONE',
                    email: creds?.email
                });
                
                if (!creds || !creds.access_token) {
                    console.error('[!] Credentials missing');
                    emailList.innerHTML = '<div class="empty-state"><div class="empty-state-text">Error</div><p>Gmail credentials not found. Please restart the app.</p></div>';
                    if (emailCount) emailCount.textContent = 'Showing 0 / -- unread';
                    unreadButton.disabled = false;
                    unreadButton.textContent = 'Unread Mail';
                    return;
                }

                console.log('[*] Requesting unread emails from backend...');
                const response = await fetch('http://localhost:8000/api/email/unread', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        user_credentials: creds,
                        max_results: 50  // Reduced from 1000 to 50 for faster loading
                    })
                });

                console.log('[*] Response status:', response.status);
                const data = await response.json();
                console.log('[*] Response data:', data);

                if (response.ok && data.success) {
                    allEmails = data.emails || [];
                    totalUnread = typeof data.total_unread === 'number' ? data.total_unread : allEmails.length;
                    updateEmailCount();
                    console.log(`[OK] Got ${allEmails.length} emails`);
                    if (allEmails.length === 0) {
                        emailList.innerHTML = '<div class="empty-state"><div class="empty-state-text">OK</div><p>No unread emails</p></div>';
                    } else {
                        renderEmails();
                    }
                } else {
                    const errorMsg = data.error || data.detail || JSON.stringify(data);
                    console.error('[!] Backend error:', errorMsg);
                    emailList.innerHTML = `<div class="empty-state"><div class="empty-state-text">Error</div><p>${errorMsg}</p></div>`;
                    if (emailCount) emailCount.textContent = 'Showing 0 / -- unread';
                }
            } catch (error) {
                console.error('[!] Exception:', error);
                emailList.innerHTML = `<div class="empty-state"><div class="empty-state-text">Error</div><p>Exception: ${error.message}</p></div>`;
                if (emailCount) emailCount.textContent = 'Showing 0 / -- unread';
            }

            unreadButton.disabled = false;
            unreadButton.textContent = 'Unread Mail';
        }

        unreadButton.addEventListener('click', loadUnreadEmails);
        refreshButton.addEventListener('click', loadUnreadEmails);

        document.getElementById('prevButton').addEventListener('click', () => {
            goToPage(currentPage - 1);
        });

        document.getElementById('nextButton').addEventListener('click', () => {
            goToPage(currentPage + 1);
        });

        document.getElementById('prevButtonTop').addEventListener('click', () => {
            goToPage(currentPage - 1);
        });

        document.getElementById('nextButtonTop').addEventListener('click', () => {
            goToPage(currentPage + 1);
        });

        // Close email detail modal
        document.getElementById('closeEmailBtn').addEventListener('click', closeEmailDetail);
        
        // Close modal when clicking outside of it
        // Close modal when clicking on overlay or outside
        const emailDetailModal = document.getElementById('emailDetailModal');
        if (emailDetailModal) {
            emailDetailModal.addEventListener('click', (e) => {
                // Close if clicking on overlay or modal background (not the container)
                if (e.target.id === 'emailDetailModal' || e.target.classList.contains('email-detail-overlay')) {
                    closeEmailDetail();
                }
            });
            
            // Prevent closing when clicking inside the container
            const emailDetailContainer = emailDetailModal.querySelector('.email-detail-container');
            if (emailDetailContainer) {
                emailDetailContainer.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
            }
            
            // Close on ESC key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && emailDetailModal.style.display === 'flex') {
                    closeEmailDetail();
                }
            });
        }

        messageInput.focus();


        // Telegram functionality - Node.js backend
        const TELEGRAM_API_URL = 'http://localhost:3001';
        const WHATSAPP_API_URL = 'http://localhost:3000';
        let currentTelegramChatId = null;
        const telegramMessageInput = document.getElementById('telegramMessageInput');
        const telegramSendButton = document.getElementById('telegramSendButton');
        const telegramAttachButton = document.getElementById('telegramAttachButton');
        const telegramFileInput = document.getElementById('telegramFileInput');
        const telegramEditLastBtn = document.getElementById('telegramEditLastBtn');
        const telegramClearChatBtn = document.getElementById('telegramClearChatBtn');
        let telegramSocket = null;

        // Track socket connection state / throttling
        let telegramSocketRetryDisabled = false; // (kept for backward-compat; no longer permanently disables retries)
        let telegramSocketConnecting = false;
        
        // Check if Telegram server is available before connecting
        async function checkTelegramServerAvailable() {
            try {
                const response = await fetch(`${TELEGRAM_API_URL}/health`, {
                    method: 'GET',
                    signal: AbortSignal.timeout(6000)
                });
                return response.ok;
            } catch (error) {
                return false;
            }
        }
        
        // Connect to Telegram WebSocket with retry logic
        async function connectTelegramWebSocket(retryCount = 0) {
            if (telegramSocket && telegramSocket.connected) return;
            
            if (telegramSocketConnecting) return;
            telegramSocketConnecting = true;
            
            const maxRetries = 3; // Reduced retries
            const retryDelay = 3000; // 3 seconds
            
            // Check if server is available first
            if (retryCount === 0) {
                const serverAvailable = await checkTelegramServerAvailable();
                if (!serverAvailable) {
                    console.log('[Telegram] Server not available, will not connect WebSocket');
                    telegramSocketConnecting = false;
                    // Don't permanently disable: allow later reconnect (tab open/refresh)
                    return;
                }
            }
            
            try {
                if (telegramSocket) {
                    telegramSocket.disconnect();
                    telegramSocket = null;
                }
                
                telegramSocket = io(`${TELEGRAM_API_URL}`, {
                    reconnection: true,
                    reconnectionDelay: 1000,
                    reconnectionDelayMax: 5000,
                    reconnectionAttempts: Infinity,
                    timeout: 20000,
                    transports: ['websocket', 'polling'],
                    autoConnect: true
                });
                
                telegramSocket.on('connect', () => {
                    console.log('[Telegram] WebSocket connected');
                    retryCount = 0; // Reset retry count on successful connection
                    telegramSocketRetryDisabled = false;
                    telegramSocketConnecting = false;
                });
                
                telegramSocket.on('telegram_status', (data) => {
                    console.log('[Telegram] Status update:', data);
                    // Intentionally do NOT auto-load contacts/messages here.
                    // Per UX requirement: Telegram contacts/messages load only when user clicks Refresh.
                });
                
                telegramSocket.on('telegram_message', (message) => {
                    if (!telegramLoadedOnce) return;
                    console.log('[Telegram] New message:', message);
                    // Best-effort status defaults
                    if (message && message.fromMe && !message.delivery_status) {
                        message.delivery_status = 'sent';
                    }
                    // Update UI with new message
                    if (message.contact_id === currentTelegramChatId) {
                        // Add message to current chat
                        telegramChatMessages[message.contact_id] = telegramChatMessages[message.contact_id] || [];
                        telegramChatMessages[message.contact_id].push(message);
                        renderTelegramMessages(telegramChatMessages[message.contact_id]);
                    }
                    // Update chat list if needed
                    updateTelegramChatInList(message.contact_id, message);
                });

                telegramSocket.on('telegram_message_update', (message) => {
                    if (!telegramLoadedOnce) return;
                    // Media downloaded async; patch message in cache if present
                    if (!message || !message.contact_id || !message.id) return;
                    const list = telegramChatMessages[message.contact_id];
                    if (!list || !Array.isArray(list)) return;
                    const idx = list.findIndex(m => String(m.id) === String(message.id));
                    if (idx >= 0) {
                        list[idx] = { ...list[idx], ...message };
                        if (message.contact_id === currentTelegramChatId) {
                            renderTelegramMessages(list);
                        }
                    }
                });

                telegramSocket.on('telegram_outgoing_sent', (data) => {
                    if (!telegramLoadedOnce) return;
                    // Mark outgoing as sent (single-check)
                    if (!data || !data.contact_id || !data.message_id) return;
                    const list = telegramChatMessages[data.contact_id];
                    if (!list || !Array.isArray(list)) return;
                    const idx = list.findIndex(m => String(m.id) === String(data.message_id));
                    if (idx >= 0) {
                        list[idx].delivery_status = 'sent';
                        if (data.contact_id === currentTelegramChatId) renderTelegramMessages(list);
                    }
                });

                telegramSocket.on('telegram_receipt', (data) => {
                    if (!telegramLoadedOnce) return;
                    // Best-effort "read" receipt: mark all outgoing <= max_id as read
                    if (!data || data.kind !== 'read' || !data.contact_id || !data.max_id) return;
                    // Persist latest read max on chat (so loaded history renders ‚úì‚úì correctly)
                    const chat = telegramChats.find(c => c.contact_id === data.contact_id);
                    if (chat) {
                        const maxId = parseInt(String(data.max_id), 10);
                        if (Number.isFinite(maxId)) chat.read_outbox_max_id = maxId;
                    }
                    const list = telegramChatMessages[data.contact_id];
                    if (!list || !Array.isArray(list)) return;
                    const maxId = parseInt(String(data.max_id), 10);
                    if (!Number.isFinite(maxId)) return;
                    let changed = false;
                    for (const m of list) {
                        const mid = parseInt(String(m.id), 10);
                        if (m.fromMe && Number.isFinite(mid) && mid <= maxId && m.delivery_status !== 'read') {
                            m.delivery_status = 'read';
                            changed = true;
                        }
                    }
                    if (changed && data.contact_id === currentTelegramChatId) {
                        renderTelegramMessages(list);
                    }
                });
                
                telegramSocket.on('disconnect', (reason) => {
                    console.log('[Telegram] WebSocket disconnected:', reason);
                    telegramSocketConnecting = false;
                });
                
                telegramSocket.on('connect_error', (error) => {
                    // Suppress console errors for connection refused (server not running)
                    if (error.message && (error.message.includes('ERR_CONNECTION_REFUSED') || 
                        error.message.includes('xhr poll error') || 
                        error.message.includes('transport error'))) {
                        // Server is not running, don't spam console
                        if (retryCount === 0) {
                            console.log('[Telegram] Server not available - WebSocket connection disabled');
                        }
                        telegramSocketConnecting = false;
                        return;
                    }
                    
                    // For other errors, log them
                    console.warn('[Telegram] WebSocket connection error:', error.message);
                    
                    telegramSocketConnecting = false;
                    if (retryCount < maxRetries) {
                        setTimeout(() => {
                            console.log(`[Telegram] Retrying connection (${retryCount + 1}/${maxRetries})...`);
                            connectTelegramWebSocket(retryCount + 1);
                        }, retryDelay);
                    } else {
                        console.log('[Telegram] Stopped retrying for now (manual Refresh will retry). Server may be slow or temporarily unavailable.');
                        telegramSocketRetryDisabled = false; // allow future manual reconnect
                    }
                });
            } catch (error) {
                // Suppress errors when server is not running
                if (error.message && error.message.includes('ERR_CONNECTION_REFUSED')) {
                    if (retryCount === 0) {
                        console.log('[Telegram] Server not available - WebSocket connection disabled');
                    }
                    telegramSocketConnecting = false;
                    return;
                }
                
                console.error('[Telegram] Error connecting WebSocket:', error);
                telegramSocketConnecting = false;
                if (retryCount < maxRetries) {
                    setTimeout(() => {
                        console.log(`[Telegram] Retrying connection (${retryCount + 1}/${maxRetries})...`);
                        connectTelegramWebSocket(retryCount + 1);
                    }, retryDelay);
                }
            }
        }
        
        // Function to manually reconnect (can be called when server comes back online)
        window.reconnectTelegramWebSocket = function() {
            telegramSocketRetryDisabled = false;
            telegramSocketConnecting = false;
            if (telegramSocket) {
                telegramSocket.disconnect();
                telegramSocket = null;
            }
            connectTelegramWebSocket();
        };

        // Connect WebSocket on page load (with delay to ensure server is ready)
        setTimeout(() => {
            connectTelegramWebSocket();
        }, 1000);

        async function sendTelegramMessage() {
            if (!currentTelegramChatId || !telegramMessageInput) return;
            
            const text = telegramMessageInput.value.trim();
            if (!text) return;
            
            if (telegramSendButton) telegramSendButton.disabled = true;
            
            try {
                const response = await fetch(`${TELEGRAM_API_URL}/api/telegram/send`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        chat_id: currentTelegramChatId,
                        text: text
                    })
                });
                
                if (response.ok) {
                    const respData = await response.json().catch(() => null);
                    telegramMessageInput.value = '';
                    // Optimistic append (in case realtime isn't connected)
                    if (respData && respData.message_id) {
                        const list = telegramChatMessages[currentTelegramChatId] || (telegramChatMessages[currentTelegramChatId] = []);
                        const exists = list.some(m => String(m.id) === String(respData.message_id));
                        if (!exists) {
                            list.push({
                                id: String(respData.message_id),
                                body: text,
                                fromMe: true,
                                timestamp: respData.timestamp || Math.floor(Date.now() / 1000),
                                type: 'text',
                                hasMedia: false,
                                delivery_status: 'sent'
                            });
                            updateTelegramChatInList(currentTelegramChatId, { body: text, timestamp: respData.timestamp || Math.floor(Date.now() / 1000), fromMe: true });
                            if (currentTelegramChatId === currentChatId) {
                                renderTelegramMessages(list);
                            }
                        }
                    }
                } else {
                    const data = await response.json();
                    alert('Failed to send message: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('[Telegram] Error sending message:', error);
                alert('Error sending message: ' + error.message);
            } finally {
                if (telegramSendButton) {
                    telegramSendButton.disabled = !telegramMessageInput.value.trim() || !currentTelegramChatId;
                }
            }
        }

        // On-demand media load (keeps API fast by default)
        window.telegramLoadMedia = async function(chatId, messageId) {
            try {
                if (!chatId || !messageId) return;
                const list = telegramChatMessages[chatId];
                if (!list || !Array.isArray(list)) return;
                const idx = list.findIndex(m => String(m.id) === String(messageId));
                if (idx < 0) return;
                
                const resp = await fetch(`${TELEGRAM_API_URL}/api/telegram/media`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ chat_id: chatId, message_id: messageId }),
                    signal: AbortSignal.timeout(30000)
                });
                const data = await resp.json().catch(() => null);
                if (!resp.ok || !data || !data.success) {
                    alert('Failed to load media: ' + ((data && data.error) ? data.error : `HTTP ${resp.status}`));
                    return;
                }
                // Prefer streaming URL for large video/files
                list[idx].fileUrl = data.fileUrl || null;
                if (data.mediaUrl) {
                    list[idx].mediaUrl = data.mediaUrl;
                } else if (data.fileUrl) {
                    list[idx].mediaUrl = `${TELEGRAM_API_URL}${data.fileUrl}`;
                }
                list[idx].mediaMimetype = data.mediaMimetype;
                list[idx].mediaFilename = data.mediaFilename;
                if (chatId === currentTelegramChatId) renderTelegramMessages(list);
            } catch (e) {
                alert('Failed to load media: ' + (e.message || String(e)));
            }
        };

        // Attach/send files
        if (telegramAttachButton && telegramFileInput) {
            telegramAttachButton.addEventListener('click', () => {
                if (!currentTelegramChatId) return;
                telegramFileInput.click();
            });
            telegramFileInput.addEventListener('change', async () => {
                try {
                    const file = telegramFileInput.files && telegramFileInput.files[0];
                    if (!file || !currentTelegramChatId) return;
                    
                    // Read as base64
                    const base64 = await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => {
                            const result = String(reader.result || '');
                            const commaIdx = result.indexOf(',');
                            resolve(commaIdx >= 0 ? result.slice(commaIdx + 1) : result);
                        };
                        reader.onerror = () => reject(reader.error || new Error('File read failed'));
                        reader.readAsDataURL(file);
                    });
                    
                    const resp = await fetch(`${TELEGRAM_API_URL}/api/telegram/sendFile`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            chat_id: currentTelegramChatId,
                            data_base64: base64,
                            caption: undefined
                        }),
                        signal: AbortSignal.timeout(60000)
                    });
                    const data = await resp.json().catch(() => null);
                    if (!resp.ok || !data || !data.success) {
                        alert('Failed to send file: ' + ((data && data.error) ? data.error : `HTTP ${resp.status}`));
                        return;
                    }
                    // Clear the input so the same file can be selected again
                    telegramFileInput.value = '';
                } catch (e) {
                    alert('Failed to send file: ' + (e.message || String(e)));
                }
            });
        }

        // Edit last sent message
        if (telegramEditLastBtn) {
            telegramEditLastBtn.addEventListener('click', async () => {
                try {
                    const chatId = currentTelegramChatId;
                    if (!chatId) return;
                    const list = telegramChatMessages[chatId] || [];
                    const lastMine = [...list].reverse().find(m => m && m.fromMe && m.body && String(m.id).match(/^\d+$/));
                    if (!lastMine) {
                        alert('No editable outgoing message found in this chat.');
                        return;
                    }
                    const nextText = prompt('Edit last message:', lastMine.body);
                    if (nextText === null) return;
                    const resp = await fetch(`${TELEGRAM_API_URL}/api/telegram/edit`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ chat_id: chatId, message_id: lastMine.id, text: String(nextText) }),
                        signal: AbortSignal.timeout(20000)
                    });
                    const data = await resp.json().catch(() => null);
                    if (!resp.ok || !data || !data.success) {
                        alert('Failed to edit: ' + ((data && data.error) ? data.error : `HTTP ${resp.status}`));
                        return;
                    }
                    lastMine.body = String(nextText);
                    if (chatId === currentTelegramChatId) renderTelegramMessages(list);
                } catch (e) {
                    alert('Failed to edit: ' + (e.message || String(e)));
                }
            });
        }

        // Clear chat history (best-effort)
        if (telegramClearChatBtn) {
            telegramClearChatBtn.addEventListener('click', async () => {
                try {
                    const chatId = currentTelegramChatId;
                    if (!chatId) return;
                    const ok = confirm('Clear chat history? This may not be reversible.');
                    if (!ok) return;
                    
                    const resp = await fetch(`${TELEGRAM_API_URL}/api/telegram/clear`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ chat_id: chatId, revoke: true }),
                        signal: AbortSignal.timeout(30000)
                    });
                    const data = await resp.json().catch(() => null);
                    if (!resp.ok || !data || !data.success) {
                        alert('Failed to clear chat: ' + ((data && data.error) ? data.error : `HTTP ${resp.status}`));
                        return;
                    }
                    telegramChatMessages[chatId] = [];
                    if (telegramCount) telegramCount.textContent = '0 messages';
                    renderTelegramMessages([]);
                } catch (e) {
                    alert('Failed to clear chat: ' + (e.message || String(e)));
                }
            });
        }

        async function loadOlderTelegramMessages(chatId) {
            if (!chatId) return;
            const paging = telegramChatPaging[chatId] || (telegramChatPaging[chatId] = { loadingOlder: false, reachedStart: false, oldestId: null });
            if (paging.loadingOlder || paging.reachedStart) return;
            if (!paging.oldestId) return;
            
            paging.loadingOlder = true;
            try {
                const container = document.getElementById('telegramMessagesContainer');
                const prevScrollHeight = container ? container.scrollHeight : 0;
                const prevScrollTop = container ? container.scrollTop : 0;
                
                const resp = await fetch(`${TELEGRAM_API_URL}/api/telegram/messages`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ chat_id: chatId, limit: 50, before_id: paging.oldestId }),
                    signal: AbortSignal.timeout(20000)
                });
                const data = await resp.json().catch(() => null);
                if (!resp.ok || !data || !data.success) {
                    return;
                }
                
                const older = data.messages || [];
                applyReadStatusFromChat(chatId, older);
                
                const list = telegramChatMessages[chatId] || (telegramChatMessages[chatId] = []);
                // Prepend, de-dupe by id
                const existingIds = new Set(list.map(m => String(m.id)));
                const merged = [...older.filter(m => !existingIds.has(String(m.id))), ...list];
                telegramChatMessages[chatId] = merged;
                
                paging.oldestId = data.oldest_id || (merged[0] ? merged[0].id : paging.oldestId);
                paging.reachedStart = !!data.reached_start || older.length === 0;
                
                if (chatId === currentTelegramChatId) {
                    renderTelegramMessages(telegramChatMessages[chatId], false);
                    // Maintain scroll position after prepend
                    if (container) {
                        const newScrollHeight = container.scrollHeight;
                        container.scrollTop = (newScrollHeight - prevScrollHeight) + prevScrollTop;
                    }
                }
            } finally {
                paging.loadingOlder = false;
            }
        }

        // Infinite scroll: load older messages when scrolled near top
        {
            const _container = document.getElementById('telegramMessagesContainer');
            if (_container) _container.addEventListener('scroll', () => {
                if (!currentTelegramChatId) return;
                if (_container.scrollTop <= 40) {
                    loadOlderTelegramMessages(currentTelegramChatId);
                }
            });
        }

        // Long-press (2s) to edit an unread outgoing message
        (function setupTelegramLongPressAndContextMenu() {
            const telegramMessagesContainer = document.getElementById('telegramMessagesContainer');
            if (!telegramMessagesContainer) return;
            let pressTimer = null;
            let pressTarget = null;
            const PRESS_MS = 2000;
            let pressStartX = 0;
            let pressStartY = 0;
            const MOVE_CANCEL_PX = 8;
            
            function clearPress() {
                if (pressTimer) clearTimeout(pressTimer);
                pressTimer = null;
                pressTarget = null;
            }
            
            function getMsgEl(e) {
                const el = e.target && e.target.closest ? e.target.closest('.telegram-message[data-msg-id]') : null;
                return el;
            }
            
            async function editMessageByEl(msgEl) {
                const chatId = currentTelegramChatId;
                if (!chatId || !msgEl) return;
                const msgId = msgEl.dataset.msgId;
                const isMe = msgEl.dataset.fromMe === '1';
                const status = msgEl.dataset.status || '';
                if (!isMe) return;
                if (status === 'read') return; // only unread outgoing
                
                const list = telegramChatMessages[chatId] || [];
                const msg = list.find(m => String(m.id) === String(msgId));
                if (!msg || !msg.body) return;
                
                const nextText = prompt('Edit message:', msg.body);
                if (nextText === null) return;
                
                const resp = await fetch(`${TELEGRAM_API_URL}/api/telegram/edit`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ chat_id: chatId, message_id: msgId, text: String(nextText) }),
                    signal: AbortSignal.timeout(20000)
                });
                const data = await resp.json().catch(() => null);
                if (!resp.ok || !data || !data.success) {
                    alert('Failed to edit: ' + ((data && data.error) ? data.error : `HTTP ${resp.status}`));
                    return;
                }
                msg.body = String(nextText);
                renderTelegramMessages(list);
            }
            
            telegramMessagesContainer.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return;
                const el = getMsgEl(e);
                if (!el) return;
                pressTarget = el;
                clearPress();
                pressStartX = e.clientX;
                pressStartY = e.clientY;
                pressTimer = setTimeout(() => {
                    editMessageByEl(pressTarget);
                    clearPress();
                }, PRESS_MS);
            });
            telegramMessagesContainer.addEventListener('mouseup', clearPress);
            telegramMessagesContainer.addEventListener('mouseleave', clearPress);
            telegramMessagesContainer.addEventListener('mousemove', (e) => {
                // cancel only on actual drag (not tiny jitter)
                if (!pressTimer) return;
                const dx = Math.abs((e.clientX || 0) - pressStartX);
                const dy = Math.abs((e.clientY || 0) - pressStartY);
                if (dx > MOVE_CANCEL_PX || dy > MOVE_CANCEL_PX) clearPress();
            });
            telegramMessagesContainer.addEventListener('scroll', clearPress, { passive: true });
            telegramMessagesContainer.addEventListener('touchstart', (e) => {
                const el = getMsgEl(e);
                if (!el) return;
                pressTarget = el;
                clearPress();
                pressTimer = setTimeout(() => {
                    editMessageByEl(pressTarget);
                    clearPress();
                }, PRESS_MS);
            }, { passive: true });
            telegramMessagesContainer.addEventListener('touchend', clearPress);
            telegramMessagesContainer.addEventListener('touchcancel', clearPress);
            
            // Right-click delete
            telegramMessagesContainer.addEventListener('contextmenu', async (e) => {
                const el = getMsgEl(e);
                if (!el) return;
                e.preventDefault();
                const chatId = currentTelegramChatId;
                const msgId = el.dataset.msgId;
                if (!chatId || !msgId) return;
                const ok = confirm('Delete this message?');
                if (!ok) return;
                const isMe = el.dataset.fromMe === '1';
                const resp = await fetch(`${TELEGRAM_API_URL}/api/telegram/delete`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    // If it's not our message, revoke often fails; delete locally instead.
                    body: JSON.stringify({ chat_id: chatId, message_id: msgId, revoke: isMe }),
                    signal: AbortSignal.timeout(20000)
                });
                const data = await resp.json().catch(() => null);
                if (!resp.ok || !data || !data.success) {
                    alert('Failed to delete: ' + ((data && data.error) ? data.error : `HTTP ${resp.status}`));
                    return;
                }
                const list = telegramChatMessages[chatId] || [];
                telegramChatMessages[chatId] = list.filter(m => String(m.id) !== String(msgId));
                if (chatId === currentTelegramChatId) renderTelegramMessages(telegramChatMessages[chatId]);
            });
        })();

        if (telegramMessageInput) {
            telegramMessageInput.addEventListener('input', () => {
                if (telegramSendButton) {
                    telegramSendButton.disabled = !telegramMessageInput.value.trim() || !currentTelegramChatId;
                }
            });
            
            telegramMessageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendTelegramMessage();
                }
            });
        }

        if (telegramSendButton) {
            telegramSendButton.addEventListener('click', sendTelegramMessage);
        }

        // Telegram functionality - Node.js backend
        const telegramShowButton = document.getElementById('telegramShowButton');
        const telegramMessagesContainer = document.getElementById('telegramMessagesContainer');
        const telegramChatsList = document.getElementById('telegramChatsList');
        const telegramCurrentChat = document.getElementById('telegramCurrentChat');
        const telegramCount = document.getElementById('telegramCount');
        
        // Telegram state variables
        let telegramChats = [];
        let telegramChatMessages = {};
        let currentChatId = null;
        let telegramChatPaging = {}; // chatId -> { oldestId, reachedStart, loadingOlder }
        let telegramRealtimePollTimer = null;
        let telegramLoadedOnce = false; // contacts/messages should only be loaded on Refresh
        
        // Helper functions
        function getTelegramInitials(name) {
            if (!name) return '?';
            const parts = name.trim().split(' ');
            if (parts.length >= 2) {
                return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
            }
            return name.substring(0, 2).toUpperCase();
        }
        
        function getTelegramAvatarColor(name) {
            if (!name) return '#3390ec';
            let hash = 0;
            for (let i = 0; i < name.length; i++) {
                hash = name.charCodeAt(i) + ((hash << 5) - hash);
            }
            const colors = [
                '#3390ec', '#e17076', '#6c5ce7', '#00b894', '#fdcb6e',
                '#e84393', '#0984e3', '#00cec9', '#55a3ff', '#a29bfe'
            ];
            return colors[Math.abs(hash) % colors.length];
        }
        
        function formatTelegramTimestamp(timestamp) {
            if (!timestamp) return '';
            const date = new Date(timestamp * 1000);
            const now = new Date();
            const diff = now - date;
            const days = Math.floor(diff / (1000 * 60 * 60 * 24));
            
            if (days === 0) {
                return formatTelegramTime(timestamp);
            } else if (days === 1) {
                return 'Yesterday';
            } else if (days < 7) {
                return date.toLocaleDateString('en-US', { weekday: 'short' });
            } else {
                return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            }
        }
        
        function formatTelegramTime(timestamp) {
            if (!timestamp) return '';
            const date = new Date(timestamp * 1000);
            return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
        }
        
        function formatTelegramMessage(text) {
            if (!text) return '';
            return escapeHtml(text).replace(/\n/g, '<br>');
        }
        
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function renderTelegramChats() {
            if (!telegramChatsList) return;
            
            if (telegramChats.length === 0) {
                telegramChatsList.innerHTML = telegramLoadedOnce
                    ? '<div class="telegram-sidebar-empty">No chats found</div>'
                    : '<div class="telegram-sidebar-empty">Click Refresh to load chats</div>';
                return;
            }
            
            const prevScrollTop = telegramChatsList.scrollTop;
            telegramChatsList.innerHTML = telegramChats.map(chat => {
                const initials = getTelegramInitials(chat.name);
                const avatarColor = getTelegramAvatarColor(chat.name);
                const lastMessageTime = chat.last_message_time ? formatTelegramTimestamp(chat.last_message_time) : '';
                const lastMessage = chat.last_message ? (chat.last_message.length > 40 ? chat.last_message.substring(0, 40) + '...' : chat.last_message) : '';
                const unreadBadge = chat.unread_count > 0 ? `<span class="telegram-unread-badge">${chat.unread_count}</span>` : '';
                const avatarImgStyle = chat.avatar_url ? '' : 'display:none;';
                const avatarFallbackStyle = chat.avatar_url ? 'display:none;' : '';
                const avatarHtml = `
                    <div class="telegram-avatar-wrap">
                        <img
                            src="${chat.avatar_url ? chat.avatar_url : ''}"
                            alt="${escapeHtml(chat.name)}"
                            class="telegram-avatar-img"
                            data-contact-id="${chat.contact_id}"
                            style="${avatarImgStyle}"
                            loading="lazy"
                        >
                        <div class="telegram-avatar" style="background-color: ${avatarColor}; ${avatarFallbackStyle}">${initials}</div>
                    </div>
                `;
                
                return `
                    <div class="telegram-chat-item" data-chat-id="${chat.contact_id}" onclick="selectTelegramChat('${chat.contact_id}')">
                        ${avatarHtml}
                        <div class="telegram-chat-info">
                            <div class="telegram-chat-header">
                                <span class="telegram-chat-name">${escapeHtml(chat.name)}</span>
                                ${lastMessageTime ? `<span class="telegram-chat-time">${lastMessageTime}</span>` : ''}
                            </div>
                            <div class="telegram-chat-preview">
                                <span class="telegram-chat-last-message">${formatTelegramMessage(lastMessage)}</span>
                                ${unreadBadge}
                            </div>
                            ${chat.username ? `<div class="telegram-chat-username">@${escapeHtml(chat.username)}</div>` : ''}
                            ${chat.phone ? `<div class="telegram-chat-phone">${escapeHtml(chat.phone)}</div>` : ''}
                            ${chat.is_group ? `<div class="telegram-chat-type">Group</div>` : ''}
                            ${chat.is_channel ? `<div class="telegram-chat-type">Channel</div>` : ''}
                        </div>
                    </div>
                `;
            }).join('');
            telegramChatsList.scrollTop = prevScrollTop;

            // Load avatars for visible rows (and a small buffer) without re-rendering
            scheduleTelegramAvatarLoad();
        }

        let telegramAvatarLoadTimer = null;
        let telegramAvatarScrollAttached = false;
        const telegramAvatarInFlight = new Set(); // contact_id -> in-flight fetch

        function cssEscapeSafe(value) {
            try {
                if (typeof CSS !== 'undefined' && CSS.escape) return CSS.escape(String(value));
            } catch (e) {}
            // Minimal escape fallback for attribute selector
            return String(value).replace(/["\\]/g, '\\$&');
        }

        function scheduleTelegramAvatarLoad() {
            if (!telegramChatsList) return;
            if (!telegramAvatarScrollAttached) {
                telegramAvatarScrollAttached = true;
                telegramChatsList.addEventListener('scroll', () => {
                    scheduleTelegramAvatarLoad();
                }, { passive: true });
            }
            if (telegramAvatarLoadTimer) clearTimeout(telegramAvatarLoadTimer);
            telegramAvatarLoadTimer = setTimeout(() => {
                loadTelegramAvatars(30, true);
            }, 150);
        }

        async function loadTelegramAvatars(maxToLoad = 30, onlyVisible = false) {
            try {
                if (!Array.isArray(telegramChats) || telegramChats.length === 0) return;

                let candidates = [];
                if (onlyVisible && telegramChatsList) {
                    const contRect = telegramChatsList.getBoundingClientRect();
                    const buffer = 300;
                    const items = Array.from(telegramChatsList.querySelectorAll('.telegram-chat-item[data-chat-id]'));
                    for (const el of items) {
                        const r = el.getBoundingClientRect();
                        if (r.bottom >= contRect.top - buffer && r.top <= contRect.bottom + buffer) {
                            const id = el.getAttribute('data-chat-id');
                            if (id) candidates.push(id);
                        }
                    }
                } else {
                    candidates = telegramChats.map(c => c && c.contact_id).filter(Boolean);
                }

                const toLoad = [];
                for (const id of candidates) {
                    const chat = telegramChats.find(c => c && String(c.contact_id) === String(id));
                    if (!chat || !chat.contact_id) continue;
                    if (chat.avatar_url) continue;
                    if (telegramAvatarInFlight.has(String(chat.contact_id))) continue;
                    toLoad.push(chat);
                    if (toLoad.length >= Math.max(0, maxToLoad)) break;
                }

                const concurrency = 5;
                for (let i = 0; i < toLoad.length; i += concurrency) {
                    const batch = toLoad.slice(i, i + concurrency);
                    await Promise.all(batch.map(async (chat) => {
                        try {
                            telegramAvatarInFlight.add(String(chat.contact_id));
                            const resp = await fetch(`${TELEGRAM_API_URL}/api/telegram/avatar?contact_id=${encodeURIComponent(chat.contact_id)}`, {
                                method: 'GET',
                                signal: AbortSignal.timeout(15000)
                            });
                            if (!resp.ok) return;
                            const data = await resp.json();
                            if (data && data.success && data.avatar_url) {
                                chat.avatar_url = data.avatar_url;
                                // Update DOM in-place (avoid re-rendering / scroll jumps)
                                if (telegramChatsList) {
                                    const sel = `img.telegram-avatar-img[data-contact-id="${cssEscapeSafe(chat.contact_id)}"]`;
                                    const img = telegramChatsList.querySelector(sel);
                                    if (img) {
                                        img.src = data.avatar_url;
                                        img.style.display = '';
                                        const wrap = img.closest('.telegram-avatar-wrap');
                                        const fallback = wrap ? wrap.querySelector('.telegram-avatar') : null;
                                        if (fallback) fallback.style.display = 'none';
                                    }
                                }
                            }
                        } catch (e) {
                            // ignore avatar errors
                        } finally {
                            telegramAvatarInFlight.delete(String(chat.contact_id));
                        }
                    }));
                }
            } catch (e) {
                // ignore
            }
        }
        
        function updateTelegramChatInList(chatId, message) {
            const chat = telegramChats.find(c => c.contact_id === chatId);
            if (chat) {
                chat.last_message = message.body || '';
                chat.last_message_time = message.timestamp;
                if (!message.fromMe) {
                    chat.unread_count = (chat.unread_count || 0) + 1;
                }
                renderTelegramChats();
            }
        }

        function applyReadStatusFromChat(chatId, messages) {
            const chat = telegramChats.find(c => c.contact_id === chatId);
            const readMax = chat && typeof chat.read_outbox_max_id === 'number' ? chat.read_outbox_max_id : null;
            if (!Number.isFinite(readMax)) return;
            for (const m of messages) {
                const mid = parseInt(String(m.id), 10);
                if (m.fromMe && Number.isFinite(mid)) {
                    m.delivery_status = (mid <= readMax) ? 'read' : (m.delivery_status || 'sent');
                }
            }
        }

        // Make selectTelegramChat globally accessible
        window.selectTelegramChat = async function(chatId) {
            if (!telegramLoadedOnce) {
                if (telegramMessagesContainer) {
                    telegramMessagesContainer.innerHTML = '<div class="telegram-empty-state"><p>Click Refresh to load chats and messages</p></div>';
                }
                return;
            }
            currentChatId = chatId;
            currentTelegramChatId = chatId;
            try { localStorage.setItem('telegram_last_chat_id', String(chatId)); } catch (e) {}
            
            // Find chat info
            const chatInfo = telegramChats.find(c => c.contact_id === chatId);
            if (!chatInfo) return;

            if (telegramCurrentChat) telegramCurrentChat.textContent = chatInfo.name;
            if (telegramMessagesContainer) {
                telegramMessagesContainer.innerHTML = '<div class="telegram-empty-state"><p>Loading messages...</p></div>';
            }

            // Show input area
            const telegramInputContainer = document.getElementById('telegramInputContainer');
            if (telegramInputContainer) {
                telegramInputContainer.style.display = 'block';
            }
            if (telegramAttachButton) telegramAttachButton.disabled = false;
            if (telegramEditLastBtn) telegramEditLastBtn.disabled = false;
            if (telegramClearChatBtn) telegramClearChatBtn.disabled = false;

            // Update active state
            document.querySelectorAll('.telegram-chat-item').forEach(item => {
                item.classList.toggle('active', item.dataset.chatId === chatId);
            });

            // Show cached messages immediately if available
            if (telegramChatMessages[chatId] && telegramChatMessages[chatId].length > 0) {
                console.log(`[*] Using cached messages for chat ${chatId} (${telegramChatMessages[chatId].length} messages)`);
                const cachedMessages = telegramChatMessages[chatId];
                if (telegramCount) telegramCount.textContent = `${cachedMessages.length} messages`;
                renderTelegramMessages(cachedMessages);
                
                // Focus input immediately
                if (telegramMessageInput) {
                    telegramMessageInput.focus();
                    if (telegramSendButton) {
                        telegramSendButton.disabled = !telegramMessageInput.value.trim() || !currentTelegramChatId;
                    }
                }
                
                // Refresh messages in background (non-blocking)
                setTimeout(async () => {
                    try {
                        const response = await fetchWithTimeout(`${TELEGRAM_API_URL}/api/telegram/messages`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                chat_id: chatId,
                                limit: 50
                            })
                        }, 30000);
                        if (response.ok) {
                            const data = await response.json();
                            if (data.success && data.messages) {
                                telegramChatMessages[chatId] = data.messages;
                                applyReadStatusFromChat(chatId, telegramChatMessages[chatId]);
                                telegramChatPaging[chatId] = telegramChatPaging[chatId] || {};
                                telegramChatPaging[chatId].oldestId = data.oldest_id || (telegramChatMessages[chatId][0] ? telegramChatMessages[chatId][0].id : null);
                                telegramChatPaging[chatId].reachedStart = !!data.reached_start;
                                // Only update if still on same chat
                                if (currentChatId === chatId) {
                                    if (telegramCount) telegramCount.textContent = `${data.messages.length} messages`;
                                    renderTelegramMessages(data.messages);
                                }
                            }
                        }
                    } catch (error) {
                        // avoid noisy errors for transient timeouts
                        if (!isTimeoutLikeError(error)) {
                            console.error('[!] Error refreshing messages:', error);
                        }
                    }
                }, 100);
                return;
            }
            
            // Load messages for this chat on-demand (if not already cached)
            try {
                console.log(`[*] Loading messages for chat ${chatId}...`);
                const response = await fetchWithTimeout(`${TELEGRAM_API_URL}/api/telegram/messages`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        chat_id: chatId,
                        limit: 50
                    })
                }, 30000);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                if (data.success) {
                    telegramChatMessages[chatId] = data.messages || [];
                    applyReadStatusFromChat(chatId, telegramChatMessages[chatId]);
                    telegramChatPaging[chatId] = telegramChatPaging[chatId] || {};
                    telegramChatPaging[chatId].oldestId = data.oldest_id || (telegramChatMessages[chatId][0] ? telegramChatMessages[chatId][0].id : null);
                    telegramChatPaging[chatId].reachedStart = !!data.reached_start;
                    telegramChatPaging[chatId].loadingOlder = false;
                } else {
                    throw new Error(data.error || 'Failed to load messages');
                }
            } catch (error) {
                console.error('[!] Error loading messages:', error);
                if (telegramMessagesContainer) {
                    telegramMessagesContainer.innerHTML = `<div class="telegram-empty-state"><p>Error loading messages: ${error.message}</p></div>`;
                }
                return;
            }

            // Render messages
            const messages = telegramChatMessages[chatId] || [];
            if (telegramCount) telegramCount.textContent = `${messages.length} messages`;
            renderTelegramMessages(messages);

            // Focus input and update send button state
            if (telegramMessageInput) {
                telegramMessageInput.focus();
                if (telegramSendButton) {
                    telegramSendButton.disabled = !telegramMessageInput.value.trim() || !currentTelegramChatId;
                }
            }
        }

        function renderTelegramMessages(messages, autoScroll = true) {
            if (!telegramMessagesContainer || !messages || messages.length === 0) {
                if (telegramMessagesContainer) {
                    telegramMessagesContainer.innerHTML = '<div class="telegram-empty-state"><p>No messages</p></div>';
                }
                return;
            }
            
            telegramMessagesContainer.innerHTML = messages.map(msg => {
                const isMe = msg.fromMe;
                const senderName = msg.sender_name || (isMe ? 'You' : 'Unknown');
                const time = formatTelegramTime(msg.timestamp);
                const date = formatTelegramTimestamp(msg.timestamp);
                const messageClass = isMe ? 'telegram-message-out' : 'telegram-message-in';
                
                const statusHtml = isMe ? (() => {
                    const st = msg.delivery_status === 'read' ? '‚úì‚úì' : '‚úì';
                    const cls = msg.delivery_status === 'read' ? 'telegram-message-status read' : 'telegram-message-status';
                    return `<span class="${cls}">${st}</span>`;
                })() : '';
                
                let mediaHtml = '';
                if (msg.hasMedia) {
                    const ext = (msg.mediaFilename || '').toLowerCase().split('.').pop();
                    const isImage = (msg.mediaMimetype && msg.mediaMimetype.startsWith('image/')) || ['jpg','jpeg','png','gif','webp','bmp'].includes(ext);
                    const isVideo = (msg.mediaMimetype && msg.mediaMimetype.startsWith('video/')) || ['mp4','webm','mov','mkv'].includes(ext);
                    const isAudio = (msg.mediaMimetype && msg.mediaMimetype.startsWith('audio/')) || ['mp3','ogg','opus','wav','m4a','aac'].includes(ext);
                    const isTgs = (msg.mediaMimetype && String(msg.mediaMimetype).includes('tgsticker')) || ext === 'tgs';
                    const fileUrl = msg.fileUrl ? `${TELEGRAM_API_URL}${msg.fileUrl}` : (msg.mediaUrl && msg.mediaUrl.startsWith('/api/') ? `${TELEGRAM_API_URL}${msg.mediaUrl}` : null);
                    const src = msg.mediaUrl || fileUrl;
                    if (src) {
                        if (isTgs) {
                            mediaHtml = `<div class="telegram-tgs-sticker" data-tgs-src="${src}" aria-label="Sticker"></div>`;
                        } else if (isImage) {
                            mediaHtml = `<img src="${src}" alt="Media" class="telegram-message-media" loading="lazy" onclick="window.open('${src}', '_blank')">`;
                        } else if (isVideo) {
                            mediaHtml = `<video controls class="telegram-message-media" style="max-width: 100%; border-radius: 8px; margin-top: 4px;">
                                <source src="${src}" type="${msg.mediaMimetype || 'video/mp4'}">
                            </video>`;
                        } else if (isAudio) {
                            const dl = fileUrl ? `${fileUrl}&download=true` : src;
                            mediaHtml = `
                                <div class="telegram-audio-container">
                                    <audio controls preload="metadata" src="${src}" style="margin-top: 4px; width: 100%;"></audio>
                                    <a href="${dl}" class="telegram-media-download" style="display: inline-block; margin-top: 6px;" download="${msg.mediaFilename || 'audio'}">Download</a>
                                </div>
                            `;
                        } else {
                            const dl = fileUrl ? `${fileUrl}&download=true` : src;
                            mediaHtml = `<div class="telegram-message-media-file">
                                <a href="${dl}" download="${msg.mediaFilename || 'file'}" class="telegram-media-download">
                                    üìé ${msg.mediaFilename || 'Download file'}
                                </a>
                            </div>`;
                        }
                    } else {
                        const label = msg.mediaFilename ? `üìé ${escapeHtml(msg.mediaFilename)}` : 'üìé Load media';
                        mediaHtml = `<div class="telegram-message-media-file">
                            <button class="telegram-media-download" onclick="window.telegramLoadMedia && window.telegramLoadMedia('${currentTelegramChatId}', '${String(msg.id)}')">${label}</button>
                        </div>`;
                    }
                }
                
                return `
                    <div class="telegram-message ${messageClass}" data-msg-id="${String(msg.id)}" data-from-me="${isMe ? '1' : '0'}" data-status="${msg.delivery_status || ''}">
                        <div class="telegram-message-content">
                            ${!isMe ? `<div class="telegram-message-sender">${escapeHtml(senderName)}</div>` : ''}
                            ${msg.body ? `<div class="telegram-message-text">${formatTelegramMessage(msg.body)}</div>` : ''}
                            ${mediaHtml}
                            <div class="telegram-message-time">${time}${statusHtml}</div>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Scroll to bottom unless caller wants to preserve scroll position (e.g. when prepending older messages)
            if (autoScroll) {
                telegramMessagesContainer.scrollTop = telegramMessagesContainer.scrollHeight;
            }

            // Render Telegram .tgs animated stickers (Lottie) after DOM is updated
            try { renderTelegramTgsStickers(telegramMessagesContainer); } catch (e) {}
        }

        async function renderTelegramTgsStickers(rootEl) {
            const root = rootEl || document;
            if (!root || !root.querySelectorAll) return;
            if (!window.pako || !window.lottie) return;

            const els = Array.from(root.querySelectorAll('.telegram-tgs-sticker[data-tgs-src]'))
                .filter(el => !el.getAttribute('data-rendered'));

            for (const el of els) {
                const url = el.getAttribute('data-tgs-src');
                if (!url) continue;
                el.setAttribute('data-rendered', '1');
                el.innerHTML = '<div class="telegram-tgs-loading">Loading sticker‚Ä¶</div>';

                try {
                    const resp = await fetch(url, { method: 'GET' });
                    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);

                    const bytes = new Uint8Array(await resp.arrayBuffer());
                    let jsonText = null;
                    try {
                        // Most .tgs are gzipped Lottie JSON
                        const ungz = window.pako.ungzip(bytes);
                        jsonText = new TextDecoder('utf-8').decode(ungz);
                    } catch (e) {
                        // If it isn't gzipped for some reason, try raw JSON
                        jsonText = new TextDecoder('utf-8').decode(bytes);
                    }

                    const animationData = JSON.parse(jsonText);
                    el.innerHTML = '';
                    window.lottie.loadAnimation({
                        container: el,
                        renderer: 'svg',
                        loop: true,
                        autoplay: true,
                        animationData
                    });
                } catch (err) {
                    el.removeAttribute('data-rendered');
                    el.innerHTML = '<div class="telegram-tgs-fallback">Sticker</div>';
                }
            }
        }

        function updateTelegramCount() {
            if (telegramCount) {
                const total = telegramChats.reduce((sum, chat) => sum + (chat.unread_count || 0), 0);
                telegramCount.textContent = total > 0 ? `${total} unread` : 'All read';
            }
        }

        function isTimeoutLikeError(err) {
            try {
                const name = (err && err.name) ? String(err.name) : '';
                const msg = (err && err.message) ? String(err.message) : '';
                return name === 'AbortError' || name === 'TimeoutError' || /timed out/i.test(msg) || /timeout/i.test(msg);
            } catch (e) {
                return false;
            }
        }

        async function fetchWithTimeout(url, options = {}, timeoutMs = 30000) {
            const opts = { ...options };
            // Prefer native AbortSignal.timeout if available
            if (typeof AbortSignal !== 'undefined' && typeof AbortSignal.timeout === 'function') {
                opts.signal = AbortSignal.timeout(timeoutMs);
                return await fetch(url, opts);
            }
            // Fallback for older browsers
            const controller = new AbortController();
            const timer = setTimeout(() => controller.abort(), timeoutMs);
            try {
                opts.signal = controller.signal;
                return await fetch(url, opts);
            } finally {
                clearTimeout(timer);
            }
        }

        async function loadTelegramMessages() {
            console.log('[DEBUG] loadTelegramMessages called');
            // Ensure realtime socket attempts are re-enabled when user hits Refresh
            if (window.reconnectTelegramWebSocket) {
                window.reconnectTelegramWebSocket();
            }
            if (telegramShowButton) {
                telegramShowButton.disabled = true;
                telegramShowButton.textContent = 'Loading...';
            }
            telegramLoadedOnce = false;
            telegramChats = [];
            telegramChatMessages = {};
            currentChatId = null;
            currentTelegramChatId = null;
            telegramChatPaging = {};
            const _tgInput = document.getElementById('telegramInputContainer');
            if (_tgInput) _tgInput.style.display = 'none';
            if (telegramAttachButton) telegramAttachButton.disabled = true;
            if (telegramEditLastBtn) telegramEditLastBtn.disabled = true;
            if (telegramClearChatBtn) telegramClearChatBtn.disabled = true;

            // Clear previous content
            if (telegramChatsList) {
                telegramChatsList.innerHTML = '<div class="telegram-sidebar-empty">Loading chats...</div>';
            }
            if (telegramMessagesContainer) {
                telegramMessagesContainer.innerHTML = '<div class="telegram-empty-state"><p>Loading...</p></div>';
            }

            try {
                // Step 0: Quick health check (distinguish "server down" vs "Telegram slow")
                try {
                    const healthResp = await fetchWithTimeout(`${TELEGRAM_API_URL}/health`, { method: 'GET' }, 4000);
                    if (!healthResp.ok) {
                        throw new Error(`HTTP ${healthResp.status}: ${healthResp.statusText}`);
                    }
                } catch (e) {
                    if (isTimeoutLikeError(e)) {
                        throw new Error('Request timeout: Telegram server is taking too long to respond. Please wait a few seconds and retry.');
                    }
                    throw new Error('Cannot connect to Telegram server. Make sure it is running on port 3001.');
                }

                // Step 1: Check status
                console.log('[*] Checking Telegram status...');
                let statusResponse;
                try {
                    statusResponse = await fetchWithTimeout(`${TELEGRAM_API_URL}/api/telegram/status`, {
                        method: 'GET',
                        headers: {
                            'Content-Type': 'application/json',
                        }
                    }, 30000); // Telegram startup can be slow; allow more time
                } catch (fetchError) {
                    if (isTimeoutLikeError(fetchError)) {
                        throw new Error('Request timeout: Telegram is still starting/connecting. Please wait ~10‚Äì30 seconds and click Refresh again.');
                    } else if (fetchError.message.includes('Failed to fetch') || fetchError.message.includes('ERR_CONNECTION_REFUSED')) {
                        throw new Error('Cannot connect to Telegram server. Make sure the server is running on port 3001.');
                    }
                    throw fetchError;
                }

                if (!statusResponse.ok) {
                    throw new Error(`HTTP ${statusResponse.status}: ${statusResponse.statusText}`);
                }

                const statusData = await statusResponse.json();
                console.log('[*] Telegram status:', statusData);
                
                // Check if API credentials are missing
                if (!statusData.has_api_credentials) {
                    if (telegramMessagesContainer) {
                        telegramMessagesContainer.innerHTML = `
                            <div class="telegram-empty-state">
                                <h3>üîê API Credentials Required</h3>
                                <p style="margin-bottom: 20px;">To use Telegram, you need to set up API credentials from Telegram.</p>
                                <div style="text-align: left; max-width: 600px; margin: 0 auto; background: rgba(0,0,0,0.05); padding: 20px; border-radius: 8px;">
                                    <h4 style="margin-top: 0;">Step 1: Get API Credentials</h4>
                                    <ol style="line-height: 1.8;">
                                        <li>Go to <a href="https://my.telegram.org" target="_blank" style="color: #0088cc;">https://my.telegram.org</a></li>
                                        <li>Log in with your phone number</li>
                                        <li>Go to "API development tools"</li>
                                        <li>Create a new application (if needed)</li>
                                        <li>Copy your <strong>API ID</strong> and <strong>API Hash</strong></li>
                                    </ol>
                                    <h4 style="margin-top: 20px;">Step 2: Add Credentials to Environment</h4>
                                    <p style="margin-bottom: 10px;">Set environment variables before starting the Telegram server:</p>
                                    <code style="display: block; background: rgba(0,0,0,0.1); padding: 10px; border-radius: 4px; margin: 10px 0; font-size: 12px; font-family: 'Courier New', monospace;">
                                        TELEGRAM_API_ID=YOUR_API_ID<br>
                                        TELEGRAM_API_HASH=YOUR_API_HASH
                                    </code>
                                    <p style="margin-top: 10px; font-size: 12px; color: #666;">
                                        Then start the Telegram server: <code style="background: rgba(0,0,0,0.1); padding: 2px 6px; border-radius: 4px;">npm run telegram</code>
                                    </p>
                                </div>
                            </div>
                        `;
                    }
                    if (telegramShowButton) {
                        telegramShowButton.disabled = false;
                        telegramShowButton.textContent = 'Refresh';
                    }
                    return;
                }
                
                // Check if authentication is required
                if (!statusData.is_authenticated || !statusData.is_connected) {
                    if (telegramMessagesContainer) {
                        telegramMessagesContainer.innerHTML = `
                            <div class="telegram-empty-state">
                                <div class="telegram-empty-icon">üîê</div>
                                <h3>Authentication Required</h3>
                                <p style="margin-top: 16px; color: #707579; max-width: 500px; line-height: 1.6;">
                                    Please authenticate with Telegram. Enter your phone number to receive a verification code.
                                </p>
                                <div style="margin-top: 20px; max-width: 400px;">
                                    <input type="text" id="telegramPhoneInput" placeholder="+1234567890" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px; margin-bottom: 10px;">
                                    <button id="telegramAuthPhoneBtn" style="width: 100%; padding: 10px; background: #0088cc; color: white; border: none; border-radius: 6px; cursor: pointer;">
                                        Send Code
                                    </button>
                                </div>
                                <div id="telegramAuthCodeDiv" style="margin-top: 20px; max-width: 400px; display: none;">
                                    <input type="text" id="telegramCodeInput" placeholder="Verification code" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px; margin-bottom: 10px;">
                                    <input type="text" id="telegramPasswordInput" placeholder="2FA Password (if required)" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 6px; margin-bottom: 10px; display: none;">
                                    <button id="telegramAuthCodeBtn" style="width: 100%; padding: 10px; background: #0088cc; color: white; border: none; border-radius: 6px; cursor: pointer;">
                                        Verify Code
                                    </button>
                                </div>
                            </div>
                        `;
                        
                        // Phone authentication
                        const phoneBtn = document.getElementById('telegramAuthPhoneBtn');
                        const phoneInput = document.getElementById('telegramPhoneInput');
                        if (phoneBtn && phoneInput) {
                            phoneBtn.addEventListener('click', async () => {
                                const phone = phoneInput.value.trim();
                                if (!phone) {
                                    alert('Please enter your phone number');
                                    return;
                                }
                                try {
                                    const response = await fetch(`${TELEGRAM_API_URL}/api/telegram/auth/phone`, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ phone_number: phone })
                                    });
                                    
                                    let data;
                                    try {
                                        const text = await response.text();
                                        if (text) {
                                            data = JSON.parse(text);
                                        } else {
                                            data = { success: false, error: 'Empty response from server' };
                                        }
                                    } catch (parseError) {
                                        console.error('[Telegram] Error parsing response:', parseError);
                                        data = { 
                                            success: false, 
                                            error: `Server error (HTTP ${response.status}): ${response.statusText}` 
                                        };
                                    }
                                    
                                    if (!response.ok) {
                                        // Show detailed error message
                                        const errorMsg = (data && data.error) ? String(data.error) : `HTTP ${response.status}: ${response.statusText}`;
                                        console.error('[Telegram] Auth error:', errorMsg);
                                        alert(`Error: ${errorMsg}\n\nPlease check:\n- Phone number format (include country code, e.g., +1234567890)\n- API credentials are set in .env file\n- Server console for more details`);
                                        return;
                                    }
                                    
                                    if (data.success) {
                                        document.getElementById('telegramAuthCodeDiv').style.display = 'block';
                                        window.telegramPhoneCodeHash = data.phone_code_hash;
                                        window.telegramPhoneNumber = phone;
                                        alert('Code sent! Check your Telegram app for the verification code.');
                                    } else {
                                        alert('Error: ' + (data.error || 'Failed to send code'));
                                    }
                                } catch (error) {
                                    console.error('[Telegram] Auth request error:', error);
                                    alert('Error: ' + error.message + '\n\nMake sure the Telegram server is running on port 3001.');
                                }
                            });
                        }
                        
                        // Code verification
                        const codeBtn = document.getElementById('telegramAuthCodeBtn');
                        const codeInput = document.getElementById('telegramCodeInput');
                        const passwordInput = document.getElementById('telegramPasswordInput');
                        if (codeBtn && codeInput) {
                            codeBtn.addEventListener('click', async () => {
                                const code = codeInput.value.trim();
                                const password = passwordInput ? passwordInput.value.trim() : '';
                                if (!code && !password) {
                                    alert('Please enter verification code or password');
                                    return;
                                }
                                try {
                                    const response = await fetch(`${TELEGRAM_API_URL}/api/telegram/auth/code`, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({
                                            phone_code: code,
                                            phone_code_hash: window.telegramPhoneCodeHash,
                                            password: password || undefined
                                        })
                                    });
                                    const data = await response.json();
                                    if (data.success || data.is_authenticated) {
                                        alert('Authentication successful! Refreshing...');
                                        loadTelegramMessages();
                                    } else if (data.password_required) {
                                        if (passwordInput) passwordInput.style.display = 'block';
                                        alert('2FA password required');
                                    } else {
                                        alert('Error: ' + (data.error || 'Failed to verify code'));
                                    }
                                } catch (error) {
                                    alert('Error: ' + error.message);
                                }
                            });
                        }
                    }
                    if (telegramShowButton) {
                        telegramShowButton.disabled = false;
                        telegramShowButton.textContent = 'Refresh';
                    }
                    return;
                }

                // Step 2: Load contacts/chats
                console.log('[*] Loading Telegram contacts...');
                let contactsResponse;
                try {
                    contactsResponse = await fetchWithTimeout(`${TELEGRAM_API_URL}/api/telegram/contacts`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            limit: 100
                        })
                    }, 60000);
                } catch (e) {
                    if (isTimeoutLikeError(e)) {
                        throw new Error('Request timeout: Loading Telegram contacts is taking too long. Telegram may be busy; please retry.');
                    }
                    throw e;
                }

                if (!contactsResponse.ok) {
                    throw new Error(`HTTP ${contactsResponse.status}: ${contactsResponse.statusText}`);
                }

                const contactsData = await contactsResponse.json();
                console.log('[*] Contacts data received:', contactsData);

                if (contactsData.success) {
                    telegramLoadedOnce = true;
                    telegramChats = contactsData.contacts || [];
                    console.log(`[OK] Got ${telegramChats.length} Telegram contacts`);
                    
                    // Render chats sidebar
                    renderTelegramChats();
                    // Lazy-load real Telegram avatars (cached by backend)
                    loadTelegramAvatars(40);
                    
                    if (telegramMessagesContainer) {
                        telegramMessagesContainer.innerHTML = '<div class="telegram-empty-state"><p>Select a chat to view messages</p></div>';
                    }
                    
                    updateTelegramCount();
                    
                    // Auto-open a chat after refresh (restore last chat if possible, else first chat)
                    try {
                        const storedChatId = localStorage.getItem('telegram_last_chat_id');
                        const firstChatId = telegramChats && telegramChats[0] ? telegramChats[0].contact_id : null;
                        const preferredChatId = (storedChatId && telegramChats.some(c => c.contact_id === storedChatId))
                            ? storedChatId
                            : firstChatId;
                        if (preferredChatId && typeof window.selectTelegramChat === 'function') {
                            window.selectTelegramChat(preferredChatId);
                        }
                    } catch (e) {
                        // ignore
                    }

                    // Fallback polling if realtime socket isn't connected
                    if (telegramRealtimePollTimer) {
                        clearInterval(telegramRealtimePollTimer);
                        telegramRealtimePollTimer = null;
                    }
                    telegramRealtimePollTimer = setInterval(async () => {
                        try {
                            if (telegramSocket && telegramSocket.connected) return;
                            if (!currentTelegramChatId) return;
                            const resp = await fetchWithTimeout(`${TELEGRAM_API_URL}/api/telegram/messages`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ chat_id: currentTelegramChatId, limit: 50 })
                            }, 30000);
                            if (!resp.ok) return;
                            const data = await resp.json();
                            if (!data || !data.success) return;
                            telegramChatMessages[currentTelegramChatId] = data.messages || [];
                            applyReadStatusFromChat(currentTelegramChatId, telegramChatMessages[currentTelegramChatId]);
                            telegramChatPaging[currentTelegramChatId] = telegramChatPaging[currentTelegramChatId] || {};
                            telegramChatPaging[currentTelegramChatId].oldestId = data.oldest_id || (telegramChatMessages[currentTelegramChatId][0] ? telegramChatMessages[currentTelegramChatId][0].id : null);
                            telegramChatPaging[currentTelegramChatId].reachedStart = !!data.reached_start;
                            if (currentChatId === currentTelegramChatId) {
                                renderTelegramMessages(telegramChatMessages[currentTelegramChatId], false);
                                if (telegramCount) telegramCount.textContent = `${telegramChatMessages[currentTelegramChatId].length} messages`;
                            }
                        } catch (e) {
                            // ignore polling errors
                        }
                    }, 5000);
                } else {
                    throw new Error(contactsData.error || 'Failed to load contacts');
                }
            } catch (error) {
                console.error('[!] Exception:', error);
                let errorMsg = error.message || 'Unknown error';
                
                // Provide more helpful error messages
                if (errorMsg.includes('Failed to fetch') || errorMsg.includes('ERR_CONNECTION_REFUSED')) {
                    errorMsg = 'Cannot connect to Telegram server. Please make sure:\n\n' +
                        '1. The Telegram server is running (port 3001)\n' +
                        '2. Run "python app.py" to start all servers\n' +
                        '3. Wait a few seconds for servers to start\n' +
                        '4. Refresh this page';
                } else if (errorMsg.includes('timeout')) {
                    errorMsg = 'Request timeout: The Telegram server is not responding. Please check if the server is running.';
                }
                
                if (telegramMessagesContainer) {
                    telegramMessagesContainer.innerHTML = `
                        <div class="telegram-empty-state">
                            <div class="telegram-empty-icon">‚ö†Ô∏è</div>
                            <h3>Error Loading Telegram</h3>
                            <p style="white-space: pre-line; text-align: left; max-width: 600px; margin: 0 auto;">${escapeHtml(errorMsg)}</p>
                            <button onclick="loadTelegramMessages()" style="margin-top: 20px; padding: 10px 20px; background: #0088cc; color: white; border: none; border-radius: 5px; cursor: pointer;">Retry</button>
                        </div>
                    `;
                }
                if (telegramChatsList) {
                    telegramChatsList.innerHTML = '<div class="telegram-sidebar-empty">Error loading chats</div>';
                }
                if (telegramCount) telegramCount.textContent = 'Error';
            } finally {
                // Always re-enable the button
                if (telegramShowButton) {
                    telegramShowButton.disabled = false;
                    telegramShowButton.textContent = 'Refresh';
                }
            }
        }

        // Telegram button handler
        if (telegramShowButton) {
            telegramShowButton.addEventListener('click', loadTelegramMessages);
        }
        
        // Telegram WebSocket initializer (kept for compatibility with tab activation logic)
        function initializeTelegramWebSocket() {
            connectTelegramWebSocket();
        }

        // WhatsApp functionality
        const whatsappShowButton = document.getElementById('whatsappShowButton');
        const whatsappChatsList = document.getElementById('whatsappChatsList');
        const whatsappMessagesContainer = document.getElementById('whatsappMessagesContainer');
        const whatsappCurrentChat = document.getElementById('whatsappCurrentChat');
        const whatsappCount = document.getElementById('whatsappCount');
        const whatsappStatus = document.getElementById('whatsappStatus');
        const whatsappMessageInput = document.getElementById('whatsappMessageInput');
        const whatsappSendButton = document.getElementById('whatsappSendButton');
        const whatsappInputContainer = document.getElementById('whatsappInputContainer');
        const whatsappQrContainer = document.getElementById('whatsappQrContainer');
        const whatsappQrImage = document.getElementById('whatsappQrImage');
        const whatsappQrStatus = document.getElementById('whatsappQrStatus');
        const whatsappQrTitle = document.getElementById('whatsappQrTitle');
        const whatsappQrDescription = document.getElementById('whatsappQrDescription');
        const whatsappQrImageWrapper = document.getElementById('whatsappQrImageWrapper');
        const whatsappQrRefreshBtn = document.getElementById('whatsappQrRefreshBtn');
        const whatsappEmptyState = document.getElementById('whatsappEmptyState');

        let allWhatsAppMessages = [];
        let whatsappMessagesByChat = {};
        let currentWhatsAppChatId = null;
        let currentWhatsAppContactName = null;
        let whatsappAuthCheckInterval = null;
        let whatsappQrRefreshInterval = null;
        let whatsappIsAuthenticated = false;
        let whatsappSocket = null;
        let currentChatMessages = []; // Store messages for currently open chat

        async function checkWhatsAppStatus() {
            if (whatsappIsAuthenticated) {
                return true;
            }
            try {
                console.log('[*] Checking WhatsApp authentication status...');
                const response = await fetch('http://localhost:3000/api/whatsapp/status', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                console.log('[*] WhatsApp status response:', data);

                // Check if connected (authenticated)
                if (data.success && data.is_connected) {
                    console.log('[*] WhatsApp authenticated! Hiding QR code and showing connected state.');
                    whatsappIsAuthenticated = true;
                    
                    // Stop all intervals
                    if (whatsappAuthCheckInterval) {
                        clearInterval(whatsappAuthCheckInterval);
                        whatsappAuthCheckInterval = null;
                    }
                    if (whatsappQrRefreshInterval) {
                        clearInterval(whatsappQrRefreshInterval);
                        whatsappQrRefreshInterval = null;
                    }
                    
                    // Hide QR code container
                    if (whatsappQrContainer) {
                        whatsappQrContainer.style.display = 'none';
                    }
                    
                    // Show empty state (ready for chats)
                    if (whatsappEmptyState) {
                        whatsappEmptyState.style.display = 'flex';
                    }
                    
                    // Update status
                    if (whatsappCurrentChat) {
                        whatsappCurrentChat.textContent = 'WhatsApp';
                    }
                    if (whatsappStatus) {
                        whatsappStatus.textContent = 'Connected';
                    }
                    if (whatsappCount) {
                        whatsappCount.textContent = 'Ready';
                    }
                    
                    console.log('[*] WhatsApp UI updated to connected state');
                    return true;
                }
                
                // Check if session exists but not connected yet (restoring)
                if (data.has_session && !data.is_connected) {
                    console.log('[*] WhatsApp session exists - waiting for authentication to restore');
                    
                    // Show restoring message
                    if (whatsappQrContainer) {
                        whatsappQrContainer.style.display = 'flex';
                    }
                    if (whatsappQrImageWrapper) {
                        whatsappQrImageWrapper.style.display = 'none';
                    }
                    if (whatsappQrTitle) {
                        whatsappQrTitle.textContent = 'Restoring Connection...';
                    }
                    if (whatsappQrDescription) {
                        whatsappQrDescription.textContent = 'Your WhatsApp session is being restored';
                    }
                    if (whatsappQrStatus) {
                        whatsappQrStatus.textContent = 'Session found - restoring authentication. Please wait...';
                        whatsappQrStatus.style.color = '#3390ec';
                    }
                    if (whatsappEmptyState) {
                        whatsappEmptyState.style.display = 'none';
                    }
                    
                    // Start polling for authentication
                    if (!whatsappAuthCheckInterval) {
                        whatsappAuthCheckInterval = setInterval(async () => {
                            if (whatsappIsAuthenticated) {
                                clearInterval(whatsappAuthCheckInterval);
                                whatsappAuthCheckInterval = null;
                                return;
                            }
                            const isAuth = await checkWhatsAppStatus();
                            if (isAuth) {
                                clearInterval(whatsappAuthCheckInterval);
                                whatsappAuthCheckInterval = null;
                            }
                        }, 3000); // Check every 3 seconds
                    }
                    return false;
                }
                
                // No session - show QR code for first-time authentication
                if (!data.has_session) {
                    console.log('[*] WhatsApp is not authenticated and no session exists - showing QR code');
                    
                    // Show QR code container
                    if (whatsappQrContainer) {
                        whatsappQrContainer.style.display = 'flex';
                    }
                    if (whatsappEmptyState) {
                        whatsappEmptyState.style.display = 'none';
                    }
                    
                    // Load QR code
                    await loadWhatsAppQRCode();
                    
                    // Start monitoring for authentication
                    if (!whatsappAuthCheckInterval) {
                        whatsappAuthCheckInterval = setInterval(async () => {
                            if (whatsappIsAuthenticated) {
                                clearInterval(whatsappAuthCheckInterval);
                                whatsappAuthCheckInterval = null;
                                if (whatsappQrRefreshInterval) {
                                    clearInterval(whatsappQrRefreshInterval);
                                    whatsappQrRefreshInterval = null;
                                }
                                return;
                            }
                            const isAuth = await checkWhatsAppStatus();
                            if (isAuth) {
                                clearInterval(whatsappAuthCheckInterval);
                                whatsappAuthCheckInterval = null;
                                if (whatsappQrRefreshInterval) {
                                    clearInterval(whatsappQrRefreshInterval);
                                    whatsappQrRefreshInterval = null;
                                }
                            }
                        }, 3000); // Check every 3 seconds
                    }
                } else {
                    // Session exists but not connected yet - wait longer for restoration
                    console.log('[*] Session exists but not connected yet - continuing to wait for restoration');
                }
                
                return false;
            } catch (error) {
                console.error('[!] Error checking WhatsApp status:', error);
                if (whatsappQrStatus) {
                    whatsappQrStatus.textContent = `Error: ${error.message}`;
                    whatsappQrStatus.style.color = '#ff4444';
                }
                return false;
            }
        }

        async function loadWhatsAppQRCode(forceRefresh = false) {
            try {
                console.log(`[*] Requesting WhatsApp QR code (forceRefresh=${forceRefresh})...`);
                const url = forceRefresh 
                    ? 'http://localhost:3000/api/whatsapp/qr-code?force_refresh=true'
                    : 'http://localhost:3000/api/whatsapp/qr-code';
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                console.log('[*] QR code response:', data);

                if (data.success && data.qr_code) {
                    if (whatsappQrImage) {
                        whatsappQrImage.src = data.qr_code;
                    }
                    if (whatsappQrContainer) {
                        whatsappQrContainer.style.display = 'flex';
                    }
                    if (whatsappQrImageWrapper) {
                        whatsappQrImageWrapper.style.display = 'block';
                    }
                    if (whatsappEmptyState) {
                        whatsappEmptyState.style.display = 'none';
                    }
                    if (whatsappQrStatus) {
                        whatsappQrStatus.textContent = 'Scan the QR code with WhatsApp to connect';
                        whatsappQrStatus.style.color = '#8696a0';
                    }
                    if (whatsappQrTitle) {
                        whatsappQrTitle.textContent = 'Scan QR Code to Connect';
                    }
                    if (whatsappQrDescription) {
                        whatsappQrDescription.textContent = 'Open WhatsApp on your phone and scan this code';
                    }
                    if (whatsappQrRefreshBtn) {
                        whatsappQrRefreshBtn.style.display = 'inline-block';
                    }

                    // Auto-refresh QR code every 20 seconds (QR codes expire after ~20 seconds)
                    if (!whatsappQrRefreshInterval && !whatsappIsAuthenticated) {
                        console.log('[*] Starting QR code auto-refresh (every 20 seconds)...');
                        whatsappQrRefreshInterval = setInterval(async () => {
                            if (whatsappIsAuthenticated) {
                                console.log('[*] Authenticated - stopping QR code refresh');
                                if (whatsappQrRefreshInterval) {
                                    clearInterval(whatsappQrRefreshInterval);
                                    whatsappQrRefreshInterval = null;
                                }
                                return;
                            }
                            
                            // Force refresh QR code only if still not authenticated
                            console.log('[*] Refreshing QR code (not authenticated yet)...');
                            await loadWhatsAppQRCode(true);
                        }, 20000); // Refresh every 20 seconds
                    }
                } else if (data.is_authenticated) {
                    // Already authenticated
                    whatsappIsAuthenticated = true;
                    if (whatsappQrContainer) {
                        whatsappQrContainer.style.display = 'none';
                    }
                    if (whatsappEmptyState) {
                        whatsappEmptyState.style.display = 'flex';
                    }
                } else {
                    if (whatsappQrStatus) {
                        whatsappQrStatus.textContent = data.message || 'QR code not available. Please wait...';
                        whatsappQrStatus.style.color = '#8696a0';
                    }
                }
            } catch (error) {
                console.error('[!] Error loading WhatsApp QR code:', error);
                if (whatsappQrStatus) {
                    whatsappQrStatus.textContent = `Error: ${error.message}`;
                    whatsappQrStatus.style.color = '#ff4444';
                }
            }
        }

        async function loadWhatsAppMessages() {
            if (!whatsappShowButton) return;
            
            whatsappShowButton.disabled = true;
            whatsappShowButton.textContent = 'Loading...';
            allWhatsAppMessages = [];
            whatsappMessagesByChat = {};
            currentWhatsAppChatId = null;

            try {
                const isAuth = await checkWhatsAppStatus();
                if (!isAuth) {
                    whatsappShowButton.disabled = false;
                    whatsappShowButton.textContent = 'Refresh';
                    return;
                }

                const contactsResponse = await fetch('http://localhost:3000/api/whatsapp/contacts', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        limit: 100
                    })
                });

                if (!contactsResponse.ok) {
                    throw new Error(`HTTP ${contactsResponse.status}: ${contactsResponse.statusText}`);
                }

                const contactsData = await contactsResponse.json();
                console.log('[*] WhatsApp contacts:', contactsData);

                if (contactsData.success && contactsData.contacts && contactsData.contacts.length > 0) {
                    if (whatsappChatsList) {
                        whatsappChatsList.innerHTML = '';
                        contactsData.contacts.forEach(contact => {
                            const chatItem = document.createElement('div');
                            chatItem.className = 'whatsapp-chat-item';
                            chatItem.dataset.contactId = contact.contact_id || contact.name;
                            
                            const avatar = document.createElement('div');
                            avatar.className = 'whatsapp-chat-avatar';
                            const initials = (contact.name || '?').split(' ').map(n => n[0]).join('').toUpperCase().substring(0, 2);
                            if (contact.avatar_url) {
                                const img = document.createElement('img');
                                img.src = contact.avatar_url;
                                img.alt = contact.name || 'Avatar';
                                img.className = 'whatsapp-avatar-img';
                                avatar.textContent = '';
                                avatar.appendChild(img);
                            } else {
                                avatar.textContent = initials;
                            }
                            
                            const info = document.createElement('div');
                            info.className = 'whatsapp-chat-info';
                            
                            const name = document.createElement('div');
                            name.className = 'whatsapp-chat-name';
                            name.textContent = contact.name || 'Unknown';
                            
                            const preview = document.createElement('div');
                            preview.className = 'whatsapp-chat-preview';
                            preview.textContent = contact.last_message || (contact.is_group ? 'Group' : 'Chat');
                            
                            info.appendChild(name);
                            info.appendChild(preview);
                            chatItem.appendChild(avatar);
                            chatItem.appendChild(info);
                            
                            // Add click handler to load messages for this contact
                            chatItem.addEventListener('click', () => {
                                selectWhatsAppContact(contact.contact_id, contact.name);
                            });
                            
                            whatsappChatsList.appendChild(chatItem);
                        });
                    }

                    // Lazy-load WhatsApp avatars (cached by backend)
                    (async function loadWhatsAppAvatars(maxToLoad = 30) {
                        try {
                            const list = contactsData.contacts.filter(c => c && c.contact_id && !c.avatar_url).slice(0, Math.max(0, maxToLoad));
                            const concurrency = 5;
                            for (let i = 0; i < list.length; i += concurrency) {
                                const batch = list.slice(i, i + concurrency);
                                await Promise.all(batch.map(async (c) => {
                                    try {
                                        const r = await fetch(`http://localhost:3000/api/whatsapp/avatar?contact_id=${encodeURIComponent(c.contact_id)}`, { signal: AbortSignal.timeout(20000) });
                                        if (!r.ok) return;
                                        const data = await r.json();
                                        if (!data || !data.success || !data.avatar_url) return;
                                        c.avatar_url = data.avatar_url;
                                        const el = whatsappChatsList.querySelector(`.whatsapp-chat-item[data-contact-id="${CSS.escape(c.contact_id)}"] .whatsapp-chat-avatar`);
                                        if (!el) return;
                                        el.textContent = '';
                                        const img = document.createElement('img');
                                        img.src = c.avatar_url;
                                        img.alt = c.name || 'Avatar';
                                        img.className = 'whatsapp-avatar-img';
                                        el.appendChild(img);
                                    } catch (e) {
                                        // ignore avatar errors
                                    }
                                }));
                            }
                        } catch (e) {
                            // ignore
                        }
                    })(40);
                } else {
                    if (whatsappChatsList) {
                        whatsappChatsList.innerHTML = '<div class="whatsapp-sidebar-empty">No chats found</div>';
                    }
                }
            } catch (error) {
                console.error('[!] WhatsApp error:', error);
                if (whatsappChatsList) {
                    whatsappChatsList.innerHTML = '<div class="whatsapp-sidebar-empty">Error loading chats</div>';
                }
            } finally {
                if (whatsappShowButton) {
                    whatsappShowButton.disabled = false;
                    whatsappShowButton.textContent = 'Refresh';
                }
            }
        }

        /**
         * Initialize WebSocket connection for real-time messages
         */
        function initializeWhatsAppWebSocket() {
            if (whatsappSocket && whatsappSocket.connected) {
                console.log('[*] WhatsApp WebSocket already connected');
                return;
            }

            // Disconnect existing socket if any
            if (whatsappSocket) {
                whatsappSocket.disconnect();
            }

            console.log('[*] Initializing WhatsApp WebSocket connection...');
            whatsappSocket = io('http://localhost:3000', {
                reconnection: true,
                reconnectionDelay: 1000,
                reconnectionDelayMax: 5000,
                reconnectionAttempts: Infinity,
                timeout: 20000,
                transports: ['websocket', 'polling']
            });

            whatsappSocket.on('connect', () => {
                console.log('[*] WhatsApp WebSocket connected - Real-time messaging active');
            });

            whatsappSocket.on('disconnect', (reason) => {
                console.log('[*] WhatsApp WebSocket disconnected:', reason);
                if (reason === 'io server disconnect') {
                    // Server disconnected, reconnect manually
                    setTimeout(() => {
                        if (!whatsappSocket.connected) {
                            initializeWhatsAppWebSocket();
                        }
                    }, 1000);
                }
            });

            whatsappSocket.on('connect_error', (error) => {
                console.error('[*] WhatsApp WebSocket connection error:', error);
            });

            whatsappSocket.on('reconnect', (attemptNumber) => {
                console.log('[*] WhatsApp WebSocket reconnected after', attemptNumber, 'attempts');
            });

            whatsappSocket.on('whatsapp_status', (data) => {
                console.log('[*] WhatsApp status update:', data);
                if (data.is_connected && data.is_authenticated) {
                    whatsappIsAuthenticated = true;
                }
            });

            // Listen for incoming messages (instant display)
            whatsappSocket.on('whatsapp_message', (message) => {
                console.log('[*] Real-time WhatsApp message received:', message);
                // Display immediately without waiting
                handleIncomingWhatsAppMessage(message, true); // true = instant display
            });
            
            // Listen for message updates (with full contact info)
            whatsappSocket.on('whatsapp_message_update', (message) => {
                console.log('[*] WhatsApp message update received:', message);
                // Update existing message with full info
                handleIncomingWhatsAppMessage(message, false); // false = update existing
            });
        }

        /**
         * Handle incoming real-time WhatsApp message
         * @param {Object} message - The message object
         * @param {boolean} isInstant - If true, display immediately; if false, update existing
         */
        function handleIncomingWhatsAppMessage(message, isInstant = true) {
            // Check if message is for currently open chat
            const isForCurrentChat = currentWhatsAppChatId && (
                message.contact_id === currentWhatsAppChatId || 
                message.from === currentWhatsAppChatId ||
                message.to === currentWhatsAppChatId
            );
            
            // Check if message already exists (avoid duplicates)
            const existingIndex = currentChatMessages.findIndex(msg => msg.id === message.id);
            const messageExists = existingIndex !== -1;
            
            if (isForCurrentChat) {
                if (!messageExists && isInstant) {
                    // Add new message immediately
                    const msgData = {
                        id: message.id,
                        body: message.body,
                        from: message.from,
                        fromMe: message.fromMe,
                        timestamp: message.timestamp,
                        type: message.type,
                        hasMedia: message.hasMedia,
                        mediaUrl: message.mediaUrl || null,
                        mediaMimetype: message.mediaMimetype || null,
                        mediaFilename: message.mediaFilename || null
                    };
                    
                    currentChatMessages.push(msgData);
                    
                    // Sort by timestamp
                    currentChatMessages.sort((a, b) => a.timestamp - b.timestamp);
                    
                    // Append new message to display INSTANTLY
                    appendWhatsAppMessage(message);
                    
                    // Update message count
                    if (whatsappStatus) {
                        whatsappStatus.textContent = `${currentChatMessages.length} messages`;
                    }
                    if (whatsappCount) {
                        whatsappCount.textContent = `${currentChatMessages.length} messages`;
                    }
                } else if (messageExists && !isInstant) {
                    // Update existing message with full contact info
                    currentChatMessages[existingIndex] = {
                        id: message.id,
                        body: message.body,
                        from: message.from,
                        fromMe: message.fromMe,
                        timestamp: message.timestamp,
                        type: message.type,
                        hasMedia: message.hasMedia,
                        mediaUrl: message.mediaUrl || currentChatMessages[existingIndex].mediaUrl || null,
                        mediaMimetype: message.mediaMimetype || currentChatMessages[existingIndex].mediaMimetype || null,
                        mediaFilename: message.mediaFilename || currentChatMessages[existingIndex].mediaFilename || null
                    };
                    
                    // Update the displayed message if it exists
                    updateMessageDisplay(message.id, currentChatMessages[existingIndex]);
                }
            }
            
            // Always update contact preview in sidebar (even if chat not open)
            updateContactPreview(message);
        }

        /**
         * Append a single message to the messages display (INSTANT)
         */
        function appendWhatsAppMessage(message) {
            if (!whatsappMessagesContainer) return;

            const msgDate = new Date(message.timestamp * 1000);
            const timeStr = formatWhatsAppTime(message.timestamp);
            const formattedBody = escapeHtml(message.body || '');
            const isSent = message.fromMe || false;

            // Check if we need a date divider (check last visible message)
            let needsDateDivider = false;
            const lastMessageElement = whatsappMessagesContainer.querySelector('.whatsapp-message-wrapper:last-child');
            if (lastMessageElement) {
                const lastTimeAttr = lastMessageElement.getAttribute('data-timestamp');
                if (lastTimeAttr) {
                    const lastDate = new Date(parseInt(lastTimeAttr) * 1000);
                    needsDateDivider = msgDate.toDateString() !== lastDate.toDateString();
                } else {
                    needsDateDivider = true;
                }
            } else {
                needsDateDivider = true;
            }

            let html = '';
            
            // Date divider if needed
            if (needsDateDivider) {
                const dateStr = msgDate.toLocaleDateString('en-US', { 
                    weekday: 'long', 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                });
                html += `<div class="whatsapp-date-divider"><span>${dateStr}</span></div>`;
            }

            // Build media HTML
            let mediaHTML = '';
            if (message.hasMedia && message.mediaUrl) {
                const isImage = message.mediaMimetype?.startsWith('image/');
                const isVideo = message.mediaMimetype?.startsWith('video/');
                
                if (isImage) {
                    mediaHTML = `
                        <div class="whatsapp-media-container">
                            <img src="${message.mediaUrl}" alt="Image" class="whatsapp-media-image" onclick="openMediaViewer('${message.mediaUrl}', '${message.mediaFilename || 'image'}')" />
                            <a href="${message.mediaUrl}" download="${message.mediaFilename || 'image'}" class="whatsapp-media-download" title="Download image">‚¨áÔ∏è</a>
                        </div>
                    `;
                } else if (isVideo) {
                    mediaHTML = `
                        <div class="whatsapp-media-container">
                            <video controls class="whatsapp-media-video">
                                <source src="${message.mediaUrl}" type="${message.mediaMimetype}">
                            </video>
                            <a href="${message.mediaUrl}" download="${message.mediaFilename || 'video'}" class="whatsapp-media-download" title="Download video">‚¨áÔ∏è</a>
                        </div>
                    `;
                } else {
                    // File/document
                    const fileIcon = getFileIcon(message.mediaMimetype);
                    mediaHTML = `
                        <div class="whatsapp-media-container whatsapp-file-container">
                            <div class="whatsapp-file-icon">${fileIcon}</div>
                            <div class="whatsapp-file-info">
                                <div class="whatsapp-file-name">${escapeHtml(message.mediaFilename || 'File')}</div>
                                <div class="whatsapp-file-type">${message.mediaMimetype || 'Unknown type'}</div>
                            </div>
                            <a href="${message.mediaUrl}" download="${message.mediaFilename || 'file'}" class="whatsapp-media-download" title="Download file">‚¨áÔ∏è</a>
                        </div>
                    `;
                }
            } else if (message.hasMedia && !message.mediaUrl) {
                // Media is loading
                mediaHTML = '<div class="whatsapp-media-loading">Loading media...</div>';
            }

            // Build action buttons for sent messages
            let actionButtonsHTML = '';
            if (isSent) {
                actionButtonsHTML = `
                    <div class="whatsapp-message-actions">
                        <button class="whatsapp-action-btn" onclick="editWhatsAppMessage('${message.id}')" title="Edit message">‚úèÔ∏è</button>
                        <button class="whatsapp-action-btn" onclick="deleteWhatsAppMessage('${message.id}')" title="Delete message">üóëÔ∏è</button>
                    </div>
                `;
            }

            // Message bubble with timestamp attribute for future reference
            html += `
                <div class="whatsapp-message-wrapper ${isSent ? 'sent' : 'received'}" data-message-id="${message.id}" data-timestamp="${message.timestamp}">
                    <div class="whatsapp-message-bubble">
                        ${mediaHTML}
                        <div class="whatsapp-message-text">${formattedBody || '<em>No content</em>'}</div>
                        <div class="whatsapp-message-footer">
                            <div class="whatsapp-message-time">${timeStr}</div>
                            ${actionButtonsHTML}
                        </div>
                    </div>
                </div>
            `;

            // Append to container INSTANTLY using insertAdjacentHTML (fastest method)
            whatsappMessagesContainer.insertAdjacentHTML('beforeend', html);
            
            // Scroll to bottom smoothly
            requestAnimationFrame(() => {
                whatsappMessagesContainer.scrollTop = whatsappMessagesContainer.scrollHeight;
            });
        }

        /**
         * Update an existing message display (for media updates, edits, etc.)
         */
        function updateMessageDisplay(messageId, messageData) {
            const messageElement = whatsappMessagesContainer?.querySelector(`[data-message-id="${messageId}"]`);
            if (!messageElement) return;

            const bubble = messageElement.querySelector('.whatsapp-message-bubble');
            if (!bubble) return;

            // Update media if available
            if (messageData.hasMedia && messageData.mediaUrl) {
                const existingMedia = bubble.querySelector('.whatsapp-media-container');
                if (!existingMedia) {
                    // Insert media before text
                    const textElement = bubble.querySelector('.whatsapp-message-text');
                    if (textElement) {
                        const isImage = messageData.mediaMimetype?.startsWith('image/');
                        const isVideo = messageData.mediaMimetype?.startsWith('video/');
                        let mediaHTML = '';
                        
                        if (isImage) {
                            mediaHTML = `
                                <div class="whatsapp-media-container">
                                    <img src="${messageData.mediaUrl}" alt="Image" class="whatsapp-media-image" onclick="openMediaViewer('${messageData.mediaUrl}', '${messageData.mediaFilename || 'image'}')" />
                                    <a href="${messageData.mediaUrl}" download="${messageData.mediaFilename || 'image'}" class="whatsapp-media-download" title="Download image">‚¨áÔ∏è</a>
                                </div>
                            `;
                        } else if (isVideo) {
                            mediaHTML = `
                                <div class="whatsapp-media-container">
                                    <video controls class="whatsapp-media-video">
                                        <source src="${messageData.mediaUrl}" type="${messageData.mediaMimetype}">
                                    </video>
                                    <a href="${messageData.mediaUrl}" download="${messageData.mediaFilename || 'video'}" class="whatsapp-media-download" title="Download video">‚¨áÔ∏è</a>
                                </div>
                            `;
                        }
                        
                        if (mediaHTML) {
                            textElement.insertAdjacentHTML('beforebegin', mediaHTML);
                        }
                    }
                }
            }

            // Update text if changed
            const textElement = bubble.querySelector('.whatsapp-message-text');
            if (textElement && messageData.body) {
                textElement.innerHTML = escapeHtml(messageData.body);
            }
        }

        /**
         * Get file icon based on MIME type
         */
        window.getFileIcon = function(mimetype) {
            if (!mimetype) return 'üìÑ';
            if (mimetype.includes('pdf')) return 'üìï';
            if (mimetype.includes('word') || mimetype.includes('document')) return 'üìò';
            if (mimetype.includes('excel') || mimetype.includes('spreadsheet')) return 'üìó';
            if (mimetype.includes('zip') || mimetype.includes('archive')) return 'üì¶';
            if (mimetype.includes('audio')) return 'üéµ';
            return 'üìÑ';
        }

        window.openMediaViewer = function(mediaUrl, filename) {
            // Create modal overlay
            const modal = document.createElement('div');
            modal.className = 'whatsapp-media-viewer';
            modal.innerHTML = `
                <div class="whatsapp-media-viewer-content">
                    <button class="whatsapp-media-viewer-close" onclick="this.closest('.whatsapp-media-viewer').remove()">&times;</button>
                    <img src="${mediaUrl}" alt="${filename}" />
                    <a href="${mediaUrl}" download="${filename}" class="whatsapp-media-viewer-download">Download</a>
                </div>
            `;
            document.body.appendChild(modal);
            modal.addEventListener('click', (e) => {
                if (e.target === modal) modal.remove();
            });
        }

        // Make functions globally accessible
        window.editWhatsAppMessage = async function(messageId) {
            const message = currentChatMessages.find(msg => msg.id === messageId);
            if (!message) {
                alert('Message not found');
                return;
            }

            const newText = prompt('Edit message:', message.body || '');
            if (newText === null || newText === message.body) {
                return; // User cancelled or didn't change
            }

            try {
                const response = await fetch(`http://localhost:3000/api/whatsapp/message/${messageId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        text: newText
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                if (data.success) {
                    // Update local message
                    message.body = newText;
                    updateMessageDisplay(messageId, message);
                    console.log('[*] Message edited successfully');
                } else {
                    throw new Error(data.error || 'Failed to edit message');
                }
            } catch (error) {
                console.error('[!] Error editing message:', error);
                alert(`Error editing message: ${error.message}`);
            }
        }

        window.deleteWhatsAppMessage = async function(messageId) {
            if (!confirm('Are you sure you want to delete this message?')) {
                return;
            }

            try {
                const response = await fetch(`http://localhost:3000/api/whatsapp/message/${messageId}`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                if (data.success) {
                    // Remove message from local array
                    const index = currentChatMessages.findIndex(msg => msg.id === messageId);
                    if (index !== -1) {
                        currentChatMessages.splice(index, 1);
                    }

                    // Remove message from display
                    const messageElement = whatsappMessagesContainer?.querySelector(`[data-message-id="${messageId}"]`);
                    if (messageElement) {
                        messageElement.remove();
                    }

                    // Update message count
                    if (whatsappStatus) {
                        whatsappStatus.textContent = `${currentChatMessages.length} messages`;
                    }
                    if (whatsappCount) {
                        whatsappCount.textContent = `${currentChatMessages.length} messages`;
                    }

                    console.log('[*] Message deleted successfully');
                } else {
                    throw new Error(data.error || 'Failed to delete message');
                }
            } catch (error) {
                console.error('[!] Error deleting message:', error);
                alert(`Error deleting message: ${error.message}`);
            }
        }

        /**
         * Update contact preview in sidebar when new message arrives
         */
        function updateContactPreview(message) {
            const contactItem = document.querySelector(`.whatsapp-chat-item[data-contact-id="${message.contact_id}"]`);
            if (contactItem) {
                const previewElement = contactItem.querySelector('.whatsapp-chat-preview');
                if (previewElement) {
                    previewElement.textContent = message.body?.substring(0, 50) || 'New message';
                }
            }
        }

        /**
         * Select a WhatsApp contact and load their messages
         */
        async function selectWhatsAppContact(contactId, contactName) {
            currentWhatsAppChatId = contactId;
            currentWhatsAppContactName = contactName;
            
            // Update UI to show selected contact
            if (whatsappCurrentChat) {
                whatsappCurrentChat.textContent = contactName || 'Unknown';
            }
            if (whatsappStatus) {
                whatsappStatus.textContent = 'Loading messages...';
            }
            
            // Hide empty state and QR code
            if (whatsappEmptyState) {
                whatsappEmptyState.style.display = 'none';
            }
            if (whatsappQrContainer) {
                whatsappQrContainer.style.display = 'none';
            }
            
            // Show input container
            if (whatsappInputContainer) {
                whatsappInputContainer.style.display = 'block';
            }
            
            // Update active state in sidebar
            document.querySelectorAll('.whatsapp-chat-item').forEach(item => {
                item.classList.toggle('active', item.dataset.contactId === contactId);
            });
            
            // Load messages for this contact
            await loadWhatsAppContactMessages(contactId, contactName);
        }

        /**
         * Load messages for a specific WhatsApp contact
         */
        async function loadWhatsAppContactMessages(contactId, contactName) {
            try {
                console.log(`[*] Loading messages for contact: ${contactName} (${contactId})`);
                
                const response = await fetch('http://localhost:3000/api/whatsapp/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contact_id: contactId,
                        limit: 100
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                console.log('[*] WhatsApp messages response:', data);

                if (data.success && data.messages) {
                    // Store messages for current chat
                    currentChatMessages = data.messages;
                    
                    // Update status
                    if (whatsappStatus) {
                        whatsappStatus.textContent = `${data.count} messages`;
                    }
                    if (whatsappCount) {
                        whatsappCount.textContent = `${data.count} messages`;
                    }
                    
                    // Display messages
                    displayWhatsAppMessages(currentChatMessages, contactName);
                } else {
                    throw new Error(data.error || 'Failed to load messages');
                }
            } catch (error) {
                console.error('[!] Error loading WhatsApp messages:', error);
                if (whatsappMessagesContainer) {
                    whatsappMessagesContainer.innerHTML = `
                        <div class="whatsapp-empty-state">
                            <div class="whatsapp-empty-icon">‚ö†Ô∏è</div>
                            <h3>Error Loading Messages</h3>
                            <p>${error.message}</p>
                        </div>
                    `;
                }
                if (whatsappStatus) {
                    whatsappStatus.textContent = 'Error';
                }
            }
        }

        /**
         * Display WhatsApp messages in the messages container
         */
        function displayWhatsAppMessages(messages, contactName) {
            if (!whatsappMessagesContainer) return;
            
            if (!messages || messages.length === 0) {
                whatsappMessagesContainer.innerHTML = `
                    <div class="whatsapp-empty-state">
                        <div class="whatsapp-empty-icon">üí¨</div>
                        <h3>No messages</h3>
                        <p>Start a conversation with ${contactName || 'this contact'}</p>
                    </div>
                `;
                return;
            }

            let lastDate = null;
            const messagesHTML = messages.map((msg) => {
                const msgDate = new Date(msg.timestamp * 1000); // WhatsApp timestamps are in seconds
                const currentDate = msgDate.toDateString();
                const showDateDivider = lastDate !== currentDate;
                lastDate = currentDate;

                const timeStr = formatWhatsAppTime(msg.timestamp);
                const formattedBody = escapeHtml(msg.body || '');
                const isSent = msg.fromMe || false;

                let html = '';
                
                // Date divider
                if (showDateDivider) {
                    const dateStr = msgDate.toLocaleDateString('en-US', { 
                        weekday: 'long', 
                        year: 'numeric', 
                        month: 'long', 
                        day: 'numeric' 
                    });
                    html += `<div class="whatsapp-date-divider"><span>${dateStr}</span></div>`;
                }

                // Build media HTML (prefer inline streaming endpoint for big videos/gifs)
                let mediaHTML = '';
                if (msg.hasMedia) {
                    const isImage = msg.mediaMimetype?.startsWith('image/');
                    const isVideo = msg.mediaMimetype?.startsWith('video/');
                    const isAudio = msg.mediaMimetype?.startsWith('audio/');
                    const ext = (msg.mediaFilename || '').toLowerCase().split('.').pop();
                    const inferredImage = !isImage && !isVideo && !isAudio && ['jpg','jpeg','png','gif','webp','bmp'].includes(ext);
                    const inferredVideo = !isImage && !isVideo && !isAudio && ['mp4','webm','mov','mkv'].includes(ext);
                    const inferredAudio = !isImage && !isVideo && !isAudio && ['mp3','ogg','opus','wav','m4a','aac'].includes(ext);
                    const inlineUrl = msg.mediaFetchUrl ? `${WHATSAPP_API_URL}${msg.mediaFetchUrl}` : `${WHATSAPP_API_URL}/api/whatsapp/media/${msg.id}?inline=1`;
                    const downloadUrl = msg.mediaDownloadUrl ? `${WHATSAPP_API_URL}${msg.mediaDownloadUrl}` : `${WHATSAPP_API_URL}/api/whatsapp/media/${msg.id}?download=true`;
                    const src = msg.mediaUrl || inlineUrl;
                    
                    if (isImage || inferredImage) {
                        mediaHTML = `
                            <div class="whatsapp-media-container">
                                <img loading="lazy" src="${src}" alt="Image" class="whatsapp-media-image" onclick="openMediaViewer('${src}', '${msg.mediaFilename || 'image'}')" />
                                <a href="${downloadUrl}" download="${msg.mediaFilename || 'image'}" class="whatsapp-media-download" title="Download image">‚¨áÔ∏è</a>
                            </div>
                        `;
                    } else if (isVideo || inferredVideo) {
                        mediaHTML = `
                            <div class="whatsapp-media-container">
                                <video controls preload="metadata" class="whatsapp-media-video">
                                    <source src="${src}" type="${msg.mediaMimetype || 'video/mp4'}">
                                </video>
                                <a href="${downloadUrl}" download="${msg.mediaFilename || 'video'}" class="whatsapp-media-download" title="Download video">‚¨áÔ∏è</a>
                            </div>
                        `;
                    } else if (isAudio || inferredAudio) {
                        mediaHTML = `
                            <div class="whatsapp-media-container">
                                <audio controls preload="metadata" style="width: 100%;" src="${src}"></audio>
                                <a href="${downloadUrl}" download="${msg.mediaFilename || 'audio'}" class="whatsapp-media-download" title="Download audio">‚¨áÔ∏è</a>
                            </div>
                        `;
                    } else {
                        // File/document
                        const fileIcon = getFileIcon(msg.mediaMimetype);
                        mediaHTML = `
                            <div class="whatsapp-media-container whatsapp-file-container">
                                <div class="whatsapp-file-icon">${fileIcon}</div>
                                <div class="whatsapp-file-info">
                                    <div class="whatsapp-file-name">${escapeHtml(msg.mediaFilename || 'File')}</div>
                                    <div class="whatsapp-file-type">${msg.mediaMimetype || 'Unknown type'}</div>
                                </div>
                                <a href="${downloadUrl}" download="${msg.mediaFilename || 'file'}" class="whatsapp-media-download" title="Download file">‚¨áÔ∏è</a>
                            </div>
                        `;
                    }
                }

                // Build action buttons for sent messages
                let actionButtonsHTML = '';
                if (isSent) {
                    actionButtonsHTML = `
                        <div class="whatsapp-message-actions">
                            <button class="whatsapp-action-btn" onclick="editWhatsAppMessage('${msg.id}')" title="Edit message">‚úèÔ∏è</button>
                            <button class="whatsapp-action-btn" onclick="deleteWhatsAppMessage('${msg.id}')" title="Delete message">üóëÔ∏è</button>
                        </div>
                    `;
                }

                // Message bubble
                html += `
                    <div class="whatsapp-message-wrapper ${isSent ? 'sent' : 'received'}" data-message-id="${msg.id}" data-timestamp="${msg.timestamp}">
                        <div class="whatsapp-message-bubble">
                            ${mediaHTML}
                            <div class="whatsapp-message-text">${formattedBody || '<em>No content</em>'}</div>
                            <div class="whatsapp-message-footer">
                                <div class="whatsapp-message-time">${timeStr}</div>
                                ${actionButtonsHTML}
                            </div>
                        </div>
                    </div>
                `;

                return html;
            }).join('');

            whatsappMessagesContainer.innerHTML = messagesHTML;
            whatsappMessagesContainer.scrollTop = whatsappMessagesContainer.scrollHeight;
        }

        /**
         * Format WhatsApp timestamp
         */
        function formatWhatsAppTime(timestamp) {
            if (!timestamp) return '';
            const date = new Date(timestamp * 1000); // Convert from seconds to milliseconds
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);

            if (diffMins < 1) return 'now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            
            return date.toLocaleDateString('en-US', { 
                month: 'short', 
                day: 'numeric',
                year: date.getFullYear() !== now.getFullYear() ? 'numeric' : undefined
            });
        }

        /**
         * Escape HTML to prevent XSS
         */
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        async function sendWhatsAppMessage() {
            if (!currentWhatsAppChatId || !whatsappMessageInput) return;
            
            const messageText = whatsappMessageInput.value.trim();
            if (!messageText) return;
            
            if (whatsappSendButton) whatsappSendButton.disabled = true;
            
            // Clear input immediately for better UX
            whatsappMessageInput.value = '';
            
            // Create optimistic message (will be replaced by real message from WebSocket)
            const tempMessageId = 'temp_' + Date.now();
            const optimisticMessage = {
                id: tempMessageId,
                body: messageText,
                from: currentWhatsAppChatId,
                fromMe: true,
                timestamp: Math.floor(Date.now() / 1000),
                type: 'chat',
                hasMedia: false,
                contact_id: currentWhatsAppChatId,
                contact_name: currentWhatsAppContactName || 'You',
                is_group: false
            };
            
            // Display message instantly (optimistic update)
            handleIncomingWhatsAppMessage(optimisticMessage, true);
            
            try {
                console.log(`[*] Sending message to ${currentWhatsAppChatId}: ${messageText}`);
                const response = await fetch('http://localhost:3000/api/whatsapp/send', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contact_id: currentWhatsAppChatId,
                        text: messageText
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                console.log('[*] Message sent:', data);

                // Remove temporary message (real one will come via WebSocket)
                const tempElement = whatsappMessagesContainer?.querySelector(`[data-message-id="${tempMessageId}"]`);
                if (tempElement) {
                    tempElement.remove();
                }
                
                // Real message will arrive via WebSocket and display instantly
            } catch (error) {
                console.error('[!] Error sending WhatsApp message:', error);
                
                // Remove optimistic message on error
                const tempElement = whatsappMessagesContainer?.querySelector(`[data-message-id="${tempMessageId}"]`);
                if (tempElement) {
                    tempElement.remove();
                }
                
                // Restore message text
                whatsappMessageInput.value = messageText;
                
                alert(`Error sending message: ${error.message}`);
            } finally {
                if (whatsappSendButton) whatsappSendButton.disabled = false;
            }
        }

        if (whatsappSendButton) {
            whatsappSendButton.addEventListener('click', sendWhatsAppMessage);
        }
        if (whatsappMessageInput) {
            whatsappMessageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendWhatsAppMessage();
                }
            });
        }

        if (whatsappShowButton) {
            whatsappShowButton.addEventListener('click', async () => {
                const isAuth = await checkWhatsAppStatus();
                if (isAuth) {
                    await loadWhatsAppMessages();
                }
            });
        }


        // Manual QR code refresh button
        if (whatsappQrRefreshBtn) {
            whatsappQrRefreshBtn.addEventListener('click', async () => {
                whatsappQrRefreshBtn.disabled = true;
                whatsappQrRefreshBtn.textContent = 'Refreshing...';
                await loadWhatsAppQRCode(true);
                whatsappQrRefreshBtn.disabled = false;
                whatsappQrRefreshBtn.textContent = 'Refresh QR Code';
            });
        }

        // Check WhatsApp status when tab is switched (using a MutationObserver or event delegation)
        // This ensures it doesn't interfere with the main tab switching
        const handleTabSwitch = async (tabName) => {
            if (tabName === 'whatsapp') {
                console.log('[*] WhatsApp tab activated - initializing WhatsApp service...');
                
                // Initialize WebSocket connection for real-time messages
                initializeWhatsAppWebSocket();
            } else if (tabName === 'telegram') {
                console.log('[*] Telegram tab activated - initializing Telegram WebSocket...');
                
                // Initialize WebSocket connection for real-time messages
                initializeTelegramWebSocket();
                
                // Initialize WhatsApp service first (lazy initialization)
                try {
                    const initResponse = await fetch('http://localhost:3000/api/whatsapp/initialize', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        }
                    });
                    
                    if (!initResponse.ok) {
                        throw new Error(`Initialization failed: HTTP ${initResponse.status}`);
                    }
                    
                    const initData = await initResponse.json();
                    console.log('[*] WhatsApp initialization response:', initData);
                    
                    // After initialization, check status and handle QR code display
                    await checkWhatsAppStatus();
                } catch (error) {
                    console.error('[*] Error initializing WhatsApp:', error);
                    if (whatsappQrStatus) {
                        whatsappQrStatus.textContent = 'Error initializing WhatsApp. Please try again.';
                        whatsappQrStatus.style.color = '#ff4444';
                    }
                }
            } else {
                if (whatsappAuthCheckInterval) {
                    clearInterval(whatsappAuthCheckInterval);
                    whatsappAuthCheckInterval = null;
                    console.log('[*] Stopped WhatsApp authentication polling (switched to another tab)');
                }
                if (whatsappQrRefreshInterval) {
                    clearInterval(whatsappQrRefreshInterval);
                    whatsappQrRefreshInterval = null;
                    console.log('[*] Stopped WhatsApp QR code auto-refresh (switched to another tab)');
                }
            }
        };
        
        // Observe tab content changes to detect tab switches
        const tabObserver = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                    const target = mutation.target;
                    if (target.classList.contains('tab-content') && target.classList.contains('active')) {
                        const tabName = target.id;
                        handleTabSwitch(tabName);
                    }
                }
            });
        });
        
        // Observe all tab content elements
        document.querySelectorAll('.tab-content').forEach(tab => {
            tabObserver.observe(tab, { attributes: true, attributeFilter: ['class'] });
        });
        
        // Also handle initial tab state
        const activeTab = document.querySelector('.tab-content.active');
        if (activeTab) {
            handleTabSwitch(activeTab.id);
        }
        
        // Check WhatsApp status on page load if WhatsApp tab is active
        document.addEventListener('DOMContentLoaded', async () => {
            const activeTab = document.querySelector('.tab-content.active');
            if (activeTab && activeTab.id === 'whatsapp') {
                console.log('[*] WhatsApp tab is active on page load - checking status...');
                await checkWhatsAppStatus();
            }
        });
        
        // Also check immediately if DOM is already loaded
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            const activeTab = document.querySelector('.tab-content.active');
            if (activeTab && activeTab.id === 'whatsapp') {
                console.log('[*] DOM already loaded - checking WhatsApp status...');
                setTimeout(async () => {
                    await checkWhatsAppStatus();
                }, 1000); // Wait 1 second for backend to initialize
            }
        }

        // Slack functionality
        const slackShowButton = document.getElementById('slackShowButton');
        const slackChannelsList = document.getElementById('slackChannelsList');
        const slackMessagesContainer = document.getElementById('slackMessagesContainer');
        const slackCurrentChannel = document.getElementById('slackCurrentChannel');
        const slackStatus = document.getElementById('slackStatus');
        const slackMessageInput = document.getElementById('slackMessageInput');
        const slackSendButton = document.getElementById('slackSendButton');
        const slackInputContainer = document.getElementById('slackInputContainer');
        const slackEmptyState = document.getElementById('slackEmptyState');

        let slackChannels = [];
        let slackMessagesByChannel = {};
        let currentSlackChannelId = null;
        let slackSocket = null;
        let slackPollInterval = null;
        let slackLastMessageTs = {};

        function getSlackInitials(name) {
            if (!name) return '?';
            const parts = name.trim().split(' ');
            if (parts.length >= 2) {
                return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase();
            }
            return name.substring(0, 2).toUpperCase();
        }

        function getSlackAvatarColor(name) {
            if (!name) return '#3390ec';
            let hash = 0;
            for (let i = 0; i < name.length; i++) {
                hash = name.charCodeAt(i) + ((hash << 5) - hash);
            }
            const colors = [
                '#3390ec', '#4a154b', '#1264a3', '#0f5132', '#856404',
                '#721c24', '#155724', '#004085', '#383f45', '#1d1c1d'
            ];
            return colors[Math.abs(hash) % colors.length];
        }

        function formatSlackTime(timestamp) {
            if (!timestamp) return '';
            try {
                const date = new Date(timestamp);
                return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
            } catch (e) {
                return timestamp;
            }
        }

        function renderSlackChannels() {
            if (slackChannels.length === 0) {
                slackChannelsList.innerHTML = '<div class="slack-sidebar-empty">No channels found</div>';
                return;
            }

            const channelsHTML = slackChannels.map(channel => {
                const initials = getSlackInitials(channel.channel_name);
                const avatarColor = getSlackAvatarColor(channel.channel_name);
                const isActive = currentSlackChannelId === channel.channel_id;
                const preview = channel.last_message ? (channel.last_message.length > 30 ? channel.last_message.substring(0, 30) + '...' : channel.last_message) : 'No messages';
                const unreadBadge = channel.unread_count > 0 ? `<span class="slack-channel-unread">${channel.unread_count}</span>` : '';
                
                return `
                    <div class="slack-channel-item ${isActive ? 'active' : ''}" data-channel-id="${channel.channel_id}">
                        <div class="slack-channel-avatar" style="background-color: ${avatarColor}">
                            ${initials}
                        </div>
                        <div class="slack-channel-info">
                            <div class="slack-channel-name">${escapeHtml(channel.channel_name)}</div>
                            <div class="slack-channel-preview">${escapeHtml(preview)}${unreadBadge}</div>
                        </div>
                    </div>
                `;
            }).join('');

            slackChannelsList.innerHTML = channelsHTML;

            // Add click handlers
            document.querySelectorAll('.slack-channel-item').forEach(item => {
                item.addEventListener('click', () => {
                    const channelId = item.dataset.channelId;
                    selectSlackChannel(channelId);
                });
            });
        }

        async function selectSlackChannel(channelId) {
            const previousChannelId = currentSlackChannelId;
            currentSlackChannelId = channelId;
            const channel = slackChannels.find(c => c.channel_id === channelId);
            if (!channel) return;

            slackCurrentChannel.textContent = channel.channel_name;
            slackMessagesContainer.innerHTML = '<div class="slack-empty-state"><p>Loading messages...</p></div>';

            // Show input area
            if (slackInputContainer) {
                slackInputContainer.style.display = 'block';
            }

            // Update active state
            document.querySelectorAll('.slack-channel-item').forEach(item => {
                item.classList.toggle('active', item.dataset.channelId === channelId);
            });

            // Load messages for this channel (if not cached)
            if (!slackMessagesByChannel[channelId]) {
                try {
                    const response = await fetch('http://localhost:3002/api/slack/messages', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            channel_id: channelId,
                            limit: 50
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();
                    if (data.success) {
                        slackMessagesByChannel[channelId] = data.messages || [];
                    } else {
                        throw new Error(data.error || 'Failed to load messages');
                    }
                } catch (error) {
                    console.error('[Slack] Error loading messages:', error);
                    slackMessagesContainer.innerHTML = `<div class="slack-empty-state"><p>Error loading messages: ${escapeHtml(error.message)}</p></div>`;
                    return;
                }
            }

            const messages = slackMessagesByChannel[channelId] || [];
            renderSlackMessages(messages);

            // Connect WebSocket and join channel room
            connectSlackWebSocket();

            // Leave previous channel room (prevents polling / realtime for many channels at once)
            if (slackSocket && previousChannelId && previousChannelId !== channelId) {
                try {
                    slackSocket.emit('leave_channel', previousChannelId);
                    console.log(`[Slack] Left channel ${previousChannelId} via WebSocket`);
                } catch (e) {}
            }
            
            // Wait a bit for WebSocket to connect, then join channel
            setTimeout(() => {
                if (slackSocket) {
                    if (slackSocket.connected) {
                        slackSocket.emit('join_channel', channelId);
                        console.log(`[Slack] Joined channel ${channelId} via WebSocket`);
                        // Stop polling if WebSocket is connected
                        stopSlackPolling();
                    } else {
                        // WebSocket not connected yet, wait for connection
                        slackSocket.once('connect', () => {
                            slackSocket.emit('join_channel', channelId);
                            console.log(`[Slack] Joined channel ${channelId} via WebSocket (after connect)`);
                            stopSlackPolling();
                        });
                        // Start polling as fallback
                        startSlackPolling();
                    }
                } else {
                    // No WebSocket, start polling
                    startSlackPolling();
                }
            }, 500);

            // Focus input
            if (slackMessageInput) {
                slackMessageInput.focus();
            }
        }

        function renderSlackMessages(messages) {
            if (!messages || messages.length === 0) {
                slackMessagesContainer.innerHTML = '<div class="slack-empty-state"><p>No messages in this channel</p></div>';
                return;
            }

            let lastDate = null;
            let lastUserId = null;
            const messagesHTML = messages.map(msg => {
                const msgDate = new Date(msg.timestamp || Date.now());
                const currentDate = msgDate.toDateString();
                const showDateDivider = lastDate !== currentDate;
                lastDate = currentDate;

                const timeStr = formatSlackTime(msg.timestamp);
                const isSent = msg.fromMe || false;
                const showAvatar = lastUserId !== msg.from;
                lastUserId = msg.from;

                // Get user initials and color
                const userName = msg.fromName || msg.from || 'Unknown';
                const initials = getSlackInitials(userName);
                const avatarColor = getSlackAvatarColor(userName);

                let html = '';
                
                // Date divider
                if (showDateDivider) {
                    const dateStr = msgDate.toLocaleDateString('en-US', { 
                        weekday: 'long', 
                        year: 'numeric', 
                        month: 'long', 
                        day: 'numeric' 
                    });
                    html += `<div class="slack-date-divider"><span>${dateStr}</span></div>`;
                }

                // Message
                html += `
                    <div class="slack-message-wrapper ${isSent ? 'sent' : 'received'}">
                        ${showAvatar && !isSent ? `
                            <div class="slack-channel-avatar" style="background-color: ${avatarColor}; width: 36px; height: 36px; font-size: 14px;">
                                ${initials}
                            </div>
                        ` : ''}
                        <div class="slack-message-bubble" data-message-ts="${msg.id}" data-channel-id="${msg.channel_id}">
                            ${showAvatar && !isSent ? `<div class="slack-message-header"><span class="slack-username">${escapeHtml(userName)}</span></div>` : ''}
                            <div class="slack-message-text">${escapeHtml(msg.body || msg.text || '')}</div>
                            <div class="slack-message-footer">
                                <div class="slack-message-time">${timeStr}</div>
                                ${isSent ? `
                                    <div class="slack-message-actions" style="display: none;">
                                        <button class="slack-action-btn" onclick="editSlackMessage('${msg.id}', '${msg.channel_id}', '${escapeHtml((msg.body || msg.text || '').replace(/'/g, "\\'"))}')" title="Edit">‚úèÔ∏è</button>
                                        <button class="slack-action-btn" onclick="deleteSlackMessage('${msg.id}', '${msg.channel_id}')" title="Delete">üóëÔ∏è</button>
                                    </div>
                                ` : ''}
                                ${!isSent ? `
                                    <div class="slack-message-actions" style="display: none;">
                                        <button class="slack-action-btn" onclick="replyToSlackMessage('${msg.id}', '${msg.channel_id}')" title="Reply">üí¨</button>
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                    </div>
                `;

                return html;
            }).join('');

            slackMessagesContainer.innerHTML = messagesHTML;
            slackMessagesContainer.scrollTop = slackMessagesContainer.scrollHeight;

            // Track last message timestamp for polling (use the newest message, not the oldest)
            if (messages.length > 0) {
                // Messages are in chronological order (oldest first), so get the last one (newest)
                const newestMsg = messages[messages.length - 1];
                slackLastMessageTs[currentSlackChannelId] = newestMsg.id;
            }

            // Add hover handlers for message actions
            document.querySelectorAll('.slack-message-bubble').forEach(bubble => {
                bubble.addEventListener('mouseenter', () => {
                    const actions = bubble.querySelector('.slack-message-actions');
                    if (actions) actions.style.display = 'flex';
                });
                bubble.addEventListener('mouseleave', () => {
                    const actions = bubble.querySelector('.slack-message-actions');
                    if (actions) actions.style.display = 'none';
                });
            });
        }

        async function loadSlackChannels() {
            if (!slackShowButton) return;
            
            slackShowButton.disabled = true;
            slackShowButton.textContent = 'Loading...';
            slackChannels = [];
            slackMessagesByChannel = {};
            currentSlackChannelId = null;

            try {
                // Check status first
                const statusResponse = await fetch('http://localhost:3002/api/slack/status', {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' }
                });

                const statusData = await statusResponse.json();
                if (!statusData.connected) {
                    throw new Error(statusData.message || 'Not connected to Slack. Please check your token.');
                }

                // Fetch channels
                const channelsResponse = await fetch('http://localhost:3002/api/slack/channels', {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' }
                });

                if (!channelsResponse.ok) {
                    const errorData = await channelsResponse.json().catch(() => ({ error: 'Failed to load channels' }));
                    throw new Error(errorData.error || `HTTP ${channelsResponse.status}`);
                }

                const channelsData = await channelsResponse.json();
                if (channelsData.success) {
                    slackChannels = channelsData.channels || [];
                    console.log(`[Slack] Loaded ${slackChannels.length} channels`);
                    
                    renderSlackChannels();
                    
                    if (slackStatus) {
                        slackStatus.textContent = 'Connected';
                    }
                    
                    if (slackEmptyState) {
                        slackEmptyState.style.display = 'flex';
                    }

                    // Auto-select first channel if available
                    if (slackChannels.length > 0) {
                        await selectSlackChannel(slackChannels[0].channel_id);
                    }
                } else {
                    throw new Error(channelsData.error || 'Failed to load channels');
                }
            } catch (error) {
                console.error('[!] Error loading Slack channels:', error);
                if (slackChannelsList) {
                    slackChannelsList.innerHTML = `<div class="slack-sidebar-empty">Error: ${escapeHtml(error.message)}</div>`;
                }
                if (slackStatus) {
                    slackStatus.textContent = 'Error';
                }
                if (slackMessagesContainer) {
                    slackMessagesContainer.innerHTML = `<div class="slack-empty-state"><p>Error: ${escapeHtml(error.message)}</p></div>`;
                }
            } finally {
                slackShowButton.disabled = false;
                slackShowButton.textContent = 'Refresh';
            }
        }

        // Connect Slack WebSocket for real-time updates
        function connectSlackWebSocket() {
            if (slackSocket && slackSocket.connected) {
                return;
            }

            try {
                slackSocket = io('http://localhost:3002', {
                    transports: ['websocket', 'polling'],
                    reconnection: true,
                    reconnectionAttempts: Infinity,
                    reconnectionDelay: 1000,
                    timeout: 20000
                });

                slackSocket.on('connect', () => {
                    console.log('[Slack] WebSocket connected');
                    // Stop polling when WebSocket connects
                    stopSlackPolling();
                    if (currentSlackChannelId) {
                        slackSocket.emit('join_channel', currentSlackChannelId);
                    }
                });

                slackSocket.on('slack_message', (message) => {
                    console.log('[Slack] Received message via WebSocket:', message);
                    if (message.channel_id === currentSlackChannelId) {
                        if (!slackMessagesByChannel[currentSlackChannelId]) {
                            slackMessagesByChannel[currentSlackChannelId] = [];
                        }
                        // Check for duplicates before adding
                        const existingIds = new Set(slackMessagesByChannel[currentSlackChannelId].map(m => m.id));
                        if (!existingIds.has(message.id)) {
                            slackMessagesByChannel[currentSlackChannelId].push(message);
                            // Update last message timestamp
                            slackLastMessageTs[currentSlackChannelId] = message.id;
                            console.log(`[Slack] Added new message to channel ${currentSlackChannelId}, total: ${slackMessagesByChannel[currentSlackChannelId].length}`);
                            renderSlackMessages(slackMessagesByChannel[currentSlackChannelId]);
                        } else {
                            console.log(`[Slack] Duplicate message ignored: ${message.id}`);
                        }
                    } else {
                        console.log(`[Slack] Message for different channel (${message.channel_id} vs ${currentSlackChannelId})`);
                    }
                });

                slackSocket.on('slack_message_updated', (message) => {
                    if (message.channel_id === currentSlackChannelId) {
                        const messages = slackMessagesByChannel[currentSlackChannelId] || [];
                        const index = messages.findIndex(m => m.id === message.id);
                        if (index !== -1) {
                            messages[index] = message;
                            renderSlackMessages(messages);
                        }
                    }
                });

                slackSocket.on('slack_message_deleted', (data) => {
                    if (data.channel_id === currentSlackChannelId) {
                        const messages = slackMessagesByChannel[currentSlackChannelId] || [];
                        slackMessagesByChannel[currentSlackChannelId] = messages.filter(m => m.id !== data.message_ts);
                        renderSlackMessages(slackMessagesByChannel[currentSlackChannelId]);
                    }
                });

                slackSocket.on('disconnect', () => {
                    console.log('[Slack] WebSocket disconnected');
                    // Start polling as fallback when WebSocket disconnects
                    if (currentSlackChannelId) {
                        startSlackPolling();
                    }
                });

                slackSocket.on('connect_error', (error) => {
                    console.log('[Slack] WebSocket connection error:', error.message);
                });
            } catch (error) {
                console.error('[Slack] Error connecting WebSocket:', error);
            }
        }

        // Stop polling function
        function stopSlackPolling() {
            if (slackPollInterval) {
                clearInterval(slackPollInterval);
                slackPollInterval = null;
            }
        }

        // Polling fallback for real-time updates (only when WebSocket is not connected)
        function startSlackPolling() {
            // Don't poll if WebSocket is connected
            if (slackSocket && slackSocket.connected) {
                return;
            }

            // Clear any existing polling
            stopSlackPolling();

            slackPollInterval = setInterval(async () => {
                // Stop polling if WebSocket connects
                if (slackSocket && slackSocket.connected) {
                    stopSlackPolling();
                    return;
                }

                if (!currentSlackChannelId) return;

                try {
                    const lastTs = slackLastMessageTs[currentSlackChannelId];
                    const response = await fetch('http://localhost:3002/api/slack/poll', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            channel_id: currentSlackChannelId,
                            last_message_ts: lastTs
                        })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        if (data.success && data.messages && data.messages.length > 0) {
                            if (!slackMessagesByChannel[currentSlackChannelId]) {
                                slackMessagesByChannel[currentSlackChannelId] = [];
                            }
                            
                            // Check for duplicates before adding
                            const existingIds = new Set(slackMessagesByChannel[currentSlackChannelId].map(m => m.id));
                            const newMessages = data.messages.filter(m => !existingIds.has(m.id));
                            
                            if (newMessages.length > 0) {
                                slackMessagesByChannel[currentSlackChannelId].push(...newMessages);
                                // Update last message timestamp
                                const newestMsg = newMessages[newMessages.length - 1];
                                slackLastMessageTs[currentSlackChannelId] = newestMsg.id;
                                renderSlackMessages(slackMessagesByChannel[currentSlackChannelId]);
                            }
                        }
                    }
                } catch (error) {
                    // Silently fail - polling will retry
                }
            }, 5000); // Poll every 5 seconds (reduced frequency)
        }

        // Edit message function
        window.editSlackMessage = async function(messageTs, channelId, currentText) {
            const newText = prompt('Edit message:', currentText);
            if (!newText || newText === currentText) return;

            try {
                const response = await fetch('http://localhost:3002/api/slack/edit', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        channel_id: channelId,
                        message_ts: messageTs,
                        text: newText
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    if (data.success) {
                        // Reload messages to show updated message
                        delete slackMessagesByChannel[channelId];
                        await selectSlackChannel(channelId);
                    }
                } else {
                    const errorData = await response.json().catch(() => ({ error: 'Failed to edit message' }));
                    alert(`Error: ${errorData.error}`);
                }
            } catch (error) {
                alert(`Error editing message: ${error.message}`);
            }
        };

        // Delete message function
        window.deleteSlackMessage = async function(messageTs, channelId) {
            if (!confirm('Are you sure you want to delete this message?')) return;

            try {
                const response = await fetch('http://localhost:3002/api/slack/delete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        channel_id: channelId,
                        message_ts: messageTs
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    if (data.success) {
                        // Remove from local cache
                        const messages = slackMessagesByChannel[channelId] || [];
                        slackMessagesByChannel[channelId] = messages.filter(m => m.id !== messageTs);
                        renderSlackMessages(slackMessagesByChannel[channelId]);
                    }
                } else {
                    const errorData = await response.json().catch(() => ({ error: 'Failed to delete message' }));
                    alert(`Error: ${errorData.error}`);
                }
            } catch (error) {
                alert(`Error deleting message: ${error.message}`);
            }
        };

        // Reply to message function
        window.replyToSlackMessage = function(messageTs, channelId) {
            if (slackMessageInput) {
                slackMessageInput.value = `Replying to message... `;
                slackMessageInput.focus();
                slackMessageInput.setSelectionRange(slackMessageInput.value.length, slackMessageInput.value.length);
                
                // Store thread_ts for sending
                slackMessageInput.dataset.threadTs = messageTs;
            }
        };

        if (slackShowButton) {
            slackShowButton.addEventListener('click', loadSlackChannels);
        }

        if (slackMessageInput && slackSendButton) {
            slackMessageInput.addEventListener('input', () => {
                slackSendButton.disabled = !slackMessageInput.value.trim() || !currentSlackChannelId;
            });

            slackMessageInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    if (!slackSendButton.disabled) {
                        slackSendButton.click();
                    }
                }
            });

            slackSendButton.addEventListener('click', sendSlackMessage);
        }

        // Word Document Management
        const createWordDocButton = document.getElementById('createWordDocButton');
        const openWordDocButton = document.getElementById('openWordDocButton');
        const wordCreateModal = document.getElementById('wordCreateModal');
        const wordOpenModal = document.getElementById('wordOpenModal');
        const wordCreateModalClose = document.getElementById('wordCreateModalClose');
        const wordOpenModalClose = document.getElementById('wordOpenModalClose');
        const wordCreateCancel = document.getElementById('wordCreateCancel');
        const wordOpenCancel = document.getElementById('wordOpenCancel');
        const wordCreateSubmit = document.getElementById('wordCreateSubmit');
        const wordOpenSubmit = document.getElementById('wordOpenSubmit');
        const wordDocumentArea = document.getElementById('wordDocumentArea');
        const wordFilePathBrowse = document.getElementById('wordFilePathBrowse');
        const wordFilePathInput = document.getElementById('wordFilePathInput');
        const wordOpenFilePathBrowse = document.getElementById('wordOpenFilePathBrowse');
        const wordOpenFilePathInput = document.getElementById('wordOpenFilePathInput');

        // Browse button for opening documents - use native file picker
        if (wordOpenFilePathBrowse && wordOpenFilePathInput) {
            wordOpenFilePathBrowse.addEventListener('click', async () => {
                try {
                    const filePathInput = document.getElementById('wordOpenFilePath');
                    if (!filePathInput) return;
                    
                    // Get initial directory
                    const defaultPath = await getDefaultDocumentsPath();
                    const initialDir = filePathInput.value.trim() ? 
                        filePathInput.value.substring(0, filePathInput.value.lastIndexOf('\\')) : 
                        defaultPath;
                    
                    // Call backend to open native file picker
                    const response = await fetch(`http://localhost:8000/api/word/select-file?initial_path=${encodeURIComponent(initialDir)}`);
                    
                    if (!response.ok) {
                        throw new Error(`Failed to open file picker: ${response.status}`);
                    }
                    
                    const result = await response.json();
                    
                    if (result.success && result.file_path) {
                        filePathInput.value = result.file_path;
                        console.log('File selected:', result.file_path);
                    } else if (!result.cancelled) {
                        // Only show error if not cancelled by user
                        const errorMsg = result.error || 'Failed to select file';
                        console.error('File picker error:', errorMsg);
                        alert(`Error selecting file: ${errorMsg}`);
                    }
                } catch (error) {
                    console.error('Error opening file picker:', error);
                    alert(`Error opening file picker: ${error.message}`);
                }
            });
        }
        
        // Helper function to get default Documents path
        async function getDefaultDocumentsPath() {
            try {
                const response = await fetch('http://localhost:8000/api/word/list-directory');
                const data = await response.json();
                if (data.success && data.path) {
                    return data.path;
                }
            } catch (error) {
                console.error('Error getting default path:', error);
            }
            // Fallback to D: drive instead of C: drive
            return 'D:\\Documents';
        }

        // Browse button for creating documents
        if (wordFilePathBrowse && wordFilePathInput) {
            wordFilePathBrowse.addEventListener('click', async () => {
                const filePathInput = document.getElementById('wordFilePath');
                if (filePathInput) {
                    if (!filePathInput.value.trim()) {
                        // Get default Documents path from server
                        const defaultPath = await getDefaultDocumentsPath();
                        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
                        const suggestedPath = `${defaultPath}\\document_${timestamp}.docx`;
                        filePathInput.value = suggestedPath;
                    }
                    filePathInput.focus();
                    filePathInput.select();
                }
            });
        }

        // Store current document state
        let currentWordDocument = {
            filePath: null,
            title: null,
            content: ''
        };

        // Function to open Word editor
        function openWordEditor(filePath, title, initialContent) {
            currentWordDocument.filePath = filePath;
            currentWordDocument.title = title;
            currentWordDocument.content = initialContent;
            
            // Convert plain text content to HTML
            // Replace newlines with <div> tags for proper paragraph display
            let htmlContent = '';
            if (initialContent) {
                // Escape HTML special characters to prevent injection
                const escapeHtml = (text) => {
                    const div = document.createElement('div');
                    div.textContent = text;
                    return div.innerHTML;
                };
                
                // Split by newlines and wrap each line in a div
                const lines = initialContent.split('\n');
                htmlContent = lines.map(line => {
                    const escapedLine = escapeHtml(line);
                    // Use <br> for empty lines to preserve them
                    return `<div>${escapedLine || '<br>'}</div>`;
                }).join('');
            }
            
            if (wordDocumentArea) {
                const fileName = filePath.split('\\').pop() || filePath.split('/').pop() || 'Document';
                wordDocumentArea.innerHTML = `
                    <div class="word-editor-container">
                        <div class="word-editor-toolbar">
                            <!-- File Operations -->
                            <div class="word-editor-toolbar-group">
                                <button class="word-editor-btn" id="wordEditorNew" title="New Document">üìÑ New</button>
                                <button class="word-editor-btn" id="wordEditorOpen" title="Open Document">üìÇ Open</button>
                                <button class="word-editor-btn word-editor-btn-primary" id="wordEditorSave" title="Save (Ctrl+S)">üíæ Save</button>
                            </div>
                            
                            <!-- Text Formatting -->
                            <div class="word-editor-toolbar-group">
                                <button class="word-editor-btn" id="wordEditorBold" title="Bold (Ctrl+B)"><strong>B</strong></button>
                                <button class="word-editor-btn" id="wordEditorItalic" title="Italic (Ctrl+I)"><em>I</em></button>
                                <button class="word-editor-btn" id="wordEditorUnderline" title="Underline (Ctrl+U)"><u>U</u></button>
                                <button class="word-editor-btn" id="wordEditorStrikethrough" title="Strikethrough"><s>S</s></button>
                                <button class="word-editor-btn" id="wordEditorSubscript" title="Subscript">x‚ÇÇ</button>
                                <button class="word-editor-btn" id="wordEditorSuperscript" title="Superscript">x¬≤</button>
                            </div>
                            
                            <!-- Font Controls -->
                            <div class="word-editor-toolbar-group">
                                <select class="word-editor-select" id="wordEditorFontSize" title="Font Size">
                                    <option value="8">8</option>
                                    <option value="9">9</option>
                                    <option value="10">10</option>
                                    <option value="11">11</option>
                                    <option value="12" selected>12</option>
                                    <option value="14">14</option>
                                    <option value="16">16</option>
                                    <option value="18">18</option>
                                    <option value="20">20</option>
                                    <option value="24">24</option>
                                    <option value="28">28</option>
                                    <option value="36">36</option>
                                    <option value="48">48</option>
                                    <option value="72">72</option>
                                </select>
                                <select class="word-editor-select" id="wordEditorFontFamily" title="Font Family">
                                    <option value="Arial">Arial</option>
                                    <option value="Times New Roman">Times New Roman</option>
                                    <option value="Calibri" selected>Calibri</option>
                                    <option value="Courier New">Courier New</option>
                                    <option value="Verdana">Verdana</option>
                                    <option value="Georgia">Georgia</option>
                                    <option value="Comic Sans MS">Comic Sans MS</option>
                                    <option value="Impact">Impact</option>
                                    <option value="Trebuchet MS">Trebuchet MS</option>
                                    <option value="Tahoma">Tahoma</option>
                                </select>
                                <input type="color" id="wordEditorTextColor" title="Text Color" value="#000000" style="width: 40px; height: 28px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                                <button class="word-editor-btn" id="wordEditorHighlight" title="Highlight">üñçÔ∏è</button>
                            </div>
                            
                            <!-- Paragraph Formatting -->
                            <div class="word-editor-toolbar-group">
                                <button class="word-editor-btn" id="wordEditorAlignLeft" title="Align Left">‚¨Ö</button>
                                <button class="word-editor-btn" id="wordEditorAlignCenter" title="Align Center">‚¨å</button>
                                <button class="word-editor-btn" id="wordEditorAlignRight" title="Align Right">‚û°</button>
                                <button class="word-editor-btn" id="wordEditorAlignJustify" title="Justify">‚¨å‚¨å</button>
                                <button class="word-editor-btn" id="wordEditorBullets" title="Bullets">‚Ä¢ List</button>
                                <button class="word-editor-btn" id="wordEditorNumbering" title="Numbering">1. List</button>
                                <button class="word-editor-btn" id="wordEditorIndentDecrease" title="Decrease Indent">‚´∏</button>
                                <button class="word-editor-btn" id="wordEditorIndentIncrease" title="Increase Indent">‚´∑</button>
                            </div>
                            
                            <!-- Insert Options -->
                            <div class="word-editor-toolbar-group">
                                <button class="word-editor-btn" id="wordEditorInsertImage" title="Insert Image">üñºÔ∏è Image</button>
                                <button class="word-editor-btn" id="wordEditorInsertLink" title="Insert Hyperlink">üîó Link</button>
                                <button class="word-editor-btn" id="wordEditorInsertPageBreak" title="Page Break">üìÑ Page</button>
                            </div>
                            
                            <!-- Headings -->
                            <div class="word-editor-toolbar-group">
                                <select class="word-editor-select" id="wordEditorHeading" title="Heading Style" style="width: 120px;">
                                    <option value="">Normal</option>
                                    <option value="h1">Heading 1</option>
                                    <option value="h2">Heading 2</option>
                                    <option value="h3">Heading 3</option>
                                    <option value="h4">Heading 4</option>
                                    <option value="h5">Heading 5</option>
                                    <option value="h6">Heading 6</option>
                                </select>
                            </div>
                            
                            <!-- Document Tools -->
                            <div class="word-editor-toolbar-group">
                                <button class="word-editor-btn" id="wordEditorFindReplace" title="Find & Replace">üîç Find</button>
                                <button class="word-editor-btn" id="wordEditorWordCount" title="Word Count">üìä Count</button>
                                <button class="word-editor-btn" id="wordEditorPageSetup" title="Page Setup">üìê Setup</button>
                            </div>
                        </div>
                        <div class="word-editor-header">
                            <div class="word-editor-title">
                                <span style="font-weight: 600;">üìÑ ${fileName}</span>
                                <span style="font-size: 12px; color: #666; margin-left: 12px;">${filePath}</span>
                            </div>
                        </div>
                        <div class="word-editor-content-wrapper">
                            <div 
                                class="word-editor-content" 
                                id="wordEditorContent" 
                                contenteditable="true"
                                style="min-height: 500px; padding: 20px; background: white; border: 1px solid #ddd; border-radius: 4px; outline: none; font-family: 'Calibri', 'Arial', sans-serif; font-size: 12pt; line-height: 1.5;"
                            >${htmlContent || '<div><br></div>'}</div>
                        </div>
                    </div>
                `;
                
                // Set up editor event listeners
                setupWordEditor();
            }
        }

        // Function to set up Word editor event listeners
        function setupWordEditor() {
            const editorContent = document.getElementById('wordEditorContent');
            const saveBtn = document.getElementById('wordEditorSave');
            const boldBtn = document.getElementById('wordEditorBold');
            const italicBtn = document.getElementById('wordEditorItalic');
            const underlineBtn = document.getElementById('wordEditorUnderline');
            const alignLeftBtn = document.getElementById('wordEditorAlignLeft');
            const alignCenterBtn = document.getElementById('wordEditorAlignCenter');
            const alignRightBtn = document.getElementById('wordEditorAlignRight');
            const fontSizeSelect = document.getElementById('wordEditorFontSize');
            const fontFamilySelect = document.getElementById('wordEditorFontFamily');

            // Save functionality - show Save As dialog
            // NOTE: No auto-save functionality. Files are only saved when user explicitly:
            // 1. Clicks the Save button, or
            // 2. Presses Ctrl+S while editor is focused
            if (saveBtn && editorContent) {
                saveBtn.addEventListener('click', () => {
                    showSaveAsDialog();
                });
            }

            // Format buttons
            if (boldBtn && editorContent) {
                boldBtn.addEventListener('click', () => {
                    document.execCommand('bold', false, null);
                    editorContent.focus();
                });
            }

            if (italicBtn && editorContent) {
                italicBtn.addEventListener('click', () => {
                    document.execCommand('italic', false, null);
                    editorContent.focus();
                });
            }

            if (underlineBtn && editorContent) {
                underlineBtn.addEventListener('click', () => {
                    document.execCommand('underline', false, null);
                    editorContent.focus();
                });
            }

            // Alignment buttons
            if (alignLeftBtn && editorContent) {
                alignLeftBtn.addEventListener('click', () => {
                    document.execCommand('justifyLeft', false, null);
                    editorContent.focus();
                });
            }

            if (alignCenterBtn && editorContent) {
                alignCenterBtn.addEventListener('click', () => {
                    document.execCommand('justifyCenter', false, null);
                    editorContent.focus();
                });
            }

            if (alignRightBtn && editorContent) {
                alignRightBtn.addEventListener('click', () => {
                    document.execCommand('justifyRight', false, null);
                    editorContent.focus();
                });
            }

            // Font size
            if (fontSizeSelect && editorContent) {
                fontSizeSelect.addEventListener('change', (e) => {
                    document.execCommand('fontSize', false, e.target.value);
                    editorContent.focus();
                });
            }

            // Font family
            if (fontFamilySelect && editorContent) {
                fontFamilySelect.addEventListener('change', (e) => {
                    document.execCommand('fontName', false, e.target.value);
                    editorContent.focus();
                });
            }

            // Additional formatting buttons
            const strikethroughBtn = document.getElementById('wordEditorStrikethrough');
            const subscriptBtn = document.getElementById('wordEditorSubscript');
            const superscriptBtn = document.getElementById('wordEditorSuperscript');
            const textColorInput = document.getElementById('wordEditorTextColor');
            const highlightBtn = document.getElementById('wordEditorHighlight');
            const alignJustifyBtn = document.getElementById('wordEditorAlignJustify');
            const bulletsBtn = document.getElementById('wordEditorBullets');
            const numberingBtn = document.getElementById('wordEditorNumbering');
            const indentDecreaseBtn = document.getElementById('wordEditorIndentDecrease');
            const indentIncreaseBtn = document.getElementById('wordEditorIndentIncrease');
            const headingSelect = document.getElementById('wordEditorHeading');
            const insertImageBtn = document.getElementById('wordEditorInsertImage');
            const insertLinkBtn = document.getElementById('wordEditorInsertLink');
            const insertPageBreakBtn = document.getElementById('wordEditorInsertPageBreak');
            const findReplaceBtn = document.getElementById('wordEditorFindReplace');
            const wordCountBtn = document.getElementById('wordEditorWordCount');
            const pageSetupBtn = document.getElementById('wordEditorPageSetup');
            const newDocBtn = document.getElementById('wordEditorNew');
            const openDocBtn = document.getElementById('wordEditorOpen');

            // Strikethrough
            if (strikethroughBtn && editorContent) {
                strikethroughBtn.addEventListener('click', () => {
                    document.execCommand('strikeThrough', false, null);
                    editorContent.focus();
                });
            }

            // Subscript
            if (subscriptBtn && editorContent) {
                subscriptBtn.addEventListener('click', () => {
                    document.execCommand('subscript', false, null);
                    editorContent.focus();
                });
            }

            // Superscript
            if (superscriptBtn && editorContent) {
                superscriptBtn.addEventListener('click', () => {
                    document.execCommand('superscript', false, null);
                    editorContent.focus();
                });
            }

            // Text color
            if (textColorInput && editorContent) {
                textColorInput.addEventListener('change', (e) => {
                    document.execCommand('foreColor', false, e.target.value);
                    editorContent.focus();
                });
            }

            // Highlight
            if (highlightBtn && editorContent) {
                highlightBtn.addEventListener('click', () => {
                    const color = prompt('Enter highlight color (e.g., yellow, #FFFF00):', 'yellow');
                    if (color) {
                        document.execCommand('backColor', false, color);
                    }
                    editorContent.focus();
                });
            }

            // Justify alignment
            if (alignJustifyBtn && editorContent) {
                alignJustifyBtn.addEventListener('click', () => {
                    document.execCommand('justifyFull', false, null);
                    editorContent.focus();
                });
            }

            // Bullets
            if (bulletsBtn && editorContent) {
                bulletsBtn.addEventListener('click', () => {
                    document.execCommand('insertUnorderedList', false, null);
                    editorContent.focus();
                });
            }

            // Numbering
            if (numberingBtn && editorContent) {
                numberingBtn.addEventListener('click', () => {
                    document.execCommand('insertOrderedList', false, null);
                    editorContent.focus();
                });
            }

            // Indent decrease
            if (indentDecreaseBtn && editorContent) {
                indentDecreaseBtn.addEventListener('click', () => {
                    document.execCommand('outdent', false, null);
                    editorContent.focus();
                });
            }

            // Indent increase
            if (indentIncreaseBtn && editorContent) {
                indentIncreaseBtn.addEventListener('click', () => {
                    document.execCommand('indent', false, null);
                    editorContent.focus();
                });
            }

            // Heading style
            if (headingSelect && editorContent) {
                headingSelect.addEventListener('change', (e) => {
                    const heading = e.target.value;
                    if (heading) {
                        document.execCommand('formatBlock', false, `<${heading}>`);
                    } else {
                        document.execCommand('formatBlock', false, '<p>');
                    }
                    editorContent.focus();
                });
            }

            // Insert image
            if (insertImageBtn && editorContent) {
                insertImageBtn.addEventListener('click', () => {
                    const url = prompt('Enter image URL:', '');
                    if (url) {
                        const img = document.createElement('img');
                        img.src = url;
                        img.style.maxWidth = '100%';
                        img.style.height = 'auto';
                        const selection = window.getSelection();
                        if (selection.rangeCount > 0) {
                            selection.getRangeAt(0).insertNode(img);
                        } else {
                            editorContent.appendChild(img);
                        }
                        editorContent.focus();
                    }
                });
            }

            // Insert hyperlink
            if (insertLinkBtn && editorContent) {
                insertLinkBtn.addEventListener('click', () => {
                    const url = prompt('Enter URL:', 'https://');
                    const text = prompt('Enter link text:', '');
                    if (url && text) {
                        const link = document.createElement('a');
                        link.href = url;
                        link.textContent = text;
                        link.target = '_blank';
                        const selection = window.getSelection();
                        if (selection.rangeCount > 0) {
                            selection.getRangeAt(0).insertNode(link);
                        } else {
                            editorContent.appendChild(link);
                        }
                        editorContent.focus();
                    }
                });
            }

            // Insert page break
            if (insertPageBreakBtn && editorContent) {
                insertPageBreakBtn.addEventListener('click', () => {
                    const pageBreak = document.createElement('div');
                    pageBreak.style.pageBreakAfter = 'always';
                    pageBreak.style.borderTop = '2px dashed #ccc';
                    pageBreak.style.margin = '20px 0';
                    pageBreak.innerHTML = '<br>';
                    const selection = window.getSelection();
                    if (selection.rangeCount > 0) {
                        selection.getRangeAt(0).insertNode(pageBreak);
                    } else {
                        editorContent.appendChild(pageBreak);
                    }
                    editorContent.focus();
                });
            }

            // Find & Replace
            if (findReplaceBtn && editorContent) {
                findReplaceBtn.addEventListener('click', () => {
                    const find = prompt('Find:', '');
                    if (find) {
                        const replace = prompt('Replace with:', '');
                        const content = editorContent.innerHTML;
                        editorContent.innerHTML = content.replace(new RegExp(find, 'gi'), replace || '');
                        editorContent.focus();
                    }
                });
            }

            // Word count
            if (wordCountBtn && editorContent) {
                wordCountBtn.addEventListener('click', () => {
                    const text = editorContent.innerText || editorContent.textContent || '';
                    const words = text.trim().split(/\s+/).filter(w => w.length > 0);
                    const chars = text.length;
                    const charsNoSpaces = text.replace(/\s/g, '').length;
                    alert(`Word Count:\n\nWords: ${words.length}\nCharacters (with spaces): ${chars}\nCharacters (no spaces): ${charsNoSpaces}`);
                });
            }

            // Page setup
            if (pageSetupBtn && editorContent) {
                pageSetupBtn.addEventListener('click', () => {
                    alert('Page Setup:\n\nThis feature will be implemented with backend API integration.\n\nYou can configure:\n- Page size (A4, Letter, etc.)\n- Margins\n- Orientation (Portrait/Landscape)');
                });
            }

            // New document
            if (newDocBtn) {
                newDocBtn.addEventListener('click', async () => {
                    if (confirm('Create a new document? Unsaved changes will be lost.')) {
                        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
                        const defaultPath = await getDefaultDocumentsPath();
                        const filePath = `${defaultPath}\\document_${timestamp}.docx`;
                        openWordEditor(filePath, 'New Document', '');
                    }
                });
            }

            // Open document
            if (openDocBtn) {
                openDocBtn.addEventListener('click', () => {
                    const wordOpenModal = document.getElementById('wordOpenModal');
                    if (wordOpenModal) {
                        wordOpenModal.style.display = 'flex';
                    }
                });
            }

            // Keyboard shortcuts
            if (editorContent) {
                editorContent.addEventListener('keydown', (e) => {
                    // Ctrl+S to save (only when editor has focus and user explicitly presses Ctrl+S)
                    if (e.ctrlKey && e.key === 's' && document.activeElement === editorContent) {
                        e.preventDefault();
                        e.stopPropagation();
                        showSaveAsDialog();
                    }
                    // Ctrl+B for bold
                    if (e.ctrlKey && e.key === 'b') {
                        e.preventDefault();
                        document.execCommand('bold', false, null);
                    }
                    // Ctrl+I for italic
                    if (e.ctrlKey && e.key === 'i') {
                        e.preventDefault();
                        document.execCommand('italic', false, null);
                    }
                    // Ctrl+U for underline
                    if (e.ctrlKey && e.key === 'u') {
                        e.preventDefault();
                        document.execCommand('underline', false, null);
                    }
                });
            }
        }

        // Function to show Save As dialog
        async function showSaveAsDialog() {
            const saveAsModal = document.getElementById('wordSaveAsModal');
            const saveAsFolderPath = document.getElementById('wordSaveAsFolderPath');
            const saveAsFileName = document.getElementById('wordSaveAsFileName');
            
            if (saveAsModal && saveAsFolderPath && saveAsFileName) {
                // Pre-fill with current file path if available
                if (currentWordDocument.filePath) {
                    const fullPath = currentWordDocument.filePath;
                    const lastSeparator = Math.max(fullPath.lastIndexOf('\\'), fullPath.lastIndexOf('/'));
                    if (lastSeparator > 0) {
                        saveAsFolderPath.value = fullPath.substring(0, lastSeparator);
                        saveAsFileName.value = fullPath.substring(lastSeparator + 1);
                    } else {
                        saveAsFolderPath.value = '';
                        saveAsFileName.value = fullPath;
                    }
                } else {
                    // Generate default path
                    try {
                        const defaultPath = await getDefaultDocumentsPath();
                        saveAsFolderPath.value = defaultPath;
                        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
                        saveAsFileName.value = `document_${timestamp}.docx`;
                    } catch (error) {
                        console.error('Error getting default path:', error);
                        // Fallback
                        saveAsFolderPath.value = 'D:\\Documents';
                        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
                        saveAsFileName.value = `document_${timestamp}.docx`;
                    }
                }
                saveAsModal.style.display = 'flex';
                // Small delay to ensure modal is visible before focusing
                setTimeout(() => {
                    saveAsFileName.focus();
                    saveAsFileName.select();
                }, 100);
            }
        }

        // Set up Save As dialog event listeners
        const wordSaveAsModal = document.getElementById('wordSaveAsModal');
        const wordSaveAsModalClose = document.getElementById('wordSaveAsModalClose');
        const wordSaveAsCancel = document.getElementById('wordSaveAsCancel');
        const wordSaveAsSubmit = document.getElementById('wordSaveAsSubmit');
        const wordSaveAsFolderPath = document.getElementById('wordSaveAsFolderPath');
        const wordSaveAsFileName = document.getElementById('wordSaveAsFileName');
        const wordSaveAsFolderPathBrowse = document.getElementById('wordSaveAsFolderPathBrowse');

        // Close Save As modal
        if (wordSaveAsModalClose) {
            wordSaveAsModalClose.addEventListener('click', () => {
                if (wordSaveAsModal) wordSaveAsModal.style.display = 'none';
            });
        }

        if (wordSaveAsCancel) {
            wordSaveAsCancel.addEventListener('click', () => {
                if (wordSaveAsModal) wordSaveAsModal.style.display = 'none';
            });
        }

        // Folder browser state
        let currentFolderBrowserPath = null;
        let selectedFolderPath = null;

        // Browse button for Save As - use native Windows folder picker
        if (wordSaveAsFolderPathBrowse) {
            wordSaveAsFolderPathBrowse.addEventListener('click', async () => {
                await openNativeFolderPicker();
            });
        }

        // Function to open native Windows folder picker via backend
        async function openNativeFolderPicker() {
            const currentPath = wordSaveAsFolderPath?.value.trim() || null;
            
            try {
                const url = currentPath ? 
                    `http://localhost:8000/api/word/select-folder?initial_path=${encodeURIComponent(currentPath)}` :
                    'http://localhost:8000/api/word/select-folder';
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.success && data.folder_path) {
                    // User selected a folder
                    if (wordSaveAsFolderPath) {
                        wordSaveAsFolderPath.value = data.folder_path;
                    }
                } else if (data.cancelled) {
                    // User cancelled - do nothing
                    console.log('Folder selection cancelled');
                } else {
                    // Error occurred
                    alert('Error selecting folder: ' + (data.detail || data.message || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error opening folder picker:', error);
                alert('Error opening folder picker: ' + error.message + '\n\nFalling back to manual entry.');
                // Fallback: focus the input so user can type manually
                if (wordSaveAsFolderPath) {
                    wordSaveAsFolderPath.focus();
                }
            }
        }

        // Function to open folder browser dialog
        async function openFolderBrowserDialog() {
            const folderBrowserDialog = document.getElementById('wordFolderBrowserDialog');
            if (!folderBrowserDialog) return;

            // Get initial path from input or use default
            let initialPath = wordSaveAsFolderPath?.value.trim();
            if (!initialPath) {
                try {
                    initialPath = await getDefaultDocumentsPath();
                } catch (error) {
                    initialPath = 'D:\\Documents';
                }
            }

            currentFolderBrowserPath = initialPath;
            selectedFolderPath = initialPath;
            folderBrowserDialog.style.display = 'flex';
            loadFolderBrowserDirectory(initialPath);
        }

        // Function to load directory in folder browser
        async function loadFolderBrowserDirectory(path = null) {
            const folderBrowserContent = document.getElementById('wordFolderBrowserContent');
            const folderBrowserPathBreadcrumb = document.getElementById('wordFolderBrowserPathBreadcrumb');
            
            if (!folderBrowserContent) return;

            try {
                const url = path ? 
                    `http://localhost:8000/api/word/list-directory?path=${encodeURIComponent(path)}` :
                    'http://localhost:8000/api/word/list-directory';
                
                const response = await fetch(url);
                const data = await response.json();

                if (data.success) {
                    currentFolderBrowserPath = data.path;
                    selectedFolderPath = data.path;
                    updateFolderBrowserPathBreadcrumb(data.path);
                    
                    // Clear and populate content - only show directories
                    folderBrowserContent.innerHTML = '';

                    // Add parent directory row if available
                    if (data.parent_path) {
                        const parentRow = document.createElement('div');
                        parentRow.style.cssText = 'display: flex; align-items: center; gap: 8px; padding: 8px 16px; cursor: pointer; border-bottom: 1px solid #f0f0f0; transition: background 0.15s;';
                        parentRow.innerHTML = `
                            <span style="font-size: 20px;">üìÅ</span>
                            <span style="font-size: 14px; color: #333; font-weight: 500;">.. (Parent Folder)</span>
                        `;
                        parentRow.addEventListener('click', () => {
                            loadFolderBrowserDirectory(data.parent_path);
                        });
                        parentRow.addEventListener('mouseenter', () => {
                            parentRow.style.background = '#e8f4f8';
                        });
                        parentRow.addEventListener('mouseleave', () => {
                            parentRow.style.background = 'transparent';
                        });
                        folderBrowserContent.appendChild(parentRow);
                    }

                    // Add directories only
                    const directories = data.items.filter(item => item.is_directory);
                    directories.forEach(item => {
                        const row = createFolderBrowserRow(item, data.path);
                        folderBrowserContent.appendChild(row);
                    });

                    // Update navigation buttons
                    const navUpBtn = document.getElementById('wordFolderBrowserNavUp');
                    if (navUpBtn) {
                        navUpBtn.disabled = !data.parent_path;
                        navUpBtn.style.opacity = !data.parent_path ? '0.5' : '1';
                    }
                } else {
                    const errorMsg = data.detail || data.message || data.error || 'Unknown error';
                    folderBrowserContent.innerHTML = `
                        <div style="padding: 40px; text-align: center; color: #d32f2f;">
                            <div style="font-size: 48px; margin-bottom: 16px;">‚ö†Ô∏è</div>
                            <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">Error Loading Directory</div>
                            <div style="font-size: 14px; color: #666;">${errorMsg}</div>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('Error loading directory:', error);
                folderBrowserContent.innerHTML = `
                    <div style="padding: 40px; text-align: center; color: #d32f2f;">
                        <div style="font-size: 48px; margin-bottom: 16px;">‚ö†Ô∏è</div>
                        <div style="font-size: 16px; font-weight: 600; margin-bottom: 8px;">Network Error</div>
                        <div style="font-size: 14px; color: #666;">${error.message || 'Failed to connect to server'}</div>
                    </div>
                `;
            }
        }

        // Create a folder row for the folder browser
        function createFolderBrowserRow(item, currentPath) {
            const row = document.createElement('div');
            row.style.cssText = 'display: flex; align-items: center; gap: 8px; padding: 8px 16px; cursor: pointer; border-bottom: 1px solid #f0f0f0; transition: background 0.15s;';
            
            row.innerHTML = `
                <span style="font-size: 20px;">üìÅ</span>
                <span style="font-size: 14px; color: #333;" title="${item.path}">${item.name}</span>
            `;

            row.addEventListener('click', () => {
                // Navigate into the folder
                loadFolderBrowserDirectory(item.path);
            });

            row.addEventListener('dblclick', () => {
                // Double-click to select and use this folder
                selectedFolderPath = item.path;
                if (wordSaveAsFolderPath) {
                    wordSaveAsFolderPath.value = item.path;
                }
                const folderBrowserDialog = document.getElementById('wordFolderBrowserDialog');
                if (folderBrowserDialog) folderBrowserDialog.style.display = 'none';
            });

            row.addEventListener('mouseenter', () => {
                row.style.background = '#e8f4f8';
            });
            row.addEventListener('mouseleave', () => {
                row.style.background = 'transparent';
            });

            return row;
        }

        // Update path breadcrumb in folder browser
        function updateFolderBrowserPathBreadcrumb(path) {
            const breadcrumb = document.getElementById('wordFolderBrowserPathBreadcrumb');
            if (!breadcrumb) return;
            
            const parts = path.split(/[\\/]/).filter(p => p);
            let breadcrumbHTML = '';
            let currentPath = '';
            
            parts.forEach((part, index) => {
                if (index === 0 && path.startsWith('\\')) {
                    currentPath = '\\' + part;
                } else {
                    currentPath = currentPath ? currentPath + '\\' + part : part;
                }
                
                breadcrumbHTML += `<span style="cursor: pointer; color: #0066cc; text-decoration: underline;" data-path="${currentPath}">${part}</span>`;
                if (index < parts.length - 1) {
                    breadcrumbHTML += '<span style="margin: 0 4px; color: #666;">\\</span>';
                }
            });
            
            breadcrumb.innerHTML = breadcrumbHTML || path;
            
            // Add click handlers to breadcrumb parts
            breadcrumb.querySelectorAll('[data-path]').forEach(span => {
                span.addEventListener('click', () => {
                    loadFolderBrowserDirectory(span.getAttribute('data-path'));
                });
            });
        }

        // Folder browser dialog event listeners
        const wordFolderBrowserDialog = document.getElementById('wordFolderBrowserDialog');
        const wordFolderBrowserDialogClose = document.getElementById('wordFolderBrowserDialogClose');
        const wordFolderBrowserCancel = document.getElementById('wordFolderBrowserCancel');
        const wordFolderBrowserSelect = document.getElementById('wordFolderBrowserSelect');
        const wordFolderBrowserNavUp = document.getElementById('wordFolderBrowserNavUp');
        const wordFolderBrowserRefresh = document.getElementById('wordFolderBrowserRefresh');

        // Close folder browser
        if (wordFolderBrowserDialogClose) {
            wordFolderBrowserDialogClose.addEventListener('click', () => {
                if (wordFolderBrowserDialog) wordFolderBrowserDialog.style.display = 'none';
            });
        }

        if (wordFolderBrowserCancel) {
            wordFolderBrowserCancel.addEventListener('click', () => {
                if (wordFolderBrowserDialog) wordFolderBrowserDialog.style.display = 'none';
            });
        }

        // Select folder button
        if (wordFolderBrowserSelect) {
            wordFolderBrowserSelect.addEventListener('click', () => {
                if (selectedFolderPath && wordSaveAsFolderPath) {
                    wordSaveAsFolderPath.value = selectedFolderPath;
                }
                if (wordFolderBrowserDialog) wordFolderBrowserDialog.style.display = 'none';
            });
        }

        // Navigation buttons
        if (wordFolderBrowserNavUp) {
            wordFolderBrowserNavUp.addEventListener('click', async () => {
                if (currentFolderBrowserPath) {
                    try {
                        const response = await fetch(`http://localhost:8000/api/word/list-directory?path=${encodeURIComponent(currentFolderBrowserPath)}`);
                        const data = await response.json();
                        if (data.success && data.parent_path) {
                            loadFolderBrowserDirectory(data.parent_path);
                        }
                    } catch (error) {
                        console.error('Error navigating up:', error);
                    }
                }
            });
        }

        if (wordFolderBrowserRefresh) {
            wordFolderBrowserRefresh.addEventListener('click', () => {
                if (currentFolderBrowserPath) {
                    loadFolderBrowserDirectory(currentFolderBrowserPath);
                }
            });
        }

        // Save As submit
        if (wordSaveAsSubmit) {
            wordSaveAsSubmit.addEventListener('click', async () => {
                const folderPath = wordSaveAsFolderPath?.value.trim();
                const fileName = wordSaveAsFileName?.value.trim();
                
                if (!folderPath) {
                    alert('Please enter a folder path');
                    wordSaveAsFolderPath?.focus();
                    return;
                }

                if (!fileName) {
                    alert('Please enter a file name');
                    wordSaveAsFileName?.focus();
                    return;
                }

                // Ensure the filename ends with .docx
                let finalFileName = fileName;
                if (!finalFileName.toLowerCase().endsWith('.docx')) {
                    finalFileName = finalFileName + '.docx';
                    if (wordSaveAsFileName) wordSaveAsFileName.value = finalFileName;
                }

                // Combine folder path and filename
                // Normalize path separators - ensure we use the EXACT folder path the user selected
                let normalizedFolder = folderPath.trim();
                
                // Remove any quotes that might have been added
                normalizedFolder = normalizedFolder.replace(/^["']|["']$/g, '');
                
                // Replace forward slashes with backslashes for Windows
                normalizedFolder = normalizedFolder.replace(/\//g, '\\');
                
                // Remove trailing slashes but keep the path intact
                normalizedFolder = normalizedFolder.replace(/\\+$/, '');
                
                // Ensure we have a valid folder path (not empty)
                if (!normalizedFolder) {
                    alert('Please select a valid folder path');
                    wordSaveAsFolderPath?.focus();
                    return;
                }
                
                // Validate that the folder path looks valid (starts with a drive letter on Windows)
                if (normalizedFolder.length < 3 || !/^[A-Za-z]:/.test(normalizedFolder)) {
                    console.warn('Folder path might be invalid:', normalizedFolder);
                }
                
                // Construct the full file path using the selected folder
                // Use proper path separator
                const finalPath = `${normalizedFolder}\\${finalFileName}`;

                // Debug: Log the path being used to verify it's correct
                console.log('=== SAVE AS DIALOG ===');
                console.log('Raw folder path input:', folderPath);
                console.log('Normalized folder path:', normalizedFolder);
                console.log('File name:', finalFileName);
                console.log('Final full path:', finalPath);
                console.log('========================');

                // Save the document using the selected folder path
                await saveWordDocument(finalPath);
                
                // Close the modal
                if (wordSaveAsModal) wordSaveAsModal.style.display = 'none';
            });
        }

        // Function to save Word document (called from Save As dialog)
        // NOTE: This function is ONLY called when user explicitly requests to save.
        // There is NO auto-save functionality - files are saved only on user action.
        async function saveWordDocument(savePath = null) {
            const editorContent = document.getElementById('wordEditorContent');
            if (!editorContent) {
                alert('No document to save');
                return;
            }

            // Use provided path (from Save As dialog) or current document path
            const filePath = savePath || currentWordDocument.filePath;
            if (!filePath) {
                alert('Please specify a file path');
                showSaveAsDialog();
                return;
            }
            
            // Debug: Log the file path being used
            console.log('saveWordDocument called with filePath:', filePath);
            console.log('savePath parameter:', savePath);
            console.log('currentWordDocument.filePath:', currentWordDocument.filePath);

            // Get HTML content to preserve formatting
            const htmlContent = editorContent.innerHTML || '';
            
            // Debug: Log the content being saved
            console.log('=== SAVE DEBUG ===');
            console.log('HTML content length:', htmlContent.length);
            console.log('HTML content preview (first 500 chars):', htmlContent.substring(0, 500));
            console.log('Editor element:', editorContent);
            console.log('Editor innerHTML length:', editorContent.innerHTML ? editorContent.innerHTML.length : 0);
            
            // Check if content is empty
            const textContent = editorContent.innerText || editorContent.textContent || '';
            console.log('Text content length:', textContent.length);
            console.log('Text content preview:', textContent.substring(0, 200));
            
            if (!textContent.trim() && !htmlContent.trim()) {
                alert('Document is empty. Please add some content before saving.');
                const saveBtn = document.getElementById('wordEditorSave');
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.textContent = 'üíæ Save';
                }
                return;
            }
            
            // Ensure we have HTML content - use text content as fallback if needed
            let contentToSave = htmlContent;
            if (!htmlContent || htmlContent.trim() === '' || htmlContent.trim() === '<br>') {
                console.warn('Warning: HTML content is empty or minimal, using text content instead');
                // If HTML is empty but text exists, create a simple paragraph
                contentToSave = `<p>${textContent.replace(/\n/g, '</p><p>')}</p>`;
                console.log('Using fallback HTML:', contentToSave);
            }
            
            const saveBtn = document.getElementById('wordEditorSave');
            
            if (saveBtn) {
                saveBtn.disabled = true;
                saveBtn.textContent = 'üíæ Saving...';
            }

            try {
                // Save HTML content with formatting preserved
                console.log('=== SENDING SAVE REQUEST ===');
                console.log('File path:', filePath);
                console.log('Content to save length:', contentToSave.length);
                console.log('Content to save preview:', contentToSave.substring(0, 300));
                
                const saveResponse = await fetch('http://localhost:8000/api/word/save-html', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        file_path: filePath,
                        html_content: contentToSave
                    })
                });
                
                console.log('Save response status:', saveResponse.status);
                console.log('Save response ok:', saveResponse.ok);

                if (!saveResponse.ok) {
                    let errorMessage = `HTTP ${saveResponse.status}: Failed to save document`;
                    try {
                        const errorData = await saveResponse.json();
                        errorMessage = errorData.detail || errorData.message || errorData.error || errorMessage;
                    } catch (e) {
                        // If response is not JSON, use status text
                        errorMessage = `${saveResponse.status}: ${saveResponse.statusText || 'Unknown error'}`;
                    }
                    throw new Error(errorMessage);
                }
                
                const saveData = await saveResponse.json();
                console.log('Save response:', saveData);
                
                if (saveData.success) {
                    // Use the file path from the response if available, otherwise use what we sent
                    const savedPath = saveData.file_path || filePath;
                    
                    // Update current document path
                    currentWordDocument.filePath = savedPath;
                    
                    // Update the editor header to show new path
                    const editorTitle = document.querySelector('.word-editor-title');
                    if (editorTitle) {
                        const fileName = savedPath.split('\\').pop() || savedPath.split('/').pop() || 'Document';
                        editorTitle.innerHTML = `<span style="font-weight: 600;">üìÑ ${fileName}</span><span style="font-size: 12px; color: #666; margin-left: 12px;">${savedPath}</span>`;
                    }
                    
                    // Show success message with the actual saved path
                    alert(`Document saved successfully!\n\nPath: ${savedPath}`);
                    
                    if (saveBtn) {
                        saveBtn.textContent = 'üíæ Saved!';
                        setTimeout(() => {
                            if (saveBtn) {
                                saveBtn.textContent = 'üíæ Save';
                                saveBtn.disabled = false;
                            }
                        }, 2000);
                    }
                } else {
                    throw new Error(saveData.detail || saveData.message || saveData.error || 'Failed to save document');
                }
            } catch (error) {
                console.error('Error saving document:', error);
                alert('Error saving document: ' + error.message);
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.textContent = 'üíæ Save';
                }
            }
        }

        // Open create modal - now directly creates and opens editor
        if (createWordDocButton) {
            createWordDocButton.addEventListener('click', async () => {
                // Generate a default file path
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
                const defaultPath = await getDefaultDocumentsPath();
                const filePath = `${defaultPath}\\document_${timestamp}.docx`;
                
                // Create document with default values
                createWordDocButton.disabled = true;
                createWordDocButton.textContent = 'Creating...';
                
                try {
                    const response = await fetch('http://localhost:8000/api/word/create', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            file_path: filePath,
                            title: 'Untitled Document',
                            content: ''
                        })
                    });

                    const data = await response.json();
                    if (response.ok && data.success) {
                        // Open the document in the editor immediately
                        openWordEditor(filePath, 'Untitled Document', '');
                    } else {
                        const errorMsg = data.detail || data.message || data.error || 'Failed to create document';
                        alert('Error creating document:\n\n' + errorMsg);
                    }
                } catch (error) {
                    console.error('Error creating document:', error);
                    alert('Error creating document: ' + error.message);
                } finally {
                    createWordDocButton.disabled = false;
                    createWordDocButton.textContent = 'Create Document';
                }
            });
        }

        // Open document modal
        if (openWordDocButton) {
            openWordDocButton.addEventListener('click', () => {
                if (wordOpenModal) wordOpenModal.style.display = 'flex';
            });
        }

        // Close modals
        if (wordCreateModalClose) {
            wordCreateModalClose.addEventListener('click', () => {
                if (wordCreateModal) wordCreateModal.style.display = 'none';
            });
        }

        if (wordOpenModalClose) {
            wordOpenModalClose.addEventListener('click', () => {
                if (wordOpenModal) wordOpenModal.style.display = 'none';
            });
        }

        if (wordCreateCancel) {
            wordCreateCancel.addEventListener('click', () => {
                if (wordCreateModal) wordCreateModal.style.display = 'none';
            });
        }

        if (wordOpenCancel) {
            wordOpenCancel.addEventListener('click', () => {
                if (wordOpenModal) wordOpenModal.style.display = 'none';
            });
        }

        // Create document
        if (wordCreateSubmit) {
            wordCreateSubmit.addEventListener('click', async () => {
                const filePath = document.getElementById('wordFilePath')?.value.trim();
                const title = document.getElementById('wordDocTitle')?.value.trim();
                const content = document.getElementById('wordDocContent')?.value.trim();

                if (!filePath) {
                    alert('Please enter a file path (e.g., C:\\Users\\YourName\\Documents\\mydocument.docx)');
                    return;
                }

                // Ensure the path ends with .docx
                if (!filePath.toLowerCase().endsWith('.docx')) {
                    filePath = filePath + '.docx';
                    document.getElementById('wordFilePath').value = filePath;
                }

                wordCreateSubmit.disabled = true;
                wordCreateSubmit.textContent = 'Creating...';

                try {
                    const response = await fetch('http://localhost:8000/api/word/create', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            file_path: filePath,
                            title: title || undefined,
                            content: content || undefined
                        })
                    });

                    const data = await response.json();
                    if (response.ok && data.success) {
                        if (wordCreateModal) wordCreateModal.style.display = 'none';
                        // Clear form
                        if (document.getElementById('wordFilePath')) document.getElementById('wordFilePath').value = '';
                        if (document.getElementById('wordDocTitle')) document.getElementById('wordDocTitle').value = '';
                        if (document.getElementById('wordDocContent')) document.getElementById('wordDocContent').value = '';
                        
                        // Open the document in the editor
                        openWordEditor(filePath, title || 'Untitled Document', content || '');
                    } else {
                        const errorMsg = data.detail || data.message || data.error || 'Failed to create document';
                        console.error('Create document error:', errorMsg);
                        alert('Error creating document:\n\n' + errorMsg + '\n\nPlease check:\n- The file path is correct and writable\n- The directory exists\n- You have permission to write to that location');
                    }
                } catch (error) {
                    console.error('Error creating document:', error);
                    alert('Error creating document: ' + error.message + '\n\nPlease check your network connection and try again.');
                } finally {
                    wordCreateSubmit.disabled = false;
                    wordCreateSubmit.textContent = 'Create Document';
                }
            });
        }

        // Open document
        if (wordOpenSubmit) {
            wordOpenSubmit.addEventListener('click', async () => {
                const filePath = document.getElementById('wordOpenFilePath')?.value.trim();

                if (!filePath) {
                    alert('Please enter a file path (e.g., C:\\Users\\YourName\\Documents\\mydocument.docx)');
                    return;
                }

                // Ensure the path ends with .docx if no extension
                if (!filePath.includes('.') && !filePath.toLowerCase().endsWith('.docx')) {
                    filePath = filePath + '.docx';
                    document.getElementById('wordOpenFilePath').value = filePath;
                }

                wordOpenSubmit.disabled = true;
                wordOpenSubmit.textContent = 'Opening...';

                try {
                    const response = await fetch('http://localhost:8000/api/word/open', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            file_path: filePath
                        })
                    });

                    const data = await response.json();
                    if (response.ok && data.success) {
                        // Close the modal
                        if (wordOpenModal) wordOpenModal.style.display = 'none';
                        
                        // Get document content and open in editor
                        const content = data.data?.content || '';
                        const fileName = filePath.split('\\').pop() || filePath.split('/').pop() || 'Document';
                        
                        // Open the document in the Word editor
                        openWordEditor(filePath, fileName, content);
                        
                        console.log('Document opened successfully:', filePath);
                    } else {
                        const errorMsg = data.detail || data.message || data.error || 'Failed to open document';
                        console.error('Open document error:', errorMsg);
                        alert('Error opening document:\n\n' + errorMsg + '\n\nPlease check:\n- The file path is correct\n- The file exists\n- The file is a valid .docx document\n- You have permission to read the file');
                    }
                } catch (error) {
                    console.error('Error opening document:', error);
                    alert('Error opening document: ' + error.message + '\n\nPlease check your network connection and try again.');
                } finally {
                    wordOpenSubmit.disabled = false;
                    wordOpenSubmit.textContent = 'Open Document';
                }
            });
        }

        // Slack send message functionality (duplicate removed - already declared above)
        // Auto-resize textarea
        if (slackMessageInput) {
            slackMessageInput.addEventListener('input', function() {
                this.style.height = 'auto';
                this.style.height = Math.min(this.scrollHeight, 150) + 'px';
                slackSendButton.disabled = !this.value.trim() || !currentSlackChannelId;
            });

            slackMessageInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    if (!slackSendButton.disabled) {
                        sendSlackMessage();
                    }
                }
            });
        }

        async function sendSlackMessage() {
            if (!currentSlackChannelId || !slackMessageInput) return;
            
            const text = slackMessageInput.value.trim();
            if (!text) return;
        
            // Disable input while sending
            slackMessageInput.disabled = true;
            slackSendButton.disabled = true;
            slackSendButton.innerHTML = '<div class="slack-send-spinner"></div>';

            try {
                const threadTs = slackMessageInput.dataset.threadTs;
                console.log(`[*] Sending message to channel ${currentSlackChannelId}...`);
                
                const url = threadTs ? 'http://localhost:3002/api/slack/reply' : 'http://localhost:3002/api/slack/send';
                const body = threadTs ? {
                    channel_id: currentSlackChannelId,
                    thread_ts: threadTs,
                    text: text
                } : {
                    channel_id: currentSlackChannelId,
                    text: text
                };

                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(body)
                });

                // Clear thread_ts after sending
                if (slackMessageInput.dataset.threadTs) {
                    delete slackMessageInput.dataset.threadTs;
                }

                console.log('[*] Response status:', response.status);
                const data = await response.json();
                console.log('[*] Response data:', data);

                if (response.ok && data.success) {
                    // Clear input
                    slackMessageInput.value = '';
                    slackMessageInput.style.height = 'auto';
                    
                    // Reload messages for this channel to show the new one
                    if (currentSlackChannelId) {
                        // Clear cache and reload messages for this channel
                        delete slackMessagesByChannel[currentSlackChannelId];
                        await selectSlackChannel(currentSlackChannelId);
                    }
                } else {
                    const errorMsg = data.error || data.detail || JSON.stringify(data);
                    console.error('[!] Backend error:', errorMsg);
                    alert(`Failed to send message: ${errorMsg}`);
                }
            } catch (error) {
                console.error('[!] Exception:', error);
                alert(`Failed to send message: ${error.message}`);
            } finally {
                // Re-enable input
                slackMessageInput.disabled = false;
                slackSendButton.disabled = false;
                slackSendButton.innerHTML = `
                    <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                        <path d="M18 2L9 11M18 2L12 18L9 11M18 2L2 8L9 11" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                `;
                slackMessageInput.focus();
            }
        }

        // ===================================================================
        // Excel Spreadsheet functionality
        // ===================================================================
        
        const createExcelButton = document.getElementById('createExcelButton');
        const openExcelButton = document.getElementById('openExcelButton');
        const excelSpreadsheetArea = document.getElementById('excelSpreadsheetArea');
        
        // Track current Excel spreadsheet
        let currentExcelSpreadsheet = {
            filePath: null,
            sheets: [],
            activeSheet: null,
            data: {} // { sheetName: [[cell values]] }
        };

        // Excel function library
        const excelFunctions = [
            { name: 'SUM', category: 'math', syntax: '=SUM(range)', description: 'Adds all the numbers in a range of cells.', example: '=SUM(A1:A10)' },
            { name: 'AVERAGE', category: 'math', syntax: '=AVERAGE(range)', description: 'Returns the average (arithmetic mean) of the arguments.', example: '=AVERAGE(A1:A10)' },
            { name: 'COUNT', category: 'math', syntax: '=COUNT(range)', description: 'Counts the number of cells that contain numbers.', example: '=COUNT(A1:A10)' },
            { name: 'COUNTA', category: 'math', syntax: '=COUNTA(range)', description: 'Counts the number of cells that are not empty.', example: '=COUNTA(A1:A10)' },
            { name: 'MAX', category: 'math', syntax: '=MAX(range)', description: 'Returns the largest value in a set of values.', example: '=MAX(A1:A10)' },
            { name: 'MIN', category: 'math', syntax: '=MIN(range)', description: 'Returns the smallest value in a set of values.', example: '=MIN(A1:A10)' },
            { name: 'PRODUCT', category: 'math', syntax: '=PRODUCT(range)', description: 'Multiplies all the numbers given as arguments.', example: '=PRODUCT(A1:A5)' },
            { name: 'ROUND', category: 'math', syntax: '=ROUND(number, num_digits)', description: 'Rounds a number to a specified number of digits.', example: '=ROUND(A1, 2)' },
            { name: 'ROUNDUP', category: 'math', syntax: '=ROUNDUP(number, num_digits)', description: 'Rounds a number up, away from zero.', example: '=ROUNDUP(A1, 2)' },
            { name: 'ROUNDDOWN', category: 'math', syntax: '=ROUNDDOWN(number, num_digits)', description: 'Rounds a number down, toward zero.', example: '=ROUNDDOWN(A1, 2)' },
            { name: 'CONCATENATE', category: 'text', syntax: '=CONCATENATE(text1, text2, ...)', description: 'Joins several text strings into one text string.', example: '=CONCATENATE(A1, " ", B1)' },
            { name: 'CONCAT', category: 'text', syntax: '=CONCAT(text1, text2, ...)', description: 'Combines text from multiple ranges and/or strings.', example: '=CONCAT(A1, B1)' },
            { name: 'LEN', category: 'text', syntax: '=LEN(text)', description: 'Returns the number of characters in a text string.', example: '=LEN(A1)' },
            { name: 'UPPER', category: 'text', syntax: '=UPPER(text)', description: 'Converts text to uppercase.', example: '=UPPER(A1)' },
            { name: 'LOWER', category: 'text', syntax: '=LOWER(text)', description: 'Converts text to lowercase.', example: '=LOWER(A1)' },
            { name: 'TRIM', category: 'text', syntax: '=TRIM(text)', description: 'Removes all spaces from text except single spaces between words.', example: '=TRIM(A1)' },
            { name: 'LEFT', category: 'text', syntax: '=LEFT(text, num_chars)', description: 'Returns the first character or characters in a text string.', example: '=LEFT(A1, 5)' },
            { name: 'RIGHT', category: 'text', syntax: '=RIGHT(text, num_chars)', description: 'Returns the last character or characters in a text string.', example: '=RIGHT(A1, 5)' },
            { name: 'MID', category: 'text', syntax: '=MID(text, start_num, num_chars)', description: 'Returns a specific number of characters from a text string.', example: '=MID(A1, 2, 5)' },
            { name: 'IF', category: 'logical', syntax: '=IF(logical_test, value_if_true, value_if_false)', description: 'Returns one value if a condition is true and another value if it\'s false.', example: '=IF(A1>10, "High", "Low")' },
            { name: 'AND', category: 'logical', syntax: '=AND(logical1, logical2, ...)', description: 'Returns TRUE if all arguments are TRUE.', example: '=AND(A1>0, B1<100)' },
            { name: 'OR', category: 'logical', syntax: '=OR(logical1, logical2, ...)', description: 'Returns TRUE if any argument is TRUE.', example: '=OR(A1>0, B1>0)' },
            { name: 'NOT', category: 'logical', syntax: '=NOT(logical)', description: 'Reverses the logic of its argument.', example: '=NOT(A1>0)' },
            { name: 'TODAY', category: 'date', syntax: '=TODAY()', description: 'Returns the current date.', example: '=TODAY()' },
            { name: 'NOW', category: 'date', syntax: '=NOW()', description: 'Returns the current date and time.', example: '=NOW()' }
        ];

        let selectedFunction = null;

        function openExcelEditor(filePath, sheets, activeSheet, sheetData) {
            console.log('üìä openExcelEditor called with:');
            console.log('  - filePath:', filePath);
            console.log('  - sheets:', sheets);
            console.log('  - activeSheet:', activeSheet);
            console.log('  - sheetData keys:', sheetData ? Object.keys(sheetData) : 'N/A');
            console.log('  - sheetData structure:', sheetData);
            
            currentExcelSpreadsheet.filePath = filePath;
            currentExcelSpreadsheet.sheets = sheets || ['Sheet1'];
            currentExcelSpreadsheet.activeSheet = activeSheet || 'Sheet1';
            currentExcelSpreadsheet.data = sheetData || { 'Sheet1': Array(30).fill().map(() => Array(15).fill('')) };
            
            console.log('üìä currentExcelSpreadsheet.data keys:', Object.keys(currentExcelSpreadsheet.data));
            
            if (excelSpreadsheetArea) {
                const fileName = filePath.split('\\').pop() || filePath.split('/').pop() || 'Spreadsheet';
                excelSpreadsheetArea.innerHTML = `
                    <div class="excel-editor-container">
                        <div class="excel-editor-toolbar">
                            <!-- File Operations -->
                            <div class="excel-editor-toolbar-group">
                                <button class="excel-editor-btn" id="excelEditorNew" title="New Spreadsheet">üìä New</button>
                                <button class="excel-editor-btn" id="excelEditorOpen" title="Open Spreadsheet">üìÇ Open</button>
                                <button class="excel-editor-btn excel-editor-btn-primary" id="excelEditorSave" title="Save (Ctrl+S)">üíæ Save</button>
                            </div>
                            
                            <!-- Formatting -->
                            <div class="excel-editor-toolbar-group">
                                <button class="excel-editor-btn" id="excelEditorBold" title="Bold"><strong>B</strong></button>
                                <button class="excel-editor-btn" id="excelEditorItalic" title="Italic"><em>I</em></button>
                                <button class="excel-editor-btn" id="excelEditorUnderline" title="Underline"><u>U</u></button>
                            </div>
                            
                            <!-- Alignment -->
                            <div class="excel-editor-toolbar-group">
                                <button class="excel-editor-btn" id="excelEditorAlignLeft" title="Align Left">‚óÄ</button>
                                <button class="excel-editor-btn" id="excelEditorAlignCenter" title="Align Center">‚ñ£</button>
                                <button class="excel-editor-btn" id="excelEditorAlignRight" title="Align Right">‚ñ∂</button>
                            </div>
                            
                            <!-- Font Controls -->
                            <div class="excel-editor-toolbar-group">
                                <select class="excel-editor-select" id="excelEditorFontSize" title="Font Size">
                                    <option value="8">8</option>
                                    <option value="9">9</option>
                                    <option value="10">10</option>
                                    <option value="11" selected>11</option>
                                    <option value="12">12</option>
                                    <option value="14">14</option>
                                    <option value="16">16</option>
                                    <option value="18">18</option>
                                    <option value="20">20</option>
                                </select>
                                <input type="color" id="excelEditorBgColor" title="Background Color" value="#ffffff" style="width: 40px; height: 28px; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;">
                            </div>
                            
                            <!-- Sheet Operations -->
                            <div class="excel-editor-toolbar-group">
                                <button class="excel-editor-btn" id="excelEditorAddSheet" title="Add Sheet">‚ûï Sheet</button>
                            </div>
                        </div>
                        
                        <div class="excel-info-bar">
                            <span style="font-weight: 600;">üìä ${fileName}</span>
                            <span style="color: rgba(255, 255, 255, 0.7); margin-left: 16px;" id="excelCellInfo">Ready</span>
                        </div>
                        
                        <div class="excel-formula-bar">
                            <div class="excel-formula-bar-cell-ref" id="excelFormulaBarCellRef"></div>
                            <div class="excel-formula-bar-input-container">
                                <button class="excel-formula-bar-fx" id="excelFormulaBarFxButton" title="Insert Function">fx</button>
                                <input type="text" class="excel-formula-bar-input" id="excelFormulaBarInput" placeholder="Enter value or formula (e.g., =SUM(A1:A10))">
                            </div>
                        </div>
                        
                        <!-- Function Helper Modal -->
                        <div class="excel-function-modal" id="excelFunctionModal" style="display: none;">
                            <div class="excel-function-modal-content">
                                <div class="excel-function-modal-header">
                                    <h3>Insert Function</h3>
                                    <button class="excel-modal-close" id="excelFunctionModalClose">&times;</button>
                                </div>
                                <div class="excel-function-modal-body">
                                    <div class="excel-function-search">
                                        <input type="text" id="excelFunctionSearch" placeholder="Search functions..." />
                                    </div>
                                    <div class="excel-function-categories">
                                        <button class="excel-function-category-btn active" data-category="all">All</button>
                                        <button class="excel-function-category-btn" data-category="math">Math</button>
                                        <button class="excel-function-category-btn" data-category="text">Text</button>
                                        <button class="excel-function-category-btn" data-category="logical">Logical</button>
                                        <button class="excel-function-category-btn" data-category="date">Date/Time</button>
                                    </div>
                                    <div class="excel-function-list" id="excelFunctionList">
                                        <!-- Functions will be populated here -->
                                    </div>
                                    <div class="excel-function-description" id="excelFunctionDescription">
                                        <h4>Function Description</h4>
                                        <p>Select a function to see its description and syntax.</p>
                                    </div>
                                </div>
                                <div class="excel-function-modal-footer">
                                    <button class="btn btn-secondary" id="excelFunctionCancel">Cancel</button>
                                    <button class="btn" id="excelFunctionInsert">Insert Function</button>
                                </div>
                            </div>
                        </div>
                        
                        <div class="excel-grid-container" id="excelGridContainer">
                            ${renderExcelGrid(currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet])}
                        </div>
                        
                        <div class="excel-sheet-tabs" id="excelSheetTabs">
                            ${renderSheetTabs(currentExcelSpreadsheet.sheets, currentExcelSpreadsheet.activeSheet)}
                        </div>
                    </div>
                `;
                
                // Attach event listeners to toolbar buttons
                attachExcelToolbarListeners();
                
                // Attach event listeners to grid cells
                attachExcelCellListeners();
                
                // Attach event listeners to sheet tabs
                attachExcelSheetTabListeners();
                
                // Recalculate all formulas to ensure dependencies are resolved
                setTimeout(() => recalculateAllFormulas(), 10);
                
                // Handle keyboard shortcuts
                document.addEventListener('keydown', handleExcelKeyboard);
            }
        }

        function renderExcelGrid(data) {
            const rows = data.length;
            const cols = data[0]?.length || 15;
            const colLetters = [];
            
            // Generate column letters (A, B, C, ... Z, AA, AB, ...)
            for (let i = 0; i < cols; i++) {
                colLetters.push(getColumnLetter(i));
            }
            
            let html = '<div class="excel-grid">';
            
            // Column headers
            html += '<div class="excel-row excel-header-row">';
            html += '<div class="excel-cell excel-corner-cell"></div>'; // Corner cell
            for (let col = 0; col < cols; col++) {
                html += `<div class="excel-cell excel-column-header">${colLetters[col]}</div>`;
            }
            html += '</div>';
            
            // Data rows
            for (let row = 0; row < rows; row++) {
                html += '<div class="excel-row">';
                html += `<div class="excel-cell excel-row-header">${row + 1}</div>`; // Row number
                for (let col = 0; col < cols; col++) {
                    const value = data[row][col] || '';
                    let displayValue = value;
                    let formulaAttr = '';
                    
                    // If it's a formula, evaluate it for display
                    if (typeof value === 'string' && value.startsWith('=')) {
                        try {
                            displayValue = evaluateFormula(value, row, col);
                            formulaAttr = ` data-formula="${escapeHtml(value)}"`;
                        } catch (error) {
                            displayValue = '#ERROR!';
                            formulaAttr = ` data-formula="${escapeHtml(value)}"`;
                        }
                    }
                    
                    html += `<div class="excel-cell excel-data-cell" data-row="${row}" data-col="${col}" contenteditable="true"${formulaAttr}>${escapeHtml(String(displayValue))}</div>`;
                }
                html += '</div>';
            }
            
            html += '</div>';
            return html;
        }

        function renderSheetTabs(sheets, activeSheet) {
            return sheets.map(sheet => {
                const activeClass = sheet === activeSheet ? 'active' : '';
                return `<div class="excel-sheet-tab ${activeClass}" data-sheet="${sheet}">${sheet}</div>`;
            }).join('');
        }

        function getColumnLetter(index) {
            let letter = '';
            while (index >= 0) {
                letter = String.fromCharCode(65 + (index % 26)) + letter;
                index = Math.floor(index / 26) - 1;
            }
            return letter;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function attachExcelToolbarListeners() {
            // Save button
            const saveBtn = document.getElementById('excelEditorSave');
            if (saveBtn) {
                saveBtn.addEventListener('click', saveExcelSpreadsheet);
            }
            
            // New button
            const newBtn = document.getElementById('excelEditorNew');
            if (newBtn) {
                newBtn.addEventListener('click', () => {
                    if (createExcelButton) createExcelButton.click();
                });
            }
            
            // Open button
            const openBtn = document.getElementById('excelEditorOpen');
            if (openBtn) {
                openBtn.addEventListener('click', () => {
                    if (openExcelButton) openExcelButton.click();
                });
            }
            
            // Add Sheet button
            const addSheetBtn = document.getElementById('excelEditorAddSheet');
            if (addSheetBtn) {
                addSheetBtn.addEventListener('click', async () => {
                    const sheetName = prompt('Enter new sheet name:', `Sheet${currentExcelSpreadsheet.sheets.length + 1}`);
                    if (sheetName && !currentExcelSpreadsheet.sheets.includes(sheetName)) {
                        currentExcelSpreadsheet.sheets.push(sheetName);
                        currentExcelSpreadsheet.data[sheetName] = Array(30).fill().map(() => Array(15).fill(''));
                        updateSheetTabs();
                    }
                });
            }
            
            // fx button - open function modal
            const fxBtn = document.getElementById('excelFormulaBarFxButton');
            if (fxBtn) {
                fxBtn.addEventListener('click', () => {
                    showFunctionModal();
                });
            }
            
            // Formatting buttons
            const boldBtn = document.getElementById('excelEditorBold');
            if (boldBtn) {
                boldBtn.addEventListener('click', () => applyCellFormatting('fontWeight', 'bold'));
            }
            
            const italicBtn = document.getElementById('excelEditorItalic');
            if (italicBtn) {
                italicBtn.addEventListener('click', () => applyCellFormatting('fontStyle', 'italic'));
            }
            
            const underlineBtn = document.getElementById('excelEditorUnderline');
            if (underlineBtn) {
                underlineBtn.addEventListener('click', () => applyCellFormatting('textDecoration', 'underline'));
            }
            
            // Alignment buttons
            const alignLeftBtn = document.getElementById('excelEditorAlignLeft');
            if (alignLeftBtn) {
                alignLeftBtn.addEventListener('click', () => applyCellFormatting('textAlign', 'left'));
            }
            
            const alignCenterBtn = document.getElementById('excelEditorAlignCenter');
            if (alignCenterBtn) {
                alignCenterBtn.addEventListener('click', () => applyCellFormatting('textAlign', 'center'));
            }
            
            const alignRightBtn = document.getElementById('excelEditorAlignRight');
            if (alignRightBtn) {
                alignRightBtn.addEventListener('click', () => applyCellFormatting('textAlign', 'right'));
            }
            
            // Font controls
            const fontSizeSelect = document.getElementById('excelEditorFontSize');
            if (fontSizeSelect) {
                fontSizeSelect.addEventListener('change', function() {
                    applyCellFormatting('fontSize', this.value + 'pt');
                });
            }
            
            const fontFamilySelect = document.getElementById('excelEditorFontFamily');
            if (fontFamilySelect) {
                fontFamilySelect.addEventListener('change', function() {
                    applyCellFormatting('fontFamily', this.value);
                });
            }
        }
        
        // Apply formatting to selected cells
        function applyCellFormatting(property, value) {
            const selectedCells = document.querySelectorAll('.excel-data-cell.excel-cell-selected');
            if (selectedCells.length === 0) return;
            
            saveExcelState('Format Cells');
            
            selectedCells.forEach(cell => {
                // Toggle formatting if it's already applied (for bold, italic, underline)
                if (property === 'fontWeight' && cell.style.fontWeight === value) {
                    cell.style.fontWeight = 'normal';
                } else if (property === 'fontStyle' && cell.style.fontStyle === value) {
                    cell.style.fontStyle = 'normal';
                } else if (property === 'textDecoration' && cell.style.textDecoration === value) {
                    cell.style.textDecoration = 'none';
                } else {
                    cell.style[property] = value;
                }
            });
            
            console.log('Applied formatting:', property, '=', value, 'to', selectedCells.length, 'cells');
        }
        
        // Number formatting functions
        function formatCurrency() {
            const selectedCells = document.querySelectorAll('.excel-data-cell.excel-cell-selected');
            if (selectedCells.length === 0) return;
            
            saveExcelState('Format as Currency');
            
            selectedCells.forEach(cell => {
                const row = parseInt(cell.getAttribute('data-row'));
                const col = parseInt(cell.getAttribute('data-col'));
                const value = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet][row][col];
                
                // Skip if it's a formula
                if (typeof value === 'string' && value.startsWith('=')) return;
                
                const num = parseFloat(value);
                if (!isNaN(num)) {
                    const formatted = '$' + num.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
                    cell.textContent = formatted;
                    cell.setAttribute('data-format', 'currency');
                    cell.setAttribute('data-raw-value', value);
                }
            });
            
            console.log('Formatted as currency');
        }
        
        function formatPercentage() {
            const selectedCells = document.querySelectorAll('.excel-data-cell.excel-cell-selected');
            if (selectedCells.length === 0) return;
            
            saveExcelState('Format as Percentage');
            
            selectedCells.forEach(cell => {
                const row = parseInt(cell.getAttribute('data-row'));
                const col = parseInt(cell.getAttribute('data-col'));
                const value = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet][row][col];
                
                // Skip if it's a formula
                if (typeof value === 'string' && value.startsWith('=')) return;
                
                const num = parseFloat(value);
                if (!isNaN(num)) {
                    const formatted = (num * 100).toFixed(2) + '%';
                    cell.textContent = formatted;
                    cell.setAttribute('data-format', 'percentage');
                    cell.setAttribute('data-raw-value', value);
                }
            });
            
            console.log('Formatted as percentage');
        }
        
        function formatDecimals(decimals = 2) {
            const selectedCells = document.querySelectorAll('.excel-data-cell.excel-cell-selected');
            if (selectedCells.length === 0) return;
            
            saveExcelState('Format Decimals');
            
            selectedCells.forEach(cell => {
                const row = parseInt(cell.getAttribute('data-row'));
                const col = parseInt(cell.getAttribute('data-col'));
                const value = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet][row][col];
                
                // Skip if it's a formula
                if (typeof value === 'string' && value.startsWith('=')) return;
                
                const num = parseFloat(value);
                if (!isNaN(num)) {
                    cell.textContent = num.toFixed(decimals);
                    cell.setAttribute('data-format', 'decimal');
                    cell.setAttribute('data-raw-value', value);
                }
            });
            
            console.log('Formatted with', decimals, 'decimals');
        }
        
        function formatNumber() {
            const selectedCells = document.querySelectorAll('.excel-data-cell.excel-cell-selected');
            if (selectedCells.length === 0) return;
            
            saveExcelState('Format as Number');
            
            selectedCells.forEach(cell => {
                const row = parseInt(cell.getAttribute('data-row'));
                const col = parseInt(cell.getAttribute('data-col'));
                const value = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet][row][col];
                
                // Skip if it's a formula
                if (typeof value === 'string' && value.startsWith('=')) return;
                
                const num = parseFloat(value);
                if (!isNaN(num)) {
                    const formatted = num.toLocaleString();
                    cell.textContent = formatted;
                    cell.setAttribute('data-format', 'number');
                    cell.setAttribute('data-raw-value', value);
                }
            });
            
            console.log('Formatted as number');
        }
        
        // Add keyboard shortcut for number formatting
        function showFormatMenu() {
            const menu = prompt('Format Options:\n1. Currency ($)\n2. Percentage (%)\n3. Number (1,000)\n4. Decimal (2 places)\n5. Decimal (4 places)\n6. Add All Borders\n7. Add Outer Border\n8. Remove Borders\n\nEnter option (1-8):');
            
            switch(menu) {
                case '1':
                    formatCurrency();
                    break;
                case '2':
                    formatPercentage();
                    break;
                case '3':
                    formatNumber();
                    break;
                case '4':
                    formatDecimals(2);
                    break;
                case '5':
                    formatDecimals(4);
                    break;
                case '6':
                    addCellBorders('all');
                    break;
                case '7':
                    addCellBorders('outer');
                    break;
                case '8':
                    removeCellBorders();
                    break;
            }
        }
        
        // Cell borders functionality
        function addCellBorders(type = 'all') {
            const selectedCells = document.querySelectorAll('.excel-data-cell.excel-cell-selected');
            if (selectedCells.length === 0) return;
            
            saveExcelState('Add Cell Borders');
            
            if (type === 'all') {
                selectedCells.forEach(cell => {
                    cell.style.border = '2px solid #6366f1';
                });
            } else if (type === 'outer') {
                // Get the range of selected cells
                let minRow = Infinity, maxRow = -Infinity;
                let minCol = Infinity, maxCol = -Infinity;
                
                selectedCells.forEach(cell => {
                    const row = parseInt(cell.getAttribute('data-row'));
                    const col = parseInt(cell.getAttribute('data-col'));
                    minRow = Math.min(minRow, row);
                    maxRow = Math.max(maxRow, row);
                    minCol = Math.min(minCol, col);
                    maxCol = Math.max(maxCol, col);
                });
                
                // Apply outer borders
                selectedCells.forEach(cell => {
                    const row = parseInt(cell.getAttribute('data-row'));
                    const col = parseInt(cell.getAttribute('data-col'));
                    
                    if (row === minRow) cell.style.borderTop = '2px solid #6366f1';
                    if (row === maxRow) cell.style.borderBottom = '2px solid #6366f1';
                    if (col === minCol) cell.style.borderLeft = '2px solid #6366f1';
                    if (col === maxCol) cell.style.borderRight = '2px solid #6366f1';
                });
            }
            
            console.log('Added borders:', type);
        }
        
        function removeCellBorders() {
            const selectedCells = document.querySelectorAll('.excel-data-cell.excel-cell-selected');
            if (selectedCells.length === 0) return;
            
            saveExcelState('Remove Cell Borders');
            
            selectedCells.forEach(cell => {
                cell.style.border = '';
                cell.style.borderTop = '';
                cell.style.borderBottom = '';
                cell.style.borderLeft = '';
                cell.style.borderRight = '';
            });
            
            console.log('Removed borders');
        }

        function showFunctionModal() {
            const modal = document.getElementById('excelFunctionModal');
            if (modal) {
                modal.style.display = 'flex';
                populateFunctionList('all');
                
                // Setup modal event listeners
                setupFunctionModalListeners();
            }
        }

        function setupFunctionModalListeners() {
            // Close button
            const closeBtn = document.getElementById('excelFunctionModalClose');
            if (closeBtn) {
                closeBtn.onclick = () => {
                    document.getElementById('excelFunctionModal').style.display = 'none';
                };
            }
            
            // Cancel button
            const cancelBtn = document.getElementById('excelFunctionCancel');
            if (cancelBtn) {
                cancelBtn.onclick = () => {
                    document.getElementById('excelFunctionModal').style.display = 'none';
                };
            }
            
            // Insert button
            const insertBtn = document.getElementById('excelFunctionInsert');
            if (insertBtn) {
                insertBtn.onclick = () => {
                    if (selectedFunction) {
                        const formulaInput = document.getElementById('excelFormulaBarInput');
                        if (formulaInput) {
                            formulaInput.value = selectedFunction.syntax;
                            formulaInput.focus();
                        }
                        document.getElementById('excelFunctionModal').style.display = 'none';
                    }
                };
            }
            
            // Category buttons
            const categoryBtns = document.querySelectorAll('.excel-function-category-btn');
            categoryBtns.forEach(btn => {
                btn.onclick = function() {
                    categoryBtns.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    const category = this.getAttribute('data-category');
                    populateFunctionList(category);
                };
            });
            
            // Search input
            const searchInput = document.getElementById('excelFunctionSearch');
            if (searchInput) {
                searchInput.oninput = function() {
                    const searchTerm = this.value.toLowerCase();
                    const filtered = excelFunctions.filter(f => 
                        f.name.toLowerCase().includes(searchTerm) || 
                        f.description.toLowerCase().includes(searchTerm)
                    );
                    renderFunctionList(filtered);
                };
            }
        }

        function populateFunctionList(category) {
            const filtered = category === 'all' 
                ? excelFunctions 
                : excelFunctions.filter(f => f.category === category);
            renderFunctionList(filtered);
        }

        function renderFunctionList(functions) {
            const listContainer = document.getElementById('excelFunctionList');
            if (!listContainer) return;
            
            listContainer.innerHTML = functions.map(func => `
                <div class="excel-function-item" data-function="${func.name}">
                    <div class="excel-function-name">${func.name}</div>
                    <div class="excel-function-syntax">${func.syntax}</div>
                </div>
            `).join('');
            
            // Add click handlers
            const items = listContainer.querySelectorAll('.excel-function-item');
            items.forEach(item => {
                item.onclick = function() {
                    items.forEach(i => i.classList.remove('selected'));
                    this.classList.add('selected');
                    const funcName = this.getAttribute('data-function');
                    selectedFunction = excelFunctions.find(f => f.name === funcName);
                    showFunctionDescription(selectedFunction);
                };
            });
        }

        function showFunctionDescription(func) {
            const descContainer = document.getElementById('excelFunctionDescription');
            if (!descContainer || !func) return;
            
            descContainer.innerHTML = `
                <h4>${func.name}</h4>
                <p><strong>Syntax:</strong> ${func.syntax}</p>
                <p><strong>Description:</strong> ${func.description}</p>
                <p><strong>Example:</strong> <code>${func.example}</code></p>
            `;
        }

        function attachExcelCellListeners() {
            const cells = document.querySelectorAll('.excel-data-cell');
            const formulaBarInput = document.getElementById('excelFormulaBarInput');
            const formulaBarCellRef = document.getElementById('excelFormulaBarCellRef');
            
            cells.forEach(cell => {
                // Right-click context menu
                cell.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    const row = parseInt(this.getAttribute('data-row'));
                    const col = parseInt(this.getAttribute('data-col'));
                    showExcelContextMenu(e.clientX, e.clientY, row, col);
                });
                
                // Mouse click handler for multi-selection
                cell.addEventListener('mousedown', function(e) {
                    const row = parseInt(this.getAttribute('data-row'));
                    const col = parseInt(this.getAttribute('data-col'));
                    
                    if (e.shiftKey && excelSelection.start) {
                        // Shift-click: select range
                        e.preventDefault();
                        
                        const startRow = excelSelection.start.row;
                        const startCol = excelSelection.start.col;
                        const endRow = row;
                        const endCol = col;
                        
                        // Clear previous selection
                        document.querySelectorAll('.excel-cell-selected').forEach(c => {
                            c.classList.remove('excel-cell-selected');
                        });
                        
                        // Select all cells in range
                        const minRow = Math.min(startRow, endRow);
                        const maxRow = Math.max(startRow, endRow);
                        const minCol = Math.min(startCol, endCol);
                        const maxCol = Math.max(startCol, endCol);
                        
                        for (let r = minRow; r <= maxRow; r++) {
                            for (let c = minCol; c <= maxCol; c++) {
                                const rangeCell = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                                if (rangeCell) {
                                    rangeCell.classList.add('excel-cell-selected');
                                }
                            }
                        }
                        
                        excelSelection.end = { row, col };
                    } else if (e.ctrlKey || e.metaKey) {
                        // Ctrl-click: toggle selection
                        e.preventDefault();
                        this.classList.toggle('excel-cell-selected');
                        
                        if (!excelSelection.start) {
                            excelSelection.start = { row, col };
                        }
                    } else {
                        // Normal click: clear and select single cell
                        if (!this.classList.contains('excel-cell-selected')) {
                            document.querySelectorAll('.excel-cell-selected').forEach(c => {
                                c.classList.remove('excel-cell-selected');
                            });
                        }
                        
                        excelSelection.start = { row, col };
                        excelSelection.end = null;
                    }
                });
                
                cell.addEventListener('focus', function() {
                    const row = parseInt(this.getAttribute('data-row'));
                    const col = parseInt(this.getAttribute('data-col'));
                    const cellRef = `${getColumnLetter(col)}${row + 1}`;
                    
                    const cellInfo = document.getElementById('excelCellInfo');
                    if (cellInfo) {
                        cellInfo.textContent = `Cell: ${cellRef}`;
                    }
                    
                    // Update formula bar
                    if (formulaBarCellRef) {
                        formulaBarCellRef.textContent = cellRef;
                    }
                    if (formulaBarInput) {
                        const rawValue = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet][row][col];
                        formulaBarInput.value = rawValue || '';
                    }
                    
                    this.classList.add('excel-cell-selected');
                    
                    // Check if we need to expand the grid
                    const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
                    const currentRows = sheetData.length;
                    const currentCols = sheetData[0]?.length || 0;
                    
                    let needsExpansion = false;
                    
                    // If in last column (or beyond), add more columns
                    if (col >= currentCols - 1) {
                        const columnsToAdd = 5; // Add 5 columns at a time
                        for (let i = 0; i < sheetData.length; i++) {
                            for (let j = 0; j < columnsToAdd; j++) {
                                sheetData[i].push('');
                            }
                        }
                        needsExpansion = true;
                    }
                    
                    // If in last row (or beyond), add more rows
                    if (row >= currentRows - 1) {
                        const rowsToAdd = 10; // Add 10 rows at a time
                        const newCols = sheetData[0]?.length || currentCols;
                        for (let i = 0; i < rowsToAdd; i++) {
                            sheetData.push(Array(newCols).fill(''));
                        }
                        needsExpansion = true;
                    }
                    
                    // Re-render grid if expanded
                    if (needsExpansion) {
                        const gridContainer = document.getElementById('excelGridContainer');
                        if (gridContainer) {
                            gridContainer.innerHTML = renderExcelGrid(sheetData);
                            attachExcelCellListeners();
                            // Re-focus the cell that was clicked
                            const newCell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                            if (newCell) {
                                setTimeout(() => newCell.focus(), 10);
                            }
                        }
                    }
                });
                
                cell.addEventListener('blur', function() {
                    const row = parseInt(this.getAttribute('data-row'));
                    const col = parseInt(this.getAttribute('data-col'));
                    let value = this.textContent.trim();
                    
                    // Update data
                    if (!currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet]) {
                        currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet] = Array(30).fill().map(() => Array(15).fill(''));
                    }
                    
                    // If it's a formula, evaluate it
                    if (value.startsWith('=')) {
                        try {
                            const result = evaluateFormula(value, row, col);
                            this.textContent = result;
                            this.setAttribute('data-formula', value);
                            currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet][row][col] = value; // Store formula
                        } catch (error) {
                            this.textContent = '#ERROR!';
                            currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet][row][col] = value;
                        }
                    } else {
                        currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet][row][col] = value;
                        this.removeAttribute('data-formula');
                    }
                    
                    // Recalculate all cells that depend on this cell
                    recalculateDependentCells(row, col);
                    
                    this.classList.remove('excel-cell-selected');
                });
                
                cell.addEventListener('keydown', function(e) {
                    const row = parseInt(this.getAttribute('data-row'));
                    const col = parseInt(this.getAttribute('data-col'));
                    let nextCell = null;
                    
                    // Handle Enter key
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.blur();
                        
                        // Check if we need to expand rows
                        const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
                        if (row >= sheetData.length - 1) {
                            const rowsToAdd = 10;
                            const newCols = sheetData[0]?.length || 15;
                            for (let i = 0; i < rowsToAdd; i++) {
                                sheetData.push(Array(newCols).fill(''));
                            }
                            const gridContainer = document.getElementById('excelGridContainer');
                            if (gridContainer) {
                                gridContainer.innerHTML = renderExcelGrid(sheetData);
                                attachExcelCellListeners();
                            }
                        }
                        
                        // Move to next row (down)
                        nextCell = document.querySelector(`[data-row="${row + 1}"][data-col="${col}"]`);
                        if (nextCell) nextCell.focus();
                        return;
                    }
                    
                    // Handle Tab key
                    if (e.key === 'Tab') {
                        e.preventDefault();
                        this.blur();
                        
                        // Check if we need to expand columns
                        const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
                        const currentCols = sheetData[0]?.length || 0;
                        if (col >= currentCols - 1) {
                            const columnsToAdd = 5;
                            for (let i = 0; i < sheetData.length; i++) {
                                for (let j = 0; j < columnsToAdd; j++) {
                                    sheetData[i].push('');
                                }
                            }
                            const gridContainer = document.getElementById('excelGridContainer');
                            if (gridContainer) {
                                gridContainer.innerHTML = renderExcelGrid(sheetData);
                                attachExcelCellListeners();
                            }
                        }
                        
                        // Move to next column (right)
                        nextCell = document.querySelector(`[data-row="${row}"][data-col="${col + 1}"]`);
                        if (nextCell) nextCell.focus();
                        return;
                    }
                    
                    // Handle Arrow keys
                    if (e.key === 'ArrowUp') {
                        // Don't move up if already in row 1 (row index 0)
                        if (row === 0) {
                            return;
                        }
                        e.preventDefault();
                        this.blur();
                        nextCell = document.querySelector(`[data-row="${row - 1}"][data-col="${col}"]`);
                        if (nextCell) nextCell.focus();
                        return;
                    }
                    
                    if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        this.blur();
                        
                        // Check if we need to expand rows
                        const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
                        if (row >= sheetData.length - 1) {
                            const rowsToAdd = 10;
                            const newCols = sheetData[0]?.length || 15;
                            for (let i = 0; i < rowsToAdd; i++) {
                                sheetData.push(Array(newCols).fill(''));
                            }
                            const gridContainer = document.getElementById('excelGridContainer');
                            if (gridContainer) {
                                gridContainer.innerHTML = renderExcelGrid(sheetData);
                                attachExcelCellListeners();
                            }
                        }
                        
                        nextCell = document.querySelector(`[data-row="${row + 1}"][data-col="${col}"]`);
                        if (nextCell) nextCell.focus();
                        return;
                    }
                    
                    if (e.key === 'ArrowLeft') {
                        // Don't move left if already in column A (col index 0)
                        if (col === 0) {
                            return;
                        }
                        e.preventDefault();
                        this.blur();
                        nextCell = document.querySelector(`[data-row="${row}"][data-col="${col - 1}"]`);
                        if (nextCell) nextCell.focus();
                        return;
                    }
                    
                    if (e.key === 'ArrowRight') {
                        e.preventDefault();
                        this.blur();
                        
                        // Check if we need to expand columns
                        const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
                        const currentCols = sheetData[0]?.length || 0;
                        if (col >= currentCols - 1) {
                            const columnsToAdd = 5;
                            for (let i = 0; i < sheetData.length; i++) {
                                for (let j = 0; j < columnsToAdd; j++) {
                                    sheetData[i].push('');
                                }
                            }
                            const gridContainer = document.getElementById('excelGridContainer');
                            if (gridContainer) {
                                gridContainer.innerHTML = renderExcelGrid(sheetData);
                                attachExcelCellListeners();
                            }
                        }
                        
                        nextCell = document.querySelector(`[data-row="${row}"][data-col="${col + 1}"]`);
                        if (nextCell) nextCell.focus();
                        return;
                    }
                });
            });
            
            // Formula bar input handler
            if (formulaBarInput) {
                formulaBarInput.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        const activeCell = document.querySelector('.excel-data-cell.excel-cell-selected');
                        if (activeCell) {
                            activeCell.textContent = this.value;
                            activeCell.blur(); // This will trigger evaluation
                            activeCell.focus();
                        }
                    }
                });
            }
        }

        function attachExcelSheetTabListeners() {
            const tabs = document.querySelectorAll('.excel-sheet-tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    const sheetName = this.getAttribute('data-sheet');
                    switchExcelSheet(sheetName);
                });
                
                // Double-click to rename sheet
                tab.addEventListener('dblclick', function(e) {
                    e.stopPropagation();
                    const oldName = this.getAttribute('data-sheet');
                    renameExcelSheet(oldName, this);
                });
                
                // Right-click context menu
                tab.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    const sheetName = this.getAttribute('data-sheet');
                    showSheetContextMenu(e, sheetName);
                });
            });
        }

        function switchExcelSheet(sheetName) {
            console.log(`üîÑ Switching to sheet: ${sheetName}`);
            console.log('Available sheets in data:', Object.keys(currentExcelSpreadsheet.data));
            console.log('Has sheet data?', !!currentExcelSpreadsheet.data[sheetName]);
            
            currentExcelSpreadsheet.activeSheet = sheetName;
            
            if (!currentExcelSpreadsheet.data[sheetName]) {
                console.log(`‚ö†Ô∏è No data for ${sheetName}, creating empty sheet`);
                currentExcelSpreadsheet.data[sheetName] = Array(30).fill().map(() => Array(15).fill(''));
            } else {
                console.log(`‚úÖ Found ${currentExcelSpreadsheet.data[sheetName].length} rows for ${sheetName}`);
            }
            
            const gridContainer = document.getElementById('excelGridContainer');
            if (gridContainer) {
                gridContainer.innerHTML = renderExcelGrid(currentExcelSpreadsheet.data[sheetName]);
                attachExcelCellListeners();
                
                // Recalculate all formulas to ensure dependencies are resolved
                setTimeout(() => recalculateAllFormulas(), 10);
            }
            
            updateSheetTabs();
        }

        function updateSheetTabs() {
            const tabsContainer = document.getElementById('excelSheetTabs');
            if (tabsContainer) {
                tabsContainer.innerHTML = renderSheetTabs(currentExcelSpreadsheet.sheets, currentExcelSpreadsheet.activeSheet);
                attachExcelSheetTabListeners();
            }
        }

        function renameExcelSheet(oldName, tabElement) {
            const newName = prompt('Enter new sheet name:', oldName);
            
            if (!newName || newName === oldName) {
                return; // User cancelled or didn't change the name
            }
            
            // Validate new name
            if (newName.trim() === '') {
                alert('Sheet name cannot be empty');
                return;
            }
            
            if (currentExcelSpreadsheet.sheets.includes(newName)) {
                alert('A sheet with this name already exists');
                return;
            }
            
            // Update sheet name in array
            const index = currentExcelSpreadsheet.sheets.indexOf(oldName);
            if (index !== -1) {
                currentExcelSpreadsheet.sheets[index] = newName;
            }
            
            // Update data object
            if (currentExcelSpreadsheet.data[oldName]) {
                currentExcelSpreadsheet.data[newName] = currentExcelSpreadsheet.data[oldName];
                delete currentExcelSpreadsheet.data[oldName];
            }
            
            // Update active sheet if it was the renamed one
            if (currentExcelSpreadsheet.activeSheet === oldName) {
                currentExcelSpreadsheet.activeSheet = newName;
            }
            
            // Update UI
            updateSheetTabs();
        }

        function showSheetContextMenu(event, sheetName) {
            // Remove any existing context menu
            const existingMenu = document.getElementById('excelSheetContextMenu');
            if (existingMenu) {
                existingMenu.remove();
            }
            
            // Create context menu
            const menu = document.createElement('div');
            menu.id = 'excelSheetContextMenu';
            menu.style.position = 'fixed';
            menu.style.left = event.clientX + 'px';
            menu.style.top = event.clientY + 'px';
            menu.style.background = 'rgba(30, 41, 59, 0.95)';
            menu.style.border = '1px solid rgba(99, 102, 241, 0.5)';
            menu.style.borderRadius = '8px';
            menu.style.padding = '8px 0';
            menu.style.zIndex = '10000';
            menu.style.minWidth = '150px';
            menu.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.3)';
            
            const menuItems = [
                {
                    label: '‚úèÔ∏è Rename',
                    action: () => {
                        const tab = document.querySelector(`.excel-sheet-tab[data-sheet="${sheetName}"]`);
                        if (tab) renameExcelSheet(sheetName, tab);
                    }
                },
                {
                    label: 'üóëÔ∏è Delete',
                    action: () => deleteExcelSheet(sheetName)
                }
            ];
            
            menuItems.forEach(item => {
                const menuItem = document.createElement('div');
                menuItem.textContent = item.label;
                menuItem.style.padding = '8px 16px';
                menuItem.style.cursor = 'pointer';
                menuItem.style.color = 'white';
                menuItem.style.fontSize = '13px';
                menuItem.style.transition = 'background 0.2s';
                
                menuItem.addEventListener('mouseenter', () => {
                    menuItem.style.background = 'rgba(99, 102, 241, 0.3)';
                });
                
                menuItem.addEventListener('mouseleave', () => {
                    menuItem.style.background = 'transparent';
                });
                
                menuItem.addEventListener('click', () => {
                    item.action();
                    menu.remove();
                });
                
                menu.appendChild(menuItem);
            });
            
            document.body.appendChild(menu);
            
            // Close menu when clicking elsewhere
            const closeMenu = (e) => {
                if (!menu.contains(e.target)) {
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                }
            };
            
            setTimeout(() => {
                document.addEventListener('click', closeMenu);
            }, 100);
        }

        function deleteExcelSheet(sheetName) {
            if (currentExcelSpreadsheet.sheets.length <= 1) {
                alert('Cannot delete the last sheet');
                return;
            }
            
            if (!confirm(`Are you sure you want to delete sheet "${sheetName}"?`)) {
                return;
            }
            
            // Remove from sheets array
            const index = currentExcelSpreadsheet.sheets.indexOf(sheetName);
            if (index !== -1) {
                currentExcelSpreadsheet.sheets.splice(index, 1);
            }
            
            // Remove data
            if (currentExcelSpreadsheet.data[sheetName]) {
                delete currentExcelSpreadsheet.data[sheetName];
            }
            
            // If deleted sheet was active, switch to first sheet
            if (currentExcelSpreadsheet.activeSheet === sheetName) {
                switchExcelSheet(currentExcelSpreadsheet.sheets[0]);
            } else {
                updateSheetTabs();
            }
        }

        async function saveExcelSpreadsheet() {
            if (!currentExcelSpreadsheet.filePath) {
                alert('No spreadsheet to save');
                return;
            }
            
            const saveBtn = document.getElementById('excelEditorSave');
            if (saveBtn) {
                saveBtn.disabled = true;
                saveBtn.textContent = 'üíæ Saving...';
            }
            
            try {
                // Capture current cell data before saving
                captureCurrentCellData();
                
                console.log('=== EXCEL SAVE DEBUG ===');
                console.log('File path:', currentExcelSpreadsheet.filePath);
                console.log('Sheets:', currentExcelSpreadsheet.sheets);
                console.log('Active sheet:', currentExcelSpreadsheet.activeSheet);
                console.log('Data keys:', Object.keys(currentExcelSpreadsheet.data));
                
                // Log sample data from each sheet
                for (const [sheetName, sheetData] of Object.entries(currentExcelSpreadsheet.data)) {
                    const nonEmptyRows = sheetData.filter(row => row.some(cell => cell !== ''));
                    const totalCells = sheetData.reduce((sum, row) => sum + row.filter(cell => cell !== '').length, 0);
                    console.log(`Sheet "${sheetName}": ${nonEmptyRows.length} non-empty rows, ${totalCells} cells with data`);
                }
                
                const response = await fetch('http://localhost:8000/api/excel/save', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        file_path: currentExcelSpreadsheet.filePath,
                        data: currentExcelSpreadsheet.data
                    })
                });

                const data = await response.json();
                console.log('Save response:', data);
                
                if (response.ok && data.success) {
                    if (saveBtn) {
                        saveBtn.textContent = 'üíæ Saved!';
                        setTimeout(() => {
                            if (saveBtn) {
                                saveBtn.textContent = 'üíæ Save';
                                saveBtn.disabled = false;
                            }
                        }, 2000);
                    }
                    alert(`Spreadsheet saved successfully!\n\nFile: ${data.file_path}\nSheets: ${data.sheets ? data.sheets.join(', ') : 'N/A'}`);
                } else {
                    throw new Error(data.detail || data.message || data.error || 'Failed to save spreadsheet');
                }
            } catch (error) {
                console.error('Error saving spreadsheet:', error);
                alert('Error saving spreadsheet: ' + error.message);
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.textContent = 'üíæ Save';
                }
            }
        }

        function captureCurrentCellData() {
            // Capture data from all visible cells in the current sheet
            const cells = document.querySelectorAll('.excel-data-cell');
            cells.forEach(cell => {
                const row = parseInt(cell.getAttribute('data-row'));
                const col = parseInt(cell.getAttribute('data-col'));
                const formula = cell.getAttribute('data-formula');
                const value = formula || cell.textContent.trim();
                
                // Ensure the sheet data array exists
                if (!currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet]) {
                    currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet] = Array(30).fill().map(() => Array(15).fill(''));
                }
                
                // Update the value (store formula if exists, otherwise value)
                if (currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet][row]) {
                    currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet][row][col] = value;
                }
            });
        }

        // Extract cell references from a formula
        function extractCellReferences(formula) {
            const references = new Set();
            if (!formula || !formula.startsWith('=')) return references;
            
            // Remove the leading =
            const formulaText = formula.substring(1).toUpperCase();
            
            // Match individual cell references (e.g., A1, B2, AA10)
            const cellRegex = /([A-Z]+)(\d+)(?![:\d])/g;
            let match;
            while ((match = cellRegex.exec(formulaText)) !== null) {
                references.add(`${match[1]}${match[2]}`);
            }
            
            // Match range references (e.g., A1:B10)
            const rangeRegex = /([A-Z]+\d+):([A-Z]+\d+)/g;
            while ((match = rangeRegex.exec(formulaText)) !== null) {
                const startCell = match[1];
                const endCell = match[2];
                
                // Parse start and end cells
                const startMatch = startCell.match(/([A-Z]+)(\d+)/);
                const endMatch = endCell.match(/([A-Z]+)(\d+)/);
                
                if (startMatch && endMatch) {
                    const startCol = columnLetterToIndex(startMatch[1]);
                    const startRow = parseInt(startMatch[2]) - 1;
                    const endCol = columnLetterToIndex(endMatch[1]);
                    const endRow = parseInt(endMatch[2]) - 1;
                    
                    // Add all cells in the range
                    for (let r = startRow; r <= endRow; r++) {
                        for (let c = startCol; c <= endCol; c++) {
                            const colLetter = indexToColumnLetter(c);
                            references.add(`${colLetter}${r + 1}`);
                        }
                    }
                }
            }
            
            return references;
        }
        
        // Convert column index to letter (e.g., 0 -> A, 25 -> Z, 26 -> AA)
        function indexToColumnLetter(index) {
            let letter = '';
            while (index >= 0) {
                letter = String.fromCharCode(65 + (index % 26)) + letter;
                index = Math.floor(index / 26) - 1;
            }
            return letter;
        }
        
        // Find all cells that depend on the given cell
        function findDependentCells(targetRow, targetCol) {
            const dependents = [];
            const targetCellRef = `${indexToColumnLetter(targetCol)}${targetRow + 1}`;
            const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
            
            if (!sheetData) return dependents;
            
            // Check all cells in the sheet
            for (let row = 0; row < sheetData.length; row++) {
                for (let col = 0; col < sheetData[row].length; col++) {
                    const cellValue = sheetData[row][col];
                    
                    // Skip if not a formula
                    if (!cellValue || !cellValue.startsWith('=')) continue;
                    
                    // Check if this formula references the target cell
                    const references = extractCellReferences(cellValue);
                    if (references.has(targetCellRef)) {
                        dependents.push({ row, col, formula: cellValue });
                    }
                }
            }
            
            return dependents;
        }
        
        // Recalculate all cells that depend on the changed cell
        function recalculateDependentCells(changedRow, changedCol, visited = new Set()) {
            // Create a unique key for this cell to prevent circular dependencies
            const cellKey = `${changedRow},${changedCol}`;
            if (visited.has(cellKey)) {
                console.warn('Circular reference detected at', cellKey);
                return;
            }
            visited.add(cellKey);
            
            // Find all cells that depend on this cell
            const dependents = findDependentCells(changedRow, changedCol);
            
            // Recalculate each dependent cell
            for (const dependent of dependents) {
                const cell = document.querySelector(`[data-row="${dependent.row}"][data-col="${dependent.col}"]`);
                if (cell && cell.hasAttribute('data-formula')) {
                    const formula = cell.getAttribute('data-formula');
                    
                    try {
                        const result = evaluateFormula(formula, dependent.row, dependent.col);
                        cell.textContent = result;
                        
                        // Recursively recalculate cells that depend on this one
                        recalculateDependentCells(dependent.row, dependent.col, visited);
                    } catch (error) {
                        console.error('Error recalculating cell', dependent.row, dependent.col, error);
                        cell.textContent = '#ERROR!';
                    }
                }
            }
        }
        
        // Recalculate all formulas in the current sheet
        // This is useful after loading a spreadsheet or switching sheets
        function recalculateAllFormulas() {
            const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
            if (!sheetData) return;
            
            // Build a list of all cells with formulas
            const formulaCells = [];
            for (let row = 0; row < sheetData.length; row++) {
                for (let col = 0; col < sheetData[row].length; col++) {
                    const value = sheetData[row][col];
                    if (value && typeof value === 'string' && value.startsWith('=')) {
                        formulaCells.push({ row, col, formula: value });
                    }
                }
            }
            
            // Calculate dependency depth for each formula (how many other formulas it depends on)
            // This helps us evaluate them in the right order
            const maxIterations = 10; // Prevent infinite loops
            let iteration = 0;
            let hasChanges = true;
            
            while (hasChanges && iteration < maxIterations) {
                hasChanges = false;
                iteration++;
                
                for (const formulaCell of formulaCells) {
                    const cell = document.querySelector(`[data-row="${formulaCell.row}"][data-col="${formulaCell.col}"]`);
                    if (cell) {
                        try {
                            const oldValue = cell.textContent;
                            const newValue = evaluateFormula(formulaCell.formula, formulaCell.row, formulaCell.col);
                            
                            if (oldValue !== String(newValue)) {
                                cell.textContent = newValue;
                                hasChanges = true;
                            }
                        } catch (error) {
                            cell.textContent = '#ERROR!';
                        }
                    }
                }
            }
            
            if (iteration >= maxIterations) {
                console.warn('Recalculation stopped after', maxIterations, 'iterations. Possible circular reference.');
            }
        }

        function evaluateFormula(formula, currentRow, currentCol) {
            try {
                // Remove leading =
                let originalFormula = formula;
                formula = formula.substring(1).trim();
                
                // Store original case for text functions
                const upperFormula = formula.toUpperCase();
                
                console.log('Evaluating formula:', originalFormula);
                
                // TODAY, NOW - handle first (no parameters)
                if (upperFormula === 'TODAY()') {
                    return new Date().toLocaleDateString();
                }
                if (upperFormula === 'NOW()') {
                    return new Date().toLocaleString();
                }
                
                // Handle range functions BEFORE replacing cell references
                if (upperFormula.match(/\b(SUM|AVERAGE|COUNT|COUNTA|MAX|MIN|PRODUCT)\(/)) {
                    const result = evaluateRangeFunction(upperFormula);
                    console.log('Range function result:', result);
                    return result;
                }
                
                // Handle text functions with cell references
                if (upperFormula.match(/\b(LEN|UPPER|LOWER|TRIM)\(/)) {
                    // Replace cell references first for text functions
                    let textFormula = upperFormula.replace(/([A-Z]+)(\d+)/g, (match, col, row) => {
                        const colIndex = columnLetterToIndex(col);
                        const rowIndex = parseInt(row) - 1;
                        const value = getCellValue(rowIndex, colIndex);
                        return `"${value}"`;
                    });
                    return evaluateTextFunction(textFormula);
                }
                
                // LEFT, RIGHT, MID with cell references
                if (upperFormula.match(/\b(LEFT|RIGHT|MID)\(/)) {
                    let textFormula = upperFormula.replace(/([A-Z]+)(\d+)(?![:\d])/g, (match, col, row) => {
                        const colIndex = columnLetterToIndex(col);
                        const rowIndex = parseInt(row) - 1;
                        const value = getCellValue(rowIndex, colIndex);
                        return `"${value}"`;
                    });
                    return evaluateTextFunction(textFormula);
                }
                
                // CONCATENATE, CONCAT
                if (upperFormula.includes('CONCATENATE(') || upperFormula.includes('CONCAT(')) {
                    let concatFormula = upperFormula.replace(/([A-Z]+)(\d+)/g, (match, col, row) => {
                        const colIndex = columnLetterToIndex(col);
                        const rowIndex = parseInt(row) - 1;
                        const value = getCellValue(rowIndex, colIndex);
                        return `"${value}"`;
                    });
                    return evaluateConcatenate(concatFormula);
                }
                
                // ROUND, ROUNDUP, ROUNDDOWN
                if (upperFormula.match(/\b(ROUND|ROUNDUP|ROUNDDOWN)\(/)) {
                    let roundFormula = upperFormula.replace(/([A-Z]+)(\d+)/g, (match, col, row) => {
                        const colIndex = columnLetterToIndex(col);
                        const rowIndex = parseInt(row) - 1;
                        const value = getCellValue(rowIndex, colIndex);
                        return value || '0';
                    });
                    return evaluateRoundFunction(roundFormula);
                }
                
                // Handle IF function
                if (upperFormula.includes('IF(')) {
                    let ifFormula = upperFormula.replace(/([A-Z]+)(\d+)/g, (match, col, row) => {
                        const colIndex = columnLetterToIndex(col);
                        const rowIndex = parseInt(row) - 1;
                        const value = getCellValue(rowIndex, colIndex);
                        return isNaN(value) ? `"${value}"` : (value || '0');
                    });
                    return evaluateIfFunction(ifFormula);
                }
                
                // Handle AND, OR, NOT
                if (upperFormula.match(/\b(AND|OR|NOT)\(/)) {
                    let logicalFormula = upperFormula.replace(/([A-Z]+)(\d+)/g, (match, col, row) => {
                        const colIndex = columnLetterToIndex(col);
                        const rowIndex = parseInt(row) - 1;
                        const value = getCellValue(rowIndex, colIndex);
                        return value || '0';
                    });
                    return evaluateLogicalFunction(logicalFormula);
                }
                
                // Handle simple cell references and mathematical expressions
                formula = upperFormula.replace(/([A-Z]+)(\d+)/g, (match, col, row) => {
                    const colIndex = columnLetterToIndex(col);
                    const rowIndex = parseInt(row) - 1;
                    const value = getCellValue(rowIndex, colIndex);
                    return value || '0';
                });
                
                // Evaluate mathematical expression
                // Replace Excel operators with JavaScript operators
                formula = formula.replace(/\^/g, '**'); // Power
                
                // Evaluate the expression
                const result = Function('"use strict"; return (' + formula + ')')();
                console.log('Math result:', result);
                return isNaN(result) ? '#VALUE!' : (Math.round(result * 100000000) / 100000000);
            } catch (error) {
                console.error('Formula evaluation error:', error, 'Formula:', formula);
                return '#ERROR!';
            }
        }

        function evaluateRangeFunction(formula) {
            // Extract function name and range
            const match = formula.match(/(SUM|AVERAGE|COUNT|COUNTA|MAX|MIN|PRODUCT)\(([A-Z]+\d+):([A-Z]+\d+)\)/);
            if (!match) return '#REF!';
            
            const [, func, startCell, endCell] = match;
            const values = getRangeValues(startCell, endCell);
            const allValues = getRangeValues(startCell, endCell, true); // Include text for COUNTA
            
            if (func === 'COUNTA') {
                return allValues.length;
            }
            
            if (values.length === 0) return func === 'COUNT' ? 0 : '#DIV/0!';
            
            switch (func) {
                case 'SUM':
                    return values.reduce((sum, val) => sum + val, 0);
                case 'AVERAGE':
                    return values.reduce((sum, val) => sum + val, 0) / values.length;
                case 'COUNT':
                    return values.length;
                case 'MAX':
                    return Math.max(...values);
                case 'MIN':
                    return Math.min(...values);
                case 'PRODUCT':
                    return values.reduce((product, val) => product * val, 1);
                default:
                    return '#NAME?';
            }
        }

        function evaluateConcatenate(formula) {
            const match = formula.match(/(?:CONCATENATE|CONCAT)\((.+)\)/i);
            if (!match) return '#VALUE!';
            
            const args = match[1].split(',').map(arg => arg.trim().replace(/^"|"$/g, ''));
            return args.join('');
        }

        function evaluateTextFunction(formula) {
            const upperFormula = formula.toUpperCase();
            
            // LEN(text)
            let match = upperFormula.match(/LEN\((.+)\)/);
            if (match) {
                const text = match[1].replace(/^"|"$/g, '');
                return text.length;
            }
            
            // UPPER(text)
            match = upperFormula.match(/UPPER\((.+)\)/);
            if (match) {
                const text = match[1].replace(/^"|"$/g, '');
                return text.toUpperCase();
            }
            
            // LOWER(text)
            match = upperFormula.match(/LOWER\((.+)\)/);
            if (match) {
                const text = match[1].replace(/^"|"$/g, '');
                return text.toLowerCase();
            }
            
            // TRIM(text)
            match = upperFormula.match(/TRIM\((.+)\)/);
            if (match) {
                const text = match[1].replace(/^"|"$/g, '');
                return text.trim();
            }
            
            // LEFT(text, num_chars)
            match = upperFormula.match(/LEFT\((.+),(\d+)\)/);
            if (match) {
                const text = match[1].replace(/^"|"$/g, '');
                const num = parseInt(match[2]);
                return text.substring(0, num);
            }
            
            // RIGHT(text, num_chars)
            match = upperFormula.match(/RIGHT\((.+),(\d+)\)/);
            if (match) {
                const text = match[1].replace(/^"|"$/g, '');
                const num = parseInt(match[2]);
                return text.substring(text.length - num);
            }
            
            // MID(text, start, num_chars)
            match = upperFormula.match(/MID\((.+),(\d+),(\d+)\)/);
            if (match) {
                const text = match[1].replace(/^"|"$/g, '');
                const start = parseInt(match[2]) - 1; // Excel is 1-indexed
                const num = parseInt(match[3]);
                return text.substring(start, start + num);
            }
            
            return '#VALUE!';
        }

        function evaluateRoundFunction(formula) {
            const upperFormula = formula.toUpperCase();
            
            // ROUND(number, num_digits)
            let match = upperFormula.match(/ROUND\((.+),(\d+)\)/);
            if (match) {
                const num = parseFloat(match[1]);
                const digits = parseInt(match[2]);
                return Math.round(num * Math.pow(10, digits)) / Math.pow(10, digits);
            }
            
            // ROUNDUP(number, num_digits)
            match = upperFormula.match(/ROUNDUP\((.+),(\d+)\)/);
            if (match) {
                const num = parseFloat(match[1]);
                const digits = parseInt(match[2]);
                return Math.ceil(num * Math.pow(10, digits)) / Math.pow(10, digits);
            }
            
            // ROUNDDOWN(number, num_digits)
            match = upperFormula.match(/ROUNDDOWN\((.+),(\d+)\)/);
            if (match) {
                const num = parseFloat(match[1]);
                const digits = parseInt(match[2]);
                return Math.floor(num * Math.pow(10, digits)) / Math.pow(10, digits);
            }
            
            return '#VALUE!';
        }

        function evaluateLogicalFunction(formula) {
            // AND(logical1, logical2, ...)
            let match = formula.match(/AND\((.+)\)/);
            if (match) {
                const args = match[1].split(',').map(arg => {
                    try {
                        return Function('"use strict"; return (' + arg.trim() + ')')();
                    } catch {
                        return false;
                    }
                });
                return args.every(val => val) ? 'TRUE' : 'FALSE';
            }
            
            // OR(logical1, logical2, ...)
            match = formula.match(/OR\((.+)\)/);
            if (match) {
                const args = match[1].split(',').map(arg => {
                    try {
                        return Function('"use strict"; return (' + arg.trim() + ')')();
                    } catch {
                        return false;
                    }
                });
                return args.some(val => val) ? 'TRUE' : 'FALSE';
            }
            
            // NOT(logical)
            match = formula.match(/NOT\((.+)\)/);
            if (match) {
                try {
                    const result = Function('"use strict"; return (' + match[1].trim() + ')')();
                    return !result ? 'TRUE' : 'FALSE';
                } catch {
                    return '#VALUE!';
                }
            }
            
            return '#VALUE!';
        }

        function evaluateIfFunction(formula) {
            // Simple IF(condition, true_value, false_value)
            const match = formula.match(/IF\((.+),(.+),(.+)\)/);
            if (!match) return '#VALUE!';
            
            const [, condition, trueVal, falseVal] = match;
            
            try {
                const conditionResult = Function('"use strict"; return (' + condition + ')')();
                return conditionResult ? trueVal.trim() : falseVal.trim();
            } catch (error) {
                return '#ERROR!';
            }
        }

        function getRangeValues(startCell, endCell, includeText = false) {
            const startMatch = startCell.match(/([A-Z]+)(\d+)/);
            const endMatch = endCell.match(/([A-Z]+)(\d+)/);
            
            if (!startMatch || !endMatch) return [];
            
            const startCol = columnLetterToIndex(startMatch[1]);
            const startRow = parseInt(startMatch[2]) - 1;
            const endCol = columnLetterToIndex(endMatch[1]);
            const endRow = parseInt(endMatch[2]) - 1;
            
            const values = [];
            for (let row = startRow; row <= endRow; row++) {
                for (let col = startCol; col <= endCol; col++) {
                    const value = getCellValue(row, col);
                    if (value !== '') {
                        if (includeText) {
                            values.push(value);
                        } else if (!isNaN(value)) {
                            values.push(parseFloat(value));
                        }
                    }
                }
            }
            
            return values;
        }

        function getCellValue(row, col) {
            const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
            if (!sheetData || !sheetData[row] || !sheetData[row][col]) return '';
            
            const value = sheetData[row][col];
            
            // If it's a formula, get the displayed value from the cell
            if (typeof value === 'string' && value.startsWith('=')) {
                const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                return cell ? cell.textContent.trim() : '';
            }
            
            return value;
        }

        function columnLetterToIndex(letter) {
            let index = 0;
            for (let i = 0; i < letter.length; i++) {
                index = index * 26 + (letter.charCodeAt(i) - 64);
            }
            return index - 1;
        }

        // Clipboard for Excel operations
        let excelClipboard = {
            data: [],
            isCut: false,
            sourceRange: null
        };
        
        // Undo/Redo stacks
        let excelUndoStack = [];
        let excelRedoStack = [];
        const MAX_UNDO_STACK = 50;
        
        // Multi-selection state
        let excelSelection = {
            start: null,
            end: null,
            cells: new Set()
        };
        
        // Save state for undo/redo
        function saveExcelState(description) {
            const state = {
                description: description,
                sheet: currentExcelSpreadsheet.activeSheet,
                data: JSON.parse(JSON.stringify(currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet]))
            };
            
            excelUndoStack.push(state);
            if (excelUndoStack.length > MAX_UNDO_STACK) {
                excelUndoStack.shift();
            }
            
            // Clear redo stack when a new action is performed
            excelRedoStack = [];
        }
        
        // Undo last action
        function undoExcel() {
            if (excelUndoStack.length === 0) {
                console.log('Nothing to undo');
                return;
            }
            
            const currentState = {
                description: 'Current state',
                sheet: currentExcelSpreadsheet.activeSheet,
                data: JSON.parse(JSON.stringify(currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet]))
            };
            excelRedoStack.push(currentState);
            
            const previousState = excelUndoStack.pop();
            currentExcelSpreadsheet.data[previousState.sheet] = previousState.data;
            
            const gridContainer = document.getElementById('excelGridContainer');
            if (gridContainer) {
                gridContainer.innerHTML = renderExcelGrid(previousState.data);
                attachExcelCellListeners();
                setTimeout(() => recalculateAllFormulas(), 10);
            }
            
            console.log('Undo:', previousState.description);
        }
        
        // Redo last undone action
        function redoExcel() {
            if (excelRedoStack.length === 0) {
                console.log('Nothing to redo');
                return;
            }
            
            const currentState = {
                description: 'Current state',
                sheet: currentExcelSpreadsheet.activeSheet,
                data: JSON.parse(JSON.stringify(currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet]))
            };
            excelUndoStack.push(currentState);
            
            const nextState = excelRedoStack.pop();
            currentExcelSpreadsheet.data[nextState.sheet] = nextState.data;
            
            const gridContainer = document.getElementById('excelGridContainer');
            if (gridContainer) {
                gridContainer.innerHTML = renderExcelGrid(nextState.data);
                attachExcelCellListeners();
                setTimeout(() => recalculateAllFormulas(), 10);
            }
            
            console.log('Redo:', nextState.description);
        }
        
        // Copy selected cells
        function copyExcelCells() {
            const selectedCells = document.querySelectorAll('.excel-data-cell.excel-cell-selected');
            if (selectedCells.length === 0) return;
            
            excelClipboard.data = [];
            excelClipboard.isCut = false;
            
            // Get the range of selected cells
            let minRow = Infinity, maxRow = -Infinity;
            let minCol = Infinity, maxCol = -Infinity;
            
            selectedCells.forEach(cell => {
                const row = parseInt(cell.getAttribute('data-row'));
                const col = parseInt(cell.getAttribute('data-col'));
                minRow = Math.min(minRow, row);
                maxRow = Math.max(maxRow, row);
                minCol = Math.min(minCol, col);
                maxCol = Math.max(maxCol, col);
            });
            
            // Store the data in a 2D array
            for (let r = minRow; r <= maxRow; r++) {
                const rowData = [];
                for (let c = minCol; c <= maxCol; c++) {
                    const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                    const formula = cell ? cell.getAttribute('data-formula') : null;
                    const value = formula || (cell ? cell.textContent.trim() : '');
                    rowData.push(value);
                }
                excelClipboard.data.push(rowData);
            }
            
            excelClipboard.sourceRange = { minRow, maxRow, minCol, maxCol };
            
            // Visual feedback
            document.querySelectorAll('.excel-cell-copied').forEach(cell => {
                cell.classList.remove('excel-cell-copied');
            });
            selectedCells.forEach(cell => {
                cell.classList.add('excel-cell-copied');
            });
            
            console.log('Copied', selectedCells.length, 'cells');
        }
        
        // Cut selected cells
        function cutExcelCells() {
            copyExcelCells();
            excelClipboard.isCut = true;
            
            // Visual feedback for cut
            document.querySelectorAll('.excel-cell-cut').forEach(cell => {
                cell.classList.remove('excel-cell-cut');
            });
            document.querySelectorAll('.excel-cell-copied').forEach(cell => {
                cell.classList.remove('excel-cell-copied');
                cell.classList.add('excel-cell-cut');
            });
            
            console.log('Cut', document.querySelectorAll('.excel-cell-cut').length, 'cells');
        }
        
        // Paste cells
        function pasteExcelCells() {
            if (excelClipboard.data.length === 0) return;
            
            const activeCell = document.querySelector('.excel-data-cell.excel-cell-selected');
            if (!activeCell) return;
            
            saveExcelState('Paste');
            
            const startRow = parseInt(activeCell.getAttribute('data-row'));
            const startCol = parseInt(activeCell.getAttribute('data-col'));
            const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
            
            // Paste the data
            for (let r = 0; r < excelClipboard.data.length; r++) {
                for (let c = 0; c < excelClipboard.data[r].length; c++) {
                    const targetRow = startRow + r;
                    const targetCol = startCol + c;
                    
                    // Expand sheet if necessary
                    while (targetRow >= sheetData.length) {
                        sheetData.push(Array(sheetData[0]?.length || 15).fill(''));
                    }
                    while (targetCol >= sheetData[0].length) {
                        sheetData.forEach(row => row.push(''));
                    }
                    
                    const value = excelClipboard.data[r][c];
                    sheetData[targetRow][targetCol] = value;
                    
                    // Update the cell in the DOM
                    const cell = document.querySelector(`[data-row="${targetRow}"][data-col="${targetCol}"]`);
                    if (cell) {
                        if (value.startsWith('=')) {
                            try {
                                const result = evaluateFormula(value, targetRow, targetCol);
                                cell.textContent = result;
                                cell.setAttribute('data-formula', value);
                            } catch (error) {
                                cell.textContent = '#ERROR!';
                                cell.setAttribute('data-formula', value);
                            }
                        } else {
                            cell.textContent = value;
                            cell.removeAttribute('data-formula');
                        }
                    }
                }
            }
            
            // If it was cut, clear the source cells
            if (excelClipboard.isCut) {
                const { minRow, maxRow, minCol, maxCol } = excelClipboard.sourceRange;
                for (let r = minRow; r <= maxRow; r++) {
                    for (let c = minCol; c <= maxCol; c++) {
                        sheetData[r][c] = '';
                        const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                        if (cell) {
                            cell.textContent = '';
                            cell.removeAttribute('data-formula');
                        }
                    }
                }
                excelClipboard.isCut = false;
            }
            
            // Clear visual feedback
            document.querySelectorAll('.excel-cell-copied, .excel-cell-cut').forEach(cell => {
                cell.classList.remove('excel-cell-copied', 'excel-cell-cut');
            });
            
            // Recalculate formulas
            setTimeout(() => recalculateAllFormulas(), 10);
            
            // Re-render the grid if it expanded
            const gridContainer = document.getElementById('excelGridContainer');
            if (gridContainer) {
                gridContainer.innerHTML = renderExcelGrid(sheetData);
                attachExcelCellListeners();
            }
            
            console.log('Pasted', excelClipboard.data.length * excelClipboard.data[0].length, 'cells');
        }
        
        // Delete cell content
        function deleteExcelCellContent() {
            const selectedCells = document.querySelectorAll('.excel-data-cell.excel-cell-selected');
            if (selectedCells.length === 0) return;
            
            saveExcelState('Delete');
            
            selectedCells.forEach(cell => {
                const row = parseInt(cell.getAttribute('data-row'));
                const col = parseInt(cell.getAttribute('data-col'));
                
                currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet][row][col] = '';
                cell.textContent = '';
                cell.removeAttribute('data-formula');
                
                // Recalculate dependent cells
                recalculateDependentCells(row, col);
            });
            
            console.log('Deleted content of', selectedCells.length, 'cells');
        }
        
        // Fill down (Ctrl+D)
        function fillDown() {
            const selectedCells = Array.from(document.querySelectorAll('.excel-data-cell.excel-cell-selected'));
            if (selectedCells.length < 2) return;
            
            saveExcelState('Fill Down');
            
            // Get the range
            let minRow = Infinity, maxRow = -Infinity;
            let minCol = Infinity, maxCol = -Infinity;
            
            selectedCells.forEach(cell => {
                const row = parseInt(cell.getAttribute('data-row'));
                const col = parseInt(cell.getAttribute('data-col'));
                minRow = Math.min(minRow, row);
                maxRow = Math.max(maxRow, row);
                minCol = Math.min(minCol, col);
                maxCol = Math.max(maxCol, col);
            });
            
            const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
            
            // Fill down each column
            for (let c = minCol; c <= maxCol; c++) {
                const sourceValue = sheetData[minRow][c];
                
                for (let r = minRow + 1; r <= maxRow; r++) {
                    sheetData[r][c] = sourceValue;
                    
                    const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                    if (cell) {
                        if (sourceValue.startsWith('=')) {
                            try {
                                const result = evaluateFormula(sourceValue, r, c);
                                cell.textContent = result;
                                cell.setAttribute('data-formula', sourceValue);
                            } catch (error) {
                                cell.textContent = '#ERROR!';
                            }
                        } else {
                            cell.textContent = sourceValue;
                            cell.removeAttribute('data-formula');
                        }
                    }
                }
            }
            
            setTimeout(() => recalculateAllFormulas(), 10);
            console.log('Filled down');
        }
        
        // Fill right (Ctrl+R)
        function fillRight() {
            const selectedCells = Array.from(document.querySelectorAll('.excel-data-cell.excel-cell-selected'));
            if (selectedCells.length < 2) return;
            
            saveExcelState('Fill Right');
            
            // Get the range
            let minRow = Infinity, maxRow = -Infinity;
            let minCol = Infinity, maxCol = -Infinity;
            
            selectedCells.forEach(cell => {
                const row = parseInt(cell.getAttribute('data-row'));
                const col = parseInt(cell.getAttribute('data-col'));
                minRow = Math.min(minRow, row);
                maxRow = Math.max(maxRow, row);
                minCol = Math.min(minCol, col);
                maxCol = Math.max(maxCol, col);
            });
            
            const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
            
            // Fill right each row
            for (let r = minRow; r <= maxRow; r++) {
                const sourceValue = sheetData[r][minCol];
                
                for (let c = minCol + 1; c <= maxCol; c++) {
                    sheetData[r][c] = sourceValue;
                    
                    const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                    if (cell) {
                        if (sourceValue.startsWith('=')) {
                            try {
                                const result = evaluateFormula(sourceValue, r, c);
                                cell.textContent = result;
                                cell.setAttribute('data-formula', sourceValue);
                            } catch (error) {
                                cell.textContent = '#ERROR!';
                            }
                        } else {
                            cell.textContent = sourceValue;
                            cell.removeAttribute('data-formula');
                        }
                    }
                }
            }
            
            setTimeout(() => recalculateAllFormulas(), 10);
            console.log('Filled right');
        }
        
        // Select all cells
        function selectAllCells() {
            const cells = document.querySelectorAll('.excel-data-cell');
            cells.forEach(cell => {
                cell.classList.add('excel-cell-selected');
            });
            console.log('Selected all cells');
        }
        
        // Find dialog
        function openFindDialog() {
            const searchTerm = prompt('Find:');
            if (!searchTerm) return;
            
            const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
            let found = false;
            
            for (let r = 0; r < sheetData.length; r++) {
                for (let c = 0; c < sheetData[r].length; c++) {
                    const value = String(sheetData[r][c]).toLowerCase();
                    if (value.includes(searchTerm.toLowerCase())) {
                        const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                        if (cell) {
                            // Clear previous selections
                            document.querySelectorAll('.excel-cell-selected').forEach(c => {
                                c.classList.remove('excel-cell-selected');
                            });
                            
                            cell.classList.add('excel-cell-selected');
                            cell.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            cell.focus();
                            found = true;
                            return;
                        }
                    }
                }
            }
            
            if (!found) {
                alert(`"${searchTerm}" not found`);
            }
        }
        
        // Show context menu
        function showExcelContextMenu(x, y, row, col) {
            // Remove existing context menu if any
            const existingMenu = document.getElementById('excelContextMenu');
            if (existingMenu) {
                existingMenu.remove();
            }
            
            const menu = document.createElement('div');
            menu.id = 'excelContextMenu';
            menu.style.position = 'fixed';
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.style.background = 'rgba(30, 41, 59, 0.98)';
            menu.style.border = '1px solid rgba(99, 102, 241, 0.3)';
            menu.style.borderRadius = '8px';
            menu.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.3)';
            menu.style.zIndex = '10000';
            menu.style.minWidth = '200px';
            menu.style.padding = '4px';
            
            const menuItems = [
                { label: 'Insert Row Above', action: () => insertRowAbove(row) },
                { label: 'Insert Row Below', action: () => insertRowBelow(row) },
                { label: 'Delete Row', action: () => deleteRow(row) },
                { label: '---', action: null },
                { label: 'Insert Column Left', action: () => insertColumnLeft(col) },
                { label: 'Insert Column Right', action: () => insertColumnRight(col) },
                { label: 'Delete Column', action: () => deleteColumn(col) },
                { label: '---', action: null },
                { label: 'Sort Ascending', action: () => sortColumn(col, 'asc') },
                { label: 'Sort Descending', action: () => sortColumn(col, 'desc') }
            ];
            
            menuItems.forEach(item => {
                if (item.label === '---') {
                    const separator = document.createElement('div');
                    separator.style.height = '1px';
                    separator.style.background = 'rgba(255, 255, 255, 0.1)';
                    separator.style.margin = '4px 0';
                    menu.appendChild(separator);
                } else {
                    const menuItem = document.createElement('div');
                    menuItem.textContent = item.label;
                    menuItem.style.padding = '8px 12px';
                    menuItem.style.cursor = 'pointer';
                    menuItem.style.color = '#e2e8f0';
                    menuItem.style.fontSize = '13px';
                    menuItem.style.borderRadius = '4px';
                    menuItem.style.transition = 'all 0.2s';
                    
                    menuItem.addEventListener('mouseenter', function() {
                        this.style.background = 'rgba(99, 102, 241, 0.3)';
                    });
                    
                    menuItem.addEventListener('mouseleave', function() {
                        this.style.background = 'transparent';
                    });
                    
                    menuItem.addEventListener('click', function() {
                        item.action();
                        menu.remove();
                    });
                    
                    menu.appendChild(menuItem);
                }
            });
            
            document.body.appendChild(menu);
            
            // Close menu when clicking outside
            setTimeout(() => {
                document.addEventListener('click', function closeMenu() {
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                }, 100);
            });
        }
        
        // Insert row above
        function insertRowAbove(row) {
            saveExcelState('Insert Row Above');
            const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
            const newRow = Array(sheetData[0].length).fill('');
            sheetData.splice(row, 0, newRow);
            refreshExcelGrid();
            console.log('Inserted row above row', row + 1);
        }
        
        // Insert row below
        function insertRowBelow(row) {
            saveExcelState('Insert Row Below');
            const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
            const newRow = Array(sheetData[0].length).fill('');
            sheetData.splice(row + 1, 0, newRow);
            refreshExcelGrid();
            console.log('Inserted row below row', row + 1);
        }
        
        // Delete row
        function deleteRow(row) {
            if (!confirm(`Delete row ${row + 1}?`)) return;
            
            saveExcelState('Delete Row');
            const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
            sheetData.splice(row, 1);
            refreshExcelGrid();
            console.log('Deleted row', row + 1);
        }
        
        // Insert column left
        function insertColumnLeft(col) {
            saveExcelState('Insert Column Left');
            const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
            sheetData.forEach(row => row.splice(col, 0, ''));
            refreshExcelGrid();
            console.log('Inserted column left of', getColumnLetter(col));
        }
        
        // Insert column right
        function insertColumnRight(col) {
            saveExcelState('Insert Column Right');
            const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
            sheetData.forEach(row => row.splice(col + 1, 0, ''));
            refreshExcelGrid();
            console.log('Inserted column right of', getColumnLetter(col));
        }
        
        // Delete column
        function deleteColumn(col) {
            if (!confirm(`Delete column ${getColumnLetter(col)}?`)) return;
            
            saveExcelState('Delete Column');
            const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
            sheetData.forEach(row => row.splice(col, 1));
            refreshExcelGrid();
            console.log('Deleted column', getColumnLetter(col));
        }
        
        // Sort column
        function sortColumn(col, direction = 'asc') {
            saveExcelState('Sort Column');
            const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
            
            // Get all rows with data (skip header if needed)
            const dataRows = sheetData.map((row, index) => ({ row, index }));
            
            // Sort the rows based on column value
            dataRows.sort((a, b) => {
                const aVal = a.row[col] || '';
                const bVal = b.row[col] || '';
                
                // Try to parse as numbers
                const aNum = parseFloat(aVal);
                const bNum = parseFloat(bVal);
                
                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return direction === 'asc' ? aNum - bNum : bNum - aNum;
                }
                
                // Sort as strings
                const comparison = String(aVal).localeCompare(String(bVal));
                return direction === 'asc' ? comparison : -comparison;
            });
            
            // Update sheet data with sorted rows
            currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet] = dataRows.map(item => item.row);
            
            refreshExcelGrid();
            console.log('Sorted column', getColumnLetter(col), direction);
        }
        
        // Refresh the Excel grid
        function refreshExcelGrid() {
            const sheetData = currentExcelSpreadsheet.data[currentExcelSpreadsheet.activeSheet];
            const gridContainer = document.getElementById('excelGridContainer');
            if (gridContainer) {
                gridContainer.innerHTML = renderExcelGrid(sheetData);
                attachExcelCellListeners();
                setTimeout(() => recalculateAllFormulas(), 10);
            }
        }
        
        function handleExcelKeyboard(e) {
            const gridContainer = document.getElementById('excelGridContainer');
            const activeCell = document.querySelector('.excel-data-cell.excel-cell-selected');
            
            if (!gridContainer) return;
            
            // Save shortcut (Ctrl+S)
            if (e.ctrlKey && e.key === 's') {
                if (document.activeElement.classList.contains('excel-data-cell')) {
                    e.preventDefault();
                    saveExcelSpreadsheet();
                }
            }
            
            // Copy (Ctrl+C)
            if (e.ctrlKey && e.key === 'c' && activeCell) {
                e.preventDefault();
                copyExcelCells();
            }
            
            // Cut (Ctrl+X)
            if (e.ctrlKey && e.key === 'x' && activeCell) {
                e.preventDefault();
                cutExcelCells();
            }
            
            // Paste (Ctrl+V)
            if (e.ctrlKey && e.key === 'v' && activeCell) {
                e.preventDefault();
                pasteExcelCells();
            }
            
            // Undo (Ctrl+Z)
            if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undoExcel();
            }
            
            // Redo (Ctrl+Y or Ctrl+Shift+Z)
            if ((e.ctrlKey && e.key === 'y') || (e.ctrlKey && e.shiftKey && e.key === 'z')) {
                e.preventDefault();
                redoExcel();
            }
            
            // Delete cell content (Delete key)
            if (e.key === 'Delete' && activeCell && !activeCell.isContentEditable) {
                e.preventDefault();
                deleteExcelCellContent();
            }
            
            // Fill down (Ctrl+D)
            if (e.ctrlKey && e.key === 'd' && activeCell) {
                e.preventDefault();
                fillDown();
            }
            
            // Fill right (Ctrl+R)
            if (e.ctrlKey && e.key === 'r' && activeCell) {
                e.preventDefault();
                fillRight();
            }
            
            // Find (Ctrl+F)
            if (e.ctrlKey && e.key === 'f') {
                e.preventDefault();
                openFindDialog();
            }
            
            // Select All (Ctrl+A)
            if (e.ctrlKey && e.key === 'a' && document.activeElement.classList.contains('excel-data-cell')) {
                e.preventDefault();
                selectAllCells();
            }
            
            // Format Menu (Ctrl+Shift+F)
            if (e.ctrlKey && e.shiftKey && e.key === 'F') {
                e.preventDefault();
                showFormatMenu();
            }
            
            // Bold (Ctrl+B)
            if (e.ctrlKey && e.key === 'b' && activeCell) {
                e.preventDefault();
                applyCellFormatting('fontWeight', 'bold');
            }
            
            // Italic (Ctrl+I)
            if (e.ctrlKey && e.key === 'i' && activeCell) {
                e.preventDefault();
                applyCellFormatting('fontStyle', 'italic');
            }
            
            // Underline (Ctrl+U)
            if (e.ctrlKey && e.key === 'u' && activeCell) {
                e.preventDefault();
                applyCellFormatting('textDecoration', 'underline');
            }
        }

        // Create spreadsheet button handler
        if (createExcelButton) {
            createExcelButton.addEventListener('click', async () => {
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
                const defaultPath = await getDefaultDocumentsPath();
                const filePath = `${defaultPath}\\spreadsheet_${timestamp}.xlsx`;
                
                createExcelButton.disabled = true;
                createExcelButton.textContent = 'Creating...';
                
                try {
                    const response = await fetch('http://localhost:8000/api/excel/create', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            file_path: filePath,
                            sheet_name: 'Sheet1'
                        })
                    });

                    const data = await response.json();
                    if (response.ok && data.success) {
                        // Open the spreadsheet in the editor immediately
                        openExcelEditor(filePath, data.sheets || ['Sheet1'], data.active_sheet || 'Sheet1', null);
                    } else {
                        const errorMsg = data.detail || data.message || data.error || 'Failed to create spreadsheet';
                        alert('Error creating spreadsheet:\\n\\n' + errorMsg);
                    }
                } catch (error) {
                    console.error('Error creating spreadsheet:', error);
                    alert('Error creating spreadsheet: ' + error.message);
                } finally {
                    createExcelButton.disabled = false;
                    createExcelButton.textContent = 'Create Spreadsheet';
                }
            });
        }
        
        // Excel Open Modal - Get all elements first
        const excelOpenModal = document.getElementById('excelOpenModal');
        const excelOpenModalClose = document.getElementById('excelOpenModalClose');
        const excelOpenCancel = document.getElementById('excelOpenCancel');
        const excelOpenSubmit = document.getElementById('excelOpenSubmit');
        const excelOpenFilePath = document.getElementById('excelOpenFilePath');
        const excelOpenFilePathBrowse = document.getElementById('excelOpenFilePathBrowse');
        const excelOpenFileInput = document.getElementById('excelOpenFilePathInput');
        
        // Open spreadsheet button handler
        if (openExcelButton) {
            openExcelButton.addEventListener('click', () => {
                if (excelOpenModal) {
                    excelOpenModal.style.display = 'flex';
                    console.log('Modal opened');
                }
            });
        }
        
        // Close modal when clicking outside
        if (excelOpenModal) {
            excelOpenModal.addEventListener('click', (e) => {
                if (e.target === excelOpenModal) {
                    excelOpenModal.style.display = 'none';
                    console.log('Modal closed (clicked outside)');
                }
            });
        }
        
        // Close modal handlers
        if (excelOpenModalClose) {
            excelOpenModalClose.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (excelOpenModal) {
                    excelOpenModal.style.display = 'none';
                    console.log('Modal closed (X button)');
                }
            });
        } else {
            console.warn('X close button not found!');
        }
        
        if (excelOpenCancel) {
            excelOpenCancel.addEventListener('click', (e) => {
                e.preventDefault();
                if (excelOpenModal) {
                    excelOpenModal.style.display = 'none';
                    console.log('Modal closed (Cancel button)');
                }
            });
        } else {
            console.warn('Cancel button not found!');
        }
        
        // Add Escape key support
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && excelOpenModal && excelOpenModal.style.display === 'flex') {
                excelOpenModal.style.display = 'none';
                console.log('Modal closed (Escape key)');
            }
        });
        
        // Browse button for open modal
        console.log('Setting up browse button...');
        console.log('Browse button element:', excelOpenFilePathBrowse);
        console.log('File input element:', excelOpenFileInput);
        
        if (excelOpenFilePathBrowse && excelOpenFileInput) {
            console.log('Both elements found, adding event listener');
            
            excelOpenFilePathBrowse.addEventListener('click', async (e) => {
                console.log('Browse button clicked!');
                e.preventDefault();
                e.stopPropagation();
                
                // First, try using backend API to get full path via native dialog
                try {
                    console.log('Trying backend file picker API...');
                    
                    const defaultPath = await getDefaultDocumentsPath();
                    const response = await fetch(`http://localhost:8000/api/excel/select-file?initial_path=${encodeURIComponent(defaultPath)}`);
                    
                    if (response.ok) {
                        const result = await response.json();
                        console.log('Backend response:', result);
                        
                        if (result.success && result.file_path) {
                            // Got the full path from backend!
                            if (excelOpenFilePath) {
                                excelOpenFilePath.value = result.file_path;
                                console.log('‚úÖ Full path from backend:', result.file_path);
                            }
                            return; // Success, don't use HTML file input
                        } else if (result.cancelled) {
                            console.log('User cancelled file selection');
                            return;
                        }
                    }
                } catch (error) {
                    console.warn('Backend file picker not available:', error.message);
                }
                
                // Fallback: Use HTML file input
                console.log('Falling back to HTML file input...');
                excelOpenFileInput.click();
            });
        } else {
            console.error('Elements not found!', {
                browseButton: !!excelOpenFilePathBrowse,
                fileInput: !!excelOpenFileInput
            });
        }
        
        if (excelOpenFileInput) {
            console.log('Adding change listener to file input');
            
            // Handle file selection from Windows file picker
            excelOpenFileInput.addEventListener('change', async (e) => {
                console.log('File input change event fired');
                console.log('Files:', e.target.files);
                
                const file = e.target.files[0];
                if (file) {
                    console.log('File selected:', file);
                    console.log('File name:', file.name);
                    console.log('File size:', file.size);
                    console.log('File type:', file.type);
                    console.log('File path:', file.path);
                    console.log('File webkitRelativePath:', file.webkitRelativePath);
                    
                    // Try multiple ways to get the full path
                    let fullPath = null;
                    
                    // Method 1: Direct path property (works in Electron, pywebview, etc.)
                    if (file.path) {
                        fullPath = file.path;
                        console.log('‚úÖ Got path from file.path:', fullPath);
                    }
                    // Method 2: webkitRelativePath
                    else if (file.webkitRelativePath) {
                        fullPath = file.webkitRelativePath;
                        console.log('‚úÖ Got path from webkitRelativePath:', fullPath);
                    }
                    // Method 3: Check if File System Access API is available
                    else if (window.showOpenFilePicker) {
                        console.log('File System Access API available but not used yet');
                    }
                    
                    if (excelOpenFilePath) {
                        if (fullPath) {
                            // Full path is available
                            excelOpenFilePath.value = fullPath;
                            console.log('‚úÖ File path set to input:', fullPath);
                        } else {
                            // Path not available - just show filename
                            console.warn('‚ö†Ô∏è Full path not available');
                            excelOpenFilePath.value = file.name;
                            console.log('‚ÑπÔ∏è Set filename only:', file.name);
                            
                            // Update placeholder to guide user
                            excelOpenFilePath.setAttribute('data-filename-only', 'true');
                            excelOpenFilePath.select(); // Highlight so user can easily replace
                        }
                    }
                }
            });
        }
        
        // Open spreadsheet submit handler
        if (excelOpenSubmit) {
            excelOpenSubmit.addEventListener('click', async () => {
                const filePath = excelOpenFilePath ? excelOpenFilePath.value.trim() : '';
                
                if (!filePath) {
                    alert('Please enter the full file path to your Excel spreadsheet.\n\nExample: D:\\Documents\\data.xlsx');
                    if (excelOpenFilePath) excelOpenFilePath.focus();
                    return;
                }
                
                // Validate that it looks like a file path
                if (!filePath.includes('\\') && !filePath.includes('/')) {
                    alert('Please enter the FULL file path including the folder location.\n\nExample: D:\\Documents\\' + filePath);
                    return;
                }
                
                excelOpenSubmit.disabled = true;
                excelOpenSubmit.textContent = 'Opening...';
                
                try {
                    console.log('==========================================');
                    console.log('üìÇ Opening spreadsheet...');
                    console.log('File path:', filePath);
                    console.log('Request URL:', 'http://localhost:8000/api/excel/open');
                    
                    const response = await fetch('http://localhost:8000/api/excel/open', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            file_path: filePath
                        })
                    });
                    
                    console.log('Response status:', response.status, response.statusText);
                    
                    const data = await response.json();
                    console.log('Server response data:', JSON.stringify(data, null, 2));
                    
                    if (response.ok && data.success) {
                        console.log('‚úÖ Success! Opening editor...');
                        console.log('Sheets:', data.sheets);
                        console.log('Active sheet:', data.active_sheet);
                        console.log('Has data:', !!data.data);
                        // Close the modal
                        if (excelOpenModal) excelOpenModal.style.display = 'none';
                        
                        // Clear the input
                        if (excelOpenFilePath) excelOpenFilePath.value = '';
                        
                        // Transform the data from backend format to frontend format
                        let transformedData = {};
                        
                        console.log('üì¶ Processing backend data...');
                        console.log('Has all_sheets_data?', !!data.all_sheets_data);
                        console.log('all_sheets_data keys:', data.all_sheets_data ? Object.keys(data.all_sheets_data) : 'N/A');
                        
                        // Check if we have all sheets data (new format)
                        if (data.all_sheets_data && typeof data.all_sheets_data === 'object') {
                            console.log('‚úÖ Loading all sheets from all_sheets_data');
                            
                            // Transform each sheet's data
                            for (const [sheetName, sheetData] of Object.entries(data.all_sheets_data)) {
                                console.log(`Processing sheet: ${sheetName}, rows: ${sheetData.length}`);
                                
                                if (Array.isArray(sheetData)) {
                                    transformedData[sheetName] = sheetData.map(row => {
                                        return row.map(cell => {
                                            // Extract just the value or formula
                                            if (cell && typeof cell === 'object') {
                                                return cell.formula || cell.value || '';
                                            }
                                            return cell || '';
                                        });
                                    });
                                    console.log(`‚úÖ Transformed ${sheetName}: ${transformedData[sheetName].length} rows`);
                                }
                            }
                            
                            console.log('‚úÖ All sheets loaded:', Object.keys(transformedData));
                        }
                        // Fallback to old format (single sheet data)
                        else if (data.data && Array.isArray(data.data)) {
                            console.log('Loading single sheet from data field (backward compatibility)');
                            
                            const sheetData = data.data.map(row => {
                                return row.map(cell => {
                                    // Extract just the value or formula
                                    if (cell && typeof cell === 'object') {
                                        return cell.formula || cell.value || '';
                                    }
                                    return cell || '';
                                });
                            });
                            
                            const activeSheet = data.active_sheet || data.sheets?.[0] || 'Sheet1';
                            transformedData[activeSheet] = sheetData;
                            
                            // Initialize other sheets as empty if they exist
                            if (data.sheets && data.sheets.length > 1) {
                                data.sheets.forEach(sheetName => {
                                    if (sheetName !== activeSheet && !transformedData[sheetName]) {
                                        transformedData[sheetName] = Array(30).fill().map(() => Array(15).fill(''));
                                    }
                                });
                            }
                        }
                        
                        console.log('Transformed data structure:', transformedData);
                        
                        // Open the spreadsheet in the editor
                        openExcelEditor(
                            data.file_path || filePath,
                            data.sheets || ['Sheet1'],
                            data.active_sheet || data.sheets?.[0] || 'Sheet1',
                            transformedData
                        );
                        
                        console.log('‚úÖ Spreadsheet opened successfully!');
                        console.log('==========================================');
                    } else {
                        console.error('‚ùå Failed to open spreadsheet');
                        console.error('Response:', data);
                        const errorMsg = data.detail || data.message || data.error || 'Unknown error';
                        alert('‚ùå Error opening spreadsheet:\n\n' + errorMsg + '\n\nüìã Details:\n‚Ä¢ File: ' + filePath + '\n\n‚úì Make sure:\n1. The file exists at that location\n2. The path is correct\n3. The file is a valid .xlsx or .xls file\n4. The file is not open in another program');
                        console.log('==========================================');
                    }
                } catch (error) {
                    console.error('‚ùå Exception while opening spreadsheet');
                    console.error('Error:', error);
                    console.error('Stack:', error.stack);
                    alert('‚ùå Error opening spreadsheet:\n\n' + error.message + '\n\nüîß Please check:\n1. The backend server is running\n2. The file path is correct: ' + filePath + '\n3. You have permission to access the file\n4. Check the console (F12) for details');
                    console.log('==========================================');
                } finally {
                    excelOpenSubmit.disabled = false;
                    excelOpenSubmit.textContent = 'Open Spreadsheet';
                }
            });
        }

        // Check authentication on page load
        window.addEventListener('DOMContentLoaded', () => {
            const userId = localStorage.getItem('user_id');
            const authToken = localStorage.getItem('auth_token');
            
            if (!userId && authToken) {
                // Try to extract user_id from token
                try {
                    // JWT tokens have 3 parts separated by dots
                    const tokenParts = authToken.split('.');
                    if (tokenParts.length === 3) {
                        // Decode the payload (second part)
                        const payload = JSON.parse(atob(tokenParts[1]));
                        if (payload.user_id) {
                            localStorage.setItem('user_id', payload.user_id.toString());
                            console.log('[AUTH] Extracted user_id from token:', payload.user_id);
                        }
                    }
                } catch (e) {
                    console.warn('[AUTH] Could not extract user_id from token:', e);
                }
            }
            
            // Final check - if still no user_id, warn but don't block
            const finalUserId = localStorage.getItem('user_id');
            if (!finalUserId) {
                console.warn('[AUTH] No user_id found. Chat conversations will not be saved to database.');
                console.warn('[AUTH] Please log in again to enable conversation recording.');
            } else {
                console.log('[AUTH] User authenticated. user_id:', finalUserId);
            }
        });
    </script>
</body>
</html>
